From 11173a802bf9974ad9383aa6e6b96156b2e7862e Mon Sep 17 00:00:00 2001
From: "pinky@asuslappy" <al_borland33@yahoo.de>
Date: Thu, 6 Oct 2011 15:00:02 +0200
Subject: [PATCH]  cpufrequ src add

---
 tdt/cvs/cdk/make/release.mk                       |    4 +-
 tdt/cvs/cdk/root/release/cpu_frequ_spark_stm23.ko |  Bin 5881 -> 0 bytes
 tdt/cvs/driver/Makefile                           |    1 +
 tdt/cvs/driver/cpu_frequ/Makefile                 |    9 +
 tdt/cvs/driver/cpu_frequ/cpu_frequ.c              | 1111 +++++++++++
 tdt/cvs/driver/cpu_frequ/cpu_frequ_stb7100.c      | 1021 +++++++++++
 tdt/cvs/driver/cpu_frequ/pll0_check_stb7100.c     |   65 +
 tdt/cvs/driver/cpu_frequ/pll1_check_stb7100.c     |   65 +
 tdt/cvs/driver/cpu_frequ/pll_check_stx7105.c      |   65 +
 tdt/cvs/driver/pti/Makefile                       |   25 +-
 tdt/cvs/driver/pti/Makefile.public                |    8 +
 tdt/cvs/driver/pti/compile                        |    8 +
 tdt/cvs/driver/pti/pti.h                          | 1083 ++++++++++-
 tdt/cvs/driver/pti/pti_buffer.c                   |  374 ++++
 tdt/cvs/driver/pti/pti_buffer.h                   |   25 +
 tdt/cvs/driver/pti/pti_descrambler.c              |  225 +++
 tdt/cvs/driver/pti/pti_descrambler.h              |    9 +
 tdt/cvs/driver/pti/pti_filter.c                   |    4 +
 tdt/cvs/driver/pti/pti_hal.c                      | 2030 +++++++++++++++++++++
 tdt/cvs/driver/pti/pti_hal.h                      |   81 +-
 tdt/cvs/driver/pti/pti_main.c                     | 1583 ++++++----------
 tdt/cvs/driver/pti/pti_main.h                     |   20 +
 tdt/cvs/driver/pti/pti_process.c                  |  478 +++++
 tdt/cvs/driver/pti/pti_session.c                  |  139 ++
 tdt/cvs/driver/pti/pti_session.h                  |    7 +
 tdt/cvs/driver/pti/pti_slot.c                     |  270 +++
 tdt/cvs/driver/pti/pti_slot.h                     |   15 +
 tdt/cvs/driver/pti/tc_code.h                      | 1312 ++++++++++++-
 tdt/cvs/driver/pti/ts_makros.h                    |   72 +
 29 files changed, 8884 insertions(+), 1225 deletions(-)
 delete mode 100755 tdt/cvs/cdk/root/release/cpu_frequ_spark_stm23.ko
 create mode 100644 tdt/cvs/driver/cpu_frequ/Makefile
 create mode 100644 tdt/cvs/driver/cpu_frequ/cpu_frequ.c
 create mode 100644 tdt/cvs/driver/cpu_frequ/cpu_frequ_stb7100.c
 create mode 100644 tdt/cvs/driver/cpu_frequ/pll0_check_stb7100.c
 create mode 100644 tdt/cvs/driver/cpu_frequ/pll1_check_stb7100.c
 create mode 100644 tdt/cvs/driver/cpu_frequ/pll_check_stx7105.c
 create mode 100644 tdt/cvs/driver/pti/Makefile.public
 create mode 100755 tdt/cvs/driver/pti/compile
 create mode 100644 tdt/cvs/driver/pti/pti_buffer.c
 create mode 100644 tdt/cvs/driver/pti/pti_buffer.h
 create mode 100644 tdt/cvs/driver/pti/pti_descrambler.c
 create mode 100644 tdt/cvs/driver/pti/pti_descrambler.h
 create mode 100644 tdt/cvs/driver/pti/pti_filter.c
 create mode 100644 tdt/cvs/driver/pti/pti_hal.c
 create mode 100644 tdt/cvs/driver/pti/pti_main.h
 create mode 100644 tdt/cvs/driver/pti/pti_process.c
 create mode 100644 tdt/cvs/driver/pti/pti_session.c
 create mode 100644 tdt/cvs/driver/pti/pti_session.h
 create mode 100644 tdt/cvs/driver/pti/pti_slot.c
 create mode 100644 tdt/cvs/driver/pti/pti_slot.h
 create mode 100644 tdt/cvs/driver/pti/ts_makros.h

diff --git a/tdt/cvs/cdk/make/release.mk b/tdt/cvs/cdk/make/release.mk
index 7b7e144..f21d0c2 100644
--- a/tdt/cvs/cdk/make/release.mk
+++ b/tdt/cvs/cdk/make/release.mk
@@ -229,7 +229,8 @@ release_spark:
 	cp $(kernelprefix)/linux-sh4/drivers/usb/serial/usbserial.ko $(prefix)/release/lib/modules
 #	cp $(kernelprefix)/linux-sh4/fs/autofs4/autofs4.ko $(prefix)/release/lib/modules
 if STM23
-	cp $(buildprefix)/root/release/cpu_frequ_spark_stm23.ko $(prefix)/release/lib/modules/cpu_frequ.ko
+#	cp $(buildprefix)/root/release/cpu_frequ_spark_stm23.ko $(prefix)/release/lib/modules/cpu_frequ.ko
+	[ -e $(targetprefix)/lib/modules/$(KERNELVERSION)/extra/cpu_frequ/cpu_frequ.ko ] && cp $(targetprefix)/lib/modules/$(KERNELVERSION)/extra/cpu_frequ/cpu_frequ.ko $(prefix)/release/lib/modules || true
 endif
 #	install autofs
 	cp -f $(targetprefix)/usr/sbin/automount $(prefix)/release/usr/sbin/
@@ -1280,6 +1281,7 @@ if STM24
 	[ -e $(kernelprefix)/linux-sh4/drivers/usb/serial/pl2303.ko ] && cp $(kernelprefix)/linux-sh4/drivers/usb/serial/pl2303.ko $(prefix)/release/lib/modules || true
 	[ -e $(kernelprefix)/linux-sh4/drivers/usb/serial/usbserial.ko ] && cp $(kernelprefix)/linux-sh4/drivers/usb/serial/usbserial.ko $(prefix)/release/lib/modules || true
 	[ -e $(kernelprefix)/linux-sh4/fs/ntfs/ntfs.ko ] && cp $(kernelprefix)/linux-sh4/fs/ntfs/ntfs.ko $(prefix)/release/lib/modules || true
+	[ -e $(targetprefix)/lib/modules/$(KERNELVERSION)/extra/cpu_frequ/cpu_frequ.ko ] && cp $(targetprefix)/lib/modules/$(KERNELVERSION)/extra/cpu_frequ/cpu_frequ.ko $(prefix)/release/lib/modules || true
 endif
 
 #GSTREAMER STUFF
diff --git a/tdt/cvs/cdk/root/release/cpu_frequ_spark_stm23.ko b/tdt/cvs/cdk/root/release/cpu_frequ_spark_stm23.ko
deleted file mode 100755
index e5760a1e01f51386e64254ce990619d55bc5ab42..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 5881
zcmeHKYiu0V6~4RU;Kw*%uM_+TZD!Yr6BDxQwU>~jq^#{EcFM-<#zCbBb@nl{-m&+U
zeT49kVv&lH;wVr;l&Wr<R#C-|RD!zdFMd!7RYg>l*Rdf`S`omAQYs!oR@6GU-<g>k
zU#}=?`@3g#_k8C$=RW7o@qMBF4u^wra<E(3ip1D?nXw%(226*otcf+SD&Tc!657Df
zJ?zX6zW1xx@n6n6FTOE<uF%@h{P|D*YP#dEw(JSJ^xE0lnUQE~?=8_Sj_NC|o8@3z
zmGo3cxS7eUjlD0`GS=n(Jo14RRm)a>b%<Xds4Lga$a5}T4%Rt4`)bRzeb@5U&NgRz
zV|Cf%?g-0f#EHLb=;zN>epbz)kZmO|M}wO_Ki#m`isw3!x6SyUYJ1hCG{u`n<9aL>
zi#BvGojerliMF^A*?S0b)f0vIojp6-KRVqrdefYvzh<FZ=^1ql9NW@xG8TKd-HPeE
z9@7_9{Ekx(L|fY%_WkXNZbfF!2vaZyHi^%_VP-^o%*PhuNlzHPe@`lRgq`ja5t%I}
zzsO&VCERAmd&2P~#cz8`8f^_OzbwVB<!|o3>4}c8m8&w2%krg`pgh|h?Q~ba-MQsq
z_Xfq;UNa*HYgtWM(&S#pUY=peDhKn(*zz*3?J?h3-!FW>@%4}Y&iAS>^5%QK$c!f(
znZJ5m4mlHQSu&=z@66W+p8K&YDThuZ?w>t@bs~+?O1W>gdg0{ewko-AYWHjG-kE9b
z-ua7xHpd$Ox5{-lx{{qkClYd~b|`Gc7!-5xdd$ULud$)>v^F$96=-9QjV|(KcbBE)
z)Xr(`8}pL^OLG7<OzxW22H|IE_S-)DuKVn@efqEa^p>Tusom3B5EWTbcl}vPUPR`}
zfE>D{zY~=VNAK6>CwDa^T)t~Zr!_e=6_Cd6z}QXg-Z;Bs&ZF;`mHVW)d$vad*QYfp
z(K9cHE(R#iCCGAUGC;MxlbF`F!-9CT_HC$34t<(vLRFs(Q|(((*ZQuy8#?!+kNfL)
zJsqhz-Vt8RET$Jzi{p!9iw3P1bD!B0vy(XHY7mU?JK8@H$W_qSu*=KGfa}30!PkMG
z2X6uYHMj!)d+<%*Z-Re}_8A%x-+T2qNVcNgi8hSJ*ObWXX8NO8-|wFFjTp4ToAer`
z>Xej}v^5y1r*-tg;49S1zB<oFdwrkv#m)G-_X4!S2U@ojV%Lt)8sBnCN;J>63^bRU
zFCB_)@HCe_o4X^e9-KoR&R3l6+d8gYdAK9CxfLt>P_(gEIz1BefG?d~TV@MuFW)%V
z+EHDOx#huHRzD{XvW1TD(-CV#tz}N*#c(b**lT}z`6JVyq0hO0({DZov_JZd)>%*3
zgA--xG+RKOms{o<B3EB#<}+)QmXm9~$rhUM>>oBtn#<gMjo5vSGcNtgm66z2`r4!S
z``x{A@Rq>ZveR94#OYpBZiv)Js$XGl_7;sH%|Fd$6&j7>BdALxnr~i{$f>^S%Qdfi
z!Zma9fk*Xf^B*G+T{Irm*UW9}T{(v+Ujv$g_L#42hIYOu+&U)**+R=3HOgmK+^3wk
zHox9H*Zz!rKuX+<o;J@p-N9UQxv^oQp#|EXC)StO&ow<m+I6OubWP}0Fy}I5b_M+z
zYqDqHg2OsDZ^JW1qIVQ?TJ=nzuQd=Av<M9K;6dnesZ^Jm(Tt;N8h@tj7v*$TE2Y%r
zLvUyDTuDvj^&=(VgQQmm?^E_Do3%Q|`tKg-Rfj{NF13IE04Y<)pk2}XEA)pC-qWQX
z?hhXld~My(;nh0-7x<B`(y#jq{7ARTkBaIG4}=dM7#>l!7K+iL5$~jO(TNp(T8|b=
zd0pcc>|JzCAu@fHgM;_gv5~=msS<VY^H=)yhwe7V#*b&mv*~m}ji<(ei|JCA4Oz;F
z>zRVSXJ9zQqNQRoo8OZ$ii~M`A)YsKMI)QpGolxj{^5I+{WJ%9<{@3lW|Wb`u{-=-
zbWFiFr)RXn9>PcUd^$R6#P@W2cX+#dy#71XLNVRlqjvebdz4&W*VDP8g4tC|nN&8a
zDd<dSpThn@!Cyk+8u${o|C|1s5g6$2->qyNIegHF=d*fBj~DaVj1e#RLPn-^OzDdj
z^iCz<?ePYb?yjy~eoP^5o&QUaxA0)P7>zM+p_sRLlA}zvsC!2<C2y=`q_pjZ#=Lnw
z74;VNV?`V4$Bd#V8(5-T&T7$Ol+yaW0p`WRGBSxQ^ODw%rraqbGoH=Fb#F0g6jbwY
z(U~_^C@?SW3_XKKnT6m^y&bzVPW$9Pr44YT8!wJLlLGkPWMg9Hc?gcdV>tTQ4QNCW
zv=`S9vPiMH7o5kC>fDWxk-QO@o<TM`N576H=2MW^yjws|#B=NtFzKi8qPP>B@{teE
zHv}x^yBGN`K*x#aI{*d8WV?)f&w^7v>Ko7ZZD7jRjYhNt<Kv{TiTp@R+MJKyck#k_
z-1Z^HpLN9cqi-Lgdc1zPjbx4=0j9j%kFNI-;kgQIL=T|x7?LN@ffjJ;2R^+_8;$c>
zG?a8b-vkbGde?H|Ier9%@EAsZW86uwT@WytKcJU`Ks*Q4!TUgF@}v77C+<g_j~&_0
zAuxzQ7ci|&s*mcWx3!q>@;b)cLLkrA1wRKZR!|PjajOX#UJJ~j;16Vuai@hRz#JPb
zd>fK*+(p>F9NbUXUI;W7Jm-gk{wiU5IB1FRRtrCgq8&a9pCN45bB?gRf6fc|S;BVx
z&k6b$1pJbK{~+Kw0lz8WcLn^ufIk%Q$AmkqI<FE|EW9N6&}8tMs{~vl;1J<<D|VQ$
z$HH$Bw#V=);q7*Q!u%Wo=lBd^+vl91pCU|$4Cp*zdps`?w#RJ~Z1(kz(KI;x<jojO
zC(m!L6T}eFnaA}h!rMq|uOHjTTtBo3L3D9&Y&M~_mTaF1(%U}YC2X%xIuCgMNkRXl
z;D1K&IVbo`2|niq{kw#zqo5G2x360G%l@TRJDm2Duz?ULnY(QzgJhnFqD&{r3Q6X!
z6lH93fh6-JT2V-B?TP>-F}xfElGshFDy(9kEc1ve_&E^29-J_j%^^TH>d~C|(N>$l
zcuatkyce9R=KdqV5eOG-dlI}}u&058h~H$}X|9RL$ASKS-^O&tl1%3&ox60Lko-J2
zC#wIq5cZ<cvLO2`_%PZ|TYei{!TO<f;X=KC2PcZ4hDMCvKY`Dq(a4frf}V)tUFem|
zmPyxu=BbeB93!Isx-g%2RoH3maH9Cb75-EQC$i@uzX(qIf$EvC?Yy4Tkb|&MpUM8y
ziuh-3xeE41^y>Kv`wJEFOOO>f(;lUKf2^?osX~6ombw3@6?VFdaH9S+RmdwJY~Hwu
zH6vg7!I#&gnwrN~P?kNAH;TGi@j(bt{2sjSBP!GMeP~%ssM5twwZCZmT|0L$OJjZ4
zKykaR5I%084G8rj0ctkGN-15nzijL<{%vzRE9G#%)Kz>)!6aTORfMFX53+blk7i0a
ze$z~4v$=wr)AQ<>kw`p<paQ;n3r3G>1dNr(t8}qN?6_Lci!?gADU9kxMi!nej=`f5
z%V*;%ZmxMeE}Dv~vFvCzZR83<KDs#bVpo~X>#=zarZF@#rN?QSs6In4Fe)IP%Erfe
r1y(tQT;9kO6AUF;GiH64=k;{<=&FheMmmQ9q)UFbltPC~LWlnaK}^^l

diff --git a/tdt/cvs/driver/Makefile b/tdt/cvs/driver/Makefile
index 923d374..efa6cd3 100644
--- a/tdt/cvs/driver/Makefile
+++ b/tdt/cvs/driver/Makefile
@@ -184,6 +184,7 @@ endif
 
 ifdef SPARK
 obj-y	+= smartcard/
+obj-y   += cpu_frequ/
 endif
 
 ifdef OCTAGON1008
diff --git a/tdt/cvs/driver/cpu_frequ/Makefile b/tdt/cvs/driver/cpu_frequ/Makefile
new file mode 100644
index 0000000..0f207b7
--- /dev/null
+++ b/tdt/cvs/driver/cpu_frequ/Makefile
@@ -0,0 +1,9 @@
+ifeq ($(KERNELRELEASE),)
+DRIVER_TOPDIR:=$(shell pwd)/..
+include $(DRIVER_TOPDIR)/kernel.make
+else
+obj-m           += cpu_frequ.o
+
+#EXTRA_CFLAGS	:= -DDEBUG
+EXTRA_CFLAGS    := -I$(DRIVER_TOPDIR)/include -I$(DRIVER_TOPDIR)/dvb/drivers/media/dvb
+endif
diff --git a/tdt/cvs/driver/cpu_frequ/cpu_frequ.c b/tdt/cvs/driver/cpu_frequ/cpu_frequ.c
new file mode 100644
index 0000000..2fee215
--- /dev/null
+++ b/tdt/cvs/driver/cpu_frequ/cpu_frequ.c
@@ -0,0 +1,1111 @@
+/*
+ * cpu_frequ.c
+ * 
+ * nit 08.11.2010
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/clock.h>
+//#include <asm/timer.h>
+
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+
+#ifdef DEBUG
+#define dprintk(fmt, args...) printk(fmt, ##args)
+#else
+#define dprintk(fmt, args...)
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_STX7100) || defined(CONFIG_CPU_SUBTYPE_STB7100)
+#define STB7100
+#elif defined (CONFIG_CPU_SUBTYPE_STX7111)
+
+#define STX7111
+
+#elif defined (CONFIG_CPU_SUBTYPE_STX7105)
+
+#define STX7105
+
+#else
+#error unknown arch
+#endif
+
+#ifdef STB7100
+#define CKGA_BASE_ADDR          0xb9213000
+#define CKGA_LCK                (CKGA_BASE_ADDR + 0x00) 
+#define CKGA_MD_STA             (CKGA_BASE_ADDR + 0x04) 
+#define CKGA_PLL0_CFG           (CKGA_BASE_ADDR + 0x08) 
+#define CKGA_PLL0_LCK_STA       (CKGA_BASE_ADDR + 0x10) 
+#define CKGA_PLL0_CLK1          (CKGA_BASE_ADDR + 0x14)
+#define CKGA_PLL0_CLK2          (CKGA_BASE_ADDR + 0x18)
+#define CKGA_PLL0_CLK3          (CKGA_BASE_ADDR + 0x1c)
+#define CKGA_PLL0_CLK4          (CKGA_BASE_ADDR + 0x20)
+#define CKGA_PLL1_CFG           (CKGA_BASE_ADDR + 0x24) 
+#define CKGA_PLL1_LCK_STA       (CKGA_BASE_ADDR + 0x2c) 
+#define CKGA_CLK_DIV            (CKGA_BASE_ADDR + 0x30) 
+#define CKGA_CLK_EN             (CKGA_BASE_ADDR + 0x34) 
+#define CKGA_CLKOUT_SEL         (CKGA_BASE_ADDR + 0x38) 
+#define CKGA_PLL1_BYPASS        (CKGA_BASE_ADDR + 0x3c) 
+
+#define _TMU_TSTR               0xffd80004
+#define _TMU0_TCOR              0xffd80008
+#define _TMU0_TCNT              0xffd8000c
+#define _TMU0_TCR               0xffd80010
+
+#define _TMU1_TCOR              0xffd80014
+#define _TMU1_TCNT              0xffd80018
+#define _TMU1_TCR               0xffd8001c
+#define _TMU_TSTR_INIT          0x3    /* enable both TMU0 and TMU1 */
+
+#define _CONFIG_SH_EXTERNAL_CLOCK 27000000
+#endif
+
+#if defined(STX7105) || defined(STX7111)
+#define CKGA_BASE_ADDR          0xFE213000
+#define CKGA_PLL0_CFG           (CKGA_BASE_ADDR + 0x00) 
+#define CKGA_PLL1_CFG           (CKGA_BASE_ADDR + 0x04) 
+#define CKGA_POWER_CFG          (CKGA_BASE_ADDR + 0x10) 
+
+//TODO: richtige TMU Werte ermitteln
+#define _TMU_TSTR               0xffd80004
+#define _TMU0_TCOR              0xffd80008
+#define _TMU0_TCNT              0xffd8000c
+#define _TMU0_TCR               0xffd80010
+
+#define _TMU1_TCOR              0xffd80014
+#define _TMU1_TCNT              0xffd80018
+#define _TMU1_TCR               0xffd8001c
+
+#define _TMU2_TCOR              0xffd80020
+#define _TMU2_TCNT              0xffd80024
+#define _TMU2_TCR               0xffd80028
+//TODO: ende
+#define _TMU_TSTR_INIT          0x7   /* enable TMU0/1/2 */
+
+#define _CONFIG_SH_EXTERNAL_CLOCK 30000000
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  void set_actual_latch(unsigned long val_actual_latch);
+#endif
+
+int modul_hz = HZ;
+static struct proc_dir_entry 
+*cpu_dir, 
+*pll0_ndiv_mdiv, 
+*pll1_ndiv_mdiv, 
+#ifdef STB7100
+*pll1_clk_div, 
+*pll1_fdma_bypass, 
+*sh4_ratio, 
+*sh4_ic_ratio, 
+*module_ratio, 
+*slim_ratio, 
+*sysaclkout, 
+#endif
+*m_hz; 
+
+unsigned long get_pll0_frequ(void)
+{
+  unsigned long value, freq_pll0 = 0, ndiv, pdiv, mdiv;
+#ifdef STB7100
+  value = ctrl_inl(CKGA_PLL0_CFG);
+  mdiv = (value >>  0) & 0xff;
+  ndiv = (value >>  8) & 0xff;
+  pdiv = (value >> 16) & 0x7;
+  freq_pll0 = (((2 * (_CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv) / (1 << pdiv)) * 1000;
+#endif
+#if defined(STX7105) || defined(STX7111)
+  value = ctrl_inl(CKGA_PLL0_CFG);
+  mdiv = (value >> 0) & 0x07;
+  ndiv = (value >> 8) & 0xff;
+  freq_pll0 = ((2 * (_CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv) * 1000;
+#endif
+  return freq_pll0;
+}
+
+struct clk* set_clock(char* name, unsigned long frequ)
+{
+  struct clk *clk;
+
+  printk("%s ->%s(%ld)\n", __func__, name, frequ);
+  
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get(name);
+#else
+  clk=clk_get(NULL, name);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+  if(clk)
+#else
+  if (!IS_ERR(clk))
+#endif
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+    clk_set_rate(clk, frequ);
+#else
+   
+    if(clk->ops->recalc)
+    {
+      clk->ops->recalc(clk);
+    }
+#endif
+#endif
+  }
+  else
+  {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+     clk = NULL;
+#endif
+    printk("[CPU_FREQU] %s not found\n", name);
+  }
+  
+  return clk;
+}
+
+void update_bogomips(unsigned long sh4_hz)
+{
+  unsigned long bogomips;
+
+  bogomips=(sh4_hz / 1000000) - 3;
+  bogomips=bogomips * (500000/modul_hz);
+  boot_cpu_data.loops_per_jiffy = bogomips;
+  current_cpu_data.loops_per_jiffy = bogomips;
+  loops_per_jiffy = bogomips;
+}
+
+int update_tmu(unsigned long parent_rate)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+  struct clk *clk;
+  unsigned long actual_latch = LATCH;
+
+  while(ctrl_inl(_TMU0_TCNT) != 0x0);  // wait for tmu0 interrupt
+  ctrl_outb(ctrl_inb(_TMU_TSTR) & ~(_TMU_TSTR_INIT), _TMU_TSTR); // stop all tmu
+
+  clk=set_clock("tmu0_clk", 0);
+  if(clk)
+  {
+    clk->parent->rate = parent_rate;
+    clk=set_clock("tmu0_clk", 0);
+    // set tmu0 to actual frequ
+    actual_latch = (clk_get_rate(clk) + modul_hz / 2) / modul_hz;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    set_actual_latch(actual_latch);  // set actual latch in kernel
+#endif
+    ctrl_outl(actual_latch, _TMU0_TCOR);
+    ctrl_outl(actual_latch, _TMU0_TCNT);
+  }
+
+  ctrl_outb(ctrl_inb(_TMU_TSTR) | _TMU_TSTR_INIT, _TMU_TSTR); // start all tmu
+#else
+  unsigned long actual_latch = LATCH, frequ, value;
+  int module_div=2;
+
+  struct sh_timer_priv {
+    void (*priv_handler) (void *data);
+    void *data;
+    struct sh_timer_callb *fnc;
+  };
+
+  struct sh_tmu_priv {
+    void __iomem *mapbase;
+    struct clk *clk;
+    struct irqaction irqaction;
+    struct platform_device *pdev;
+    unsigned long rate;
+    unsigned long periodic;
+    struct clock_event_device ced;
+    struct clocksource cs;
+    struct sh_timer_priv tm;
+  };
+
+  struct sh_tmu_priv *p = NULL;
+  struct device *dev = NULL;
+  struct clock_event_device *ced = NULL;
+  struct clocksource *cs = NULL;
+
+#ifdef STB7100
+  frequ = get_pll0_frequ();
+
+  // get module frequ
+  value = ctrl_inl(CKGA_PLL0_CLK3);
+  switch(value) {
+    case 0: module_div=8;break;
+    case 1: module_div=4;break;
+    case 2: module_div=8;break;
+    case 3: module_div=8;break;
+    case 4: module_div=12;break;
+    case 5: module_div=16;break;
+    case 6: module_div=8;break;
+    case 7: module_div=8;break;
+  }
+
+  frequ = frequ / module_div / 4;
+#endif
+#if defined(STX7105) || defined(STX7111)
+  //TODO: tmu0 frequ berechnen
+#endif
+  dev = bus_find_device_by_name(&platform_bus_type, NULL, "sh_tmu.0");
+  if(dev)
+  {
+    p = dev_get_drvdata(dev);
+    if(p != NULL)
+    {
+      ced = &p->ced;
+      ced->set_mode(CLOCK_EVT_MODE_PERIODIC, ced);
+    }
+  }
+  dev = bus_find_device_by_name(&platform_bus_type, NULL, "sh_tmu.1");
+  if(dev)
+  {
+    p = dev_get_drvdata(dev);
+    if(p != NULL)
+    {
+      cs = &p->cs;
+      cs->disable(cs);
+      clocksource_unregister(cs);
+      clocksource_register(cs);
+      cs->enable(cs);
+    }
+  }
+#endif
+
+  return 0;
+}
+
+void __delay(unsigned long loops)
+{
+  __asm__ __volatile__(
+    "tst    %0, %0\n\t"
+    "1:\t"
+    "bf/s   1b\n\t"
+    " dt    %0"
+    : "=r" (loops)
+    : "0" (loops)
+    : "t");
+}
+
+unsigned long calc_bogomips(void)
+{
+  unsigned long ticks, loopbit;
+  int lps_precision = 8;
+
+  loops_per_jiffy = (1<<12);
+
+  while ((loops_per_jiffy <<= 1) != 0) {
+    /* wait for "start of" clock tick */
+    ticks = jiffies;
+    while (ticks == jiffies)
+      /* nothing */;
+    /* Go .. */
+    ticks = jiffies;
+    __delay(loops_per_jiffy);
+    ticks = jiffies - ticks;
+    if (ticks)
+      break;
+  }
+  /*
+  * Do a binary approximation to get loops_per_jiffy set to
+  * equal one clock (up to lps_precision bits)
+  */
+  loops_per_jiffy >>= 1;
+  loopbit = loops_per_jiffy;
+  while (lps_precision-- && (loopbit >>= 1)) {
+    loops_per_jiffy |= loopbit;
+    ticks = jiffies;
+    while (ticks == jiffies)
+      /* nothing */;
+    ticks = jiffies;
+    __delay(loops_per_jiffy);
+    if (jiffies != ticks)   /* longer than 1 tick */
+      loops_per_jiffy &= ~loopbit;
+  }	
+
+  return (loops_per_jiffy);
+}
+
+static int read_ratio(char *page, char **start,
+                        off_t off, int count,
+                        int *eof, void *data)
+{
+  int len=0;
+  unsigned long value, bogomips;
+  int sh4_div=2, sh4_ic_div=2, module_div=2, slim_div=2, slim_bypass=0;
+  unsigned long freq_pll0, freq_pll1, ndiv, pdiv, mdiv, val_sysaclkout=0;
+
+  len+=sprintf(page+len, "Modul HZ = %d\n", modul_hz);
+
+#ifdef STB7100
+  value = ctrl_inl(CKGA_LCK);
+  len+=sprintf(page+len, "CKGA_LCK = %lx\n", value);
+
+  value = ctrl_inl(CKGA_MD_STA);
+  len+=sprintf(page+len, "CKGA_MD_STA = %lx\n", value);
+#endif
+
+  value = ctrl_inl(CKGA_PLL0_CFG);
+  len+=sprintf(page+len, "CKGA_PLL0_CFG = %lx\n", value);
+
+#ifdef STB7100
+  mdiv = (value >>  0) & 0xff;
+  ndiv = (value >>  8) & 0xff;
+  pdiv = (value >> 16) & 0x7;
+  freq_pll0 = (((2 * (_CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv) / (1 << pdiv)) * 1000;
+  freq_pll0 = freq_pll0 / 1000000;
+
+  value = ctrl_inl(CKGA_PLL0_LCK_STA);
+  len+=sprintf(page+len, "CKGA_PLL0_LCK_STA = %lx\n", value);
+
+  value = ctrl_inl(CKGA_PLL0_CLK1);
+  len+=sprintf(page+len, "CKGA_PLL0_CLK1 = %lx\n", value);
+
+  switch(value) {
+    case 0: sh4_div=2;break;
+    case 1: sh4_div=4;break;
+    case 2: sh4_div=6;break;
+    case 3: sh4_div=8;break;
+    case 4: sh4_div=12;break;
+    case 5: sh4_div=16;break;
+    case 6: sh4_div=2;break;
+    case 7: sh4_div=2;break;
+  }
+
+  value = ctrl_inl(CKGA_PLL0_CLK2);
+  len+=sprintf(page+len, "CKGA_PLL0_CLK2 = %lx\n", value);
+
+  switch(value) {
+    case 0: sh4_ic_div=2;break;
+    case 1: sh4_ic_div=4;break;
+    case 2: sh4_ic_div=6;break;
+    case 3: sh4_ic_div=8;break;
+    case 4: sh4_ic_div=12;break;
+    case 5: sh4_ic_div=16;break;
+    case 6: sh4_ic_div=4;break;
+    case 7: sh4_ic_div=4;break;
+  }
+
+  value = ctrl_inl(CKGA_PLL0_CLK3);
+  len+=sprintf(page+len, "CKGA_PLL0_CLK3 = %lx\n", value);
+
+  switch(value) {
+    case 0: module_div=8;break;
+    case 1: module_div=4;break;
+    case 2: module_div=8;break;
+    case 3: module_div=8;break;
+    case 4: module_div=12;break;
+    case 5: module_div=16;break;
+    case 6: module_div=8;break;
+    case 7: module_div=8;break;
+  }
+
+  value = ctrl_inl(CKGA_PLL0_CLK4);
+  len+=sprintf(page+len, "CKGA_PLL0_CLK4 = %lx\n", value);
+
+  switch(value) {
+    case 0: slim_div=2;break;
+    case 1: slim_div=4;break;
+    case 2: slim_div=6;break;
+    case 3: slim_div=8;break;
+    case 4: slim_div=12;break;
+    case 5: slim_div=16;break;
+    case 6: slim_div=6;break;
+    case 7: slim_div=6;break;
+  }
+#endif
+#if defined(STX7105) || defined(STX7111)
+  mdiv = (value >>  0) & 0x07;
+  ndiv = (value >>  8) & 0xff;
+  freq_pll0 = (((2 * (_CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv)) * 1000;
+  freq_pll0 = freq_pll0 / 1000000;
+
+  sh4_div = 2;
+#endif
+
+  value = ctrl_inl(CKGA_PLL1_CFG);
+  len+=sprintf(page+len, "CKGA_PLL1_CFG = %lx\n", value);
+
+#ifdef STB7100
+  mdiv = (value >>  0) & 0xff;
+  ndiv = (value >>  8) & 0xff;
+  pdiv = (value >> 16) & 0x7;
+  freq_pll1 = (((2 * (_CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv) / (1 << pdiv)) * 1000;
+  freq_pll1 = freq_pll1 / 1000000;
+
+  value = ctrl_inl(CKGA_PLL1_LCK_STA);
+  len+=sprintf(page+len, "CKGA_PLL1_LCK_STA = %lx\n", value);
+
+  value = ctrl_inl(CKGA_CLK_DIV);
+  len+=sprintf(page+len, "CKGA_CLK_DIV = %lx\n", value);
+
+  value = ctrl_inl(CKGA_CLK_EN);
+  len+=sprintf(page+len, "CKGA_CLK_EN = %lx\n", value);
+	
+  value = ctrl_inl(CKGA_PLL1_BYPASS);
+  len+=sprintf(page+len, "CKGA_PLL1_BYPASS = %lx\n", value);
+  slim_bypass=value & 0x01;
+
+  value = ctrl_inl(CKGA_CLKOUT_SEL);
+  len+=sprintf(page+len, "CKGA_CLKOUT_SEL = %lx\n", value);
+	
+  switch(value) {
+    case 0: val_sysaclkout=freq_pll0/sh4_div;break;
+    case 1: val_sysaclkout=freq_pll0/sh4_ic_div;break;
+    case 2: val_sysaclkout=freq_pll0/module_div;break;
+    case 3: if(slim_bypass == 0) 
+              val_sysaclkout=freq_pll0/slim_div;
+            else
+              val_sysaclkout=freq_pll1;
+            break;
+    case 4: val_sysaclkout=freq_pll0/slim_div;break;
+    case 5: val_sysaclkout=freq_pll1;break;
+    case 6: val_sysaclkout=freq_pll1;break;
+    case 7: val_sysaclkout=freq_pll1;break;
+    case 8: val_sysaclkout=freq_pll1;break;
+    case 9: val_sysaclkout=freq_pll1/2;break;
+    case 10: val_sysaclkout=freq_pll1/4;break;
+    case 11: val_sysaclkout=freq_pll1/4;break;
+  }
+  len+=sprintf(page+len, "SYSACLKOUT (standard 266MHZ) = %ldMHZ\n", val_sysaclkout);
+#endif
+#if defined(STX7105) || defined(STX7111)
+  mdiv = (value >>  0) & 0x07;
+  ndiv = (value >>  8) & 0xff;
+  freq_pll1 = (((2 * (_CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv)) * 1000;
+  freq_pll1 = freq_pll1 / 1000000;
+#endif
+
+  value = ctrl_inl(_TMU0_TCOR);
+  len+=sprintf(page+len, "TMU0_TCOR = %lx\n", value);
+
+  value = ctrl_inl(_TMU0_TCNT);
+  len+=sprintf(page+len, "TMU0_TCNT = %lx\n", value);
+
+  value = ctrl_inl(_TMU1_TCOR);
+  len+=sprintf(page+len, "TMU1_TCOR = %lx\n", value);
+
+  value = ctrl_inl(_TMU1_TCNT);
+  len+=sprintf(page+len, "TMU1_TCNT = %lx\n", value);
+
+#if defined(STX7105) || defined(STX7111)
+  value = ctrl_inl(_TMU2_TCOR);
+  len+=sprintf(page+len, "TMU2_TCOR = %lx\n", value);
+
+  value = ctrl_inl(_TMU2_TCNT);
+  len+=sprintf(page+len, "TMU2_TCNT = %lx\n", value);
+#endif
+
+  len+=sprintf(page+len, "\n");
+  len+=sprintf(page+len, "BOGOMIPS (static)= %ld\n", (freq_pll0 / sh4_div) - 3);
+
+  bogomips = calc_bogomips();
+  bogomips = bogomips/(500000/modul_hz);
+  len+=sprintf(page+len, "BOGOMIPS (measured)= %ld\n", bogomips);
+
+  len+=sprintf(page+len, "\n");
+  len+=sprintf(page+len, "PLL0     = %ld MHZ\n", freq_pll0);
+  len+=sprintf(page+len, "SH4      = %ld MHZ\n", freq_pll0 / sh4_div);
+#ifdef STB7100
+  len+=sprintf(page+len, "SH4_IC   = %ld MHZ\n", freq_pll0 / sh4_ic_div);
+  len+=sprintf(page+len, "MODULE   = %ld MHZ\n", freq_pll0 / module_div);
+
+  if(slim_bypass == 0)
+    len+=sprintf(page+len, "SLIM     = %ld MHZ\n", freq_pll0 / slim_div);
+  else
+    len+=sprintf(page+len, "SLIM     = %ld MHZ\n", freq_pll1);
+#endif
+  len+=sprintf(page+len, "PLL1     = %ld MHZ\n", freq_pll1);
+#ifdef STB7100
+  len+=sprintf(page+len, "COMMS    = %ld MHZ\n", freq_pll1 / 4);
+  len+=sprintf(page+len, "TMU0     = %ld MHZ\n", (freq_pll0 / module_div) / 4);
+  len+=sprintf(page+len, "TMU1     = %ld MHZ\n", (freq_pll0 / module_div) / 4);
+
+  len+=sprintf(page+len, "\n");
+  len+=sprintf(page+len, "sh4 ratio (2,4,6,8,12,16)\n");
+  len+=sprintf(page+len, "sh4_ic ratio (2,4,6,8,12,16)\n");
+  len+=sprintf(page+len, "module ratio (4,8,12,16)\n");
+  len+=sprintf(page+len, "slim ratio (2,4,6,8,12,16)\n");
+#endif
+
+  return len;
+}
+
+static int write_pll1_ndiv_mdiv(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  struct clk *clk;
+  unsigned long regdata, sta;
+  int ndiv=0, mdiv=0;
+  int ndiv_mdiv=simple_strtoul(buffer, NULL, 10);
+#if defined(STX7105) || defined(STX7111)
+  unsigned long regdata1;
+#endif
+
+#ifdef STB7100
+  mdiv = (ndiv_mdiv >> 0) & 0xff;
+  ndiv = (ndiv_mdiv >> 8) & 0xff;
+#endif
+#if defined(STX7105) || defined(STX7111)
+  mdiv = (ndiv_mdiv >> 0) & 0x07;
+  ndiv = (ndiv_mdiv >> 8) & 0xff;
+#endif
+
+  if(mdiv<0 || mdiv>255)
+  {
+    dprintk("[CPU_FREQU] mdiv not correct, use another PLL1 Frequenze (%d)\n", mdiv);
+    return count;
+  }
+  if(ndiv<3 || ndiv>255)
+  {
+    dprintk("[CPU_FREQU] ndiv not correct, use another PLL1 Frequenze (%d)\n", ndiv);
+    return count;
+  }
+
+#ifdef STB7100
+  ctrl_outl(0xC0DE, CKGA_LCK);
+#endif
+
+  regdata = ctrl_inl(CKGA_PLL1_CFG);  // get data from register
+
+#ifdef STB7100
+  //ctrl_outl(0x00000002, CKGA_PLL1_BYPASS);  // set to SYSACLKIN
+#endif
+#if defined(STX7105) || defined(STX7111)
+  regdata = regdata | 1 << 20;  // set to SYSACLKIN
+  ctrl_outl(regdata, CKGA_PLL1_CFG);
+#endif
+
+#ifdef STB7100
+  //regdata = regdata & ~(1 << 19);  // disable PLL1
+  //ctrl_outl(regdata, CKGA_PLL1_CFG);
+#endif
+#if defined(STX7105) || defined(STX7111)
+  regdata1 = ctrl_inl(CKGA_POWER_CFG);  // get data from register
+  regdata1 = regdata1 | 0x2;
+  ctrl_outl(regdata1, CKGA_POWER_CFG);  //power down PLL1
+#endif
+
+#ifdef STB7100
+  regdata = regdata & ~(0xff);  // clear MDIV
+  regdata = regdata & ~(0xff) << 8;   // clear NDIV
+  regdata = regdata & ~(0x07) << 16;  // clear PDIV
+
+  regdata = regdata | mdiv;  // set MDIV
+  regdata = regdata | ndiv << 8;  // set NDIV
+  regdata = regdata | (0x1 & 0x7)  << 16;  // set PDIV
+#endif
+#if defined(STX7105) || defined(STX7111)
+  regdata = regdata & ~(0x07);  // clear MDIV
+  regdata = regdata & ~(0xff) << 8;   // clear NDIV
+
+  regdata = regdata | mdiv;  // set MDIV
+  regdata = regdata | ndiv << 8;  // set NDIV
+  ctrl_outl(regdata, CKGA_PLL1_CFG);
+#endif
+
+#ifdef STB7100
+  //regdata = regdata | 1 << 19;  // aktivate PLL1
+  ctrl_outl(regdata, CKGA_PLL1_CFG);
+#endif
+#if defined(STX7105) || defined(STX7111)
+  regdata1 = regdata1 & ~(0x2);
+  ctrl_outl(regdata1, CKGA_POWER_CFG);  //power up PLL1
+#endif
+
+#ifdef STB7100
+  // wait for lock
+/*
+  sta = ctrl_inl(CKGA_PLL1_LCK_STA);
+  while(sta & 0x01) == 0x00);
+  {
+    sta = ctrl_inl(CKGA_PLL1_LCK_STA);
+  }
+*/
+#endif
+#if defined(STX7105) || defined(STX7111)
+  sta = ctrl_inl(CKGA_PLL1_CFG);
+  while((sta & 0x80000000) == 0x00)
+  {
+    sta = ctrl_inl(CKGA_PLL1_CFG);
+  }
+#endif
+
+#ifdef STB7100
+  //ctrl_outl(0x00000000, CKGA_PLL1_BYPASS);  // set to PLL1_CLK
+#endif
+#if defined(STX7105) || defined(STX7111)
+  regdata = regdata & ~(1 << 20);  // set to PLL1 CLK
+  ctrl_outl(regdata, CKGA_PLL1_CFG);
+#endif
+
+#ifdef STB7100
+  ctrl_outl(0x0, CKGA_LCK);
+
+  // set /proc
+  clk=set_clock("pll1_clk", 0);
+  if(clk)
+  {
+    clk_disable(clk);
+    clk_enable(clk);
+  }
+#endif
+#if defined(STX7105) || defined(STX7111)
+  // set /proc
+  clk=set_clock("CLKA_PLL1", 0);
+  //FIXME: fuer stx7105 setze alle pll1 abhaengigen clocks
+#endif
+
+  set_clock("comms_clk", 0);
+
+  return count;
+}
+
+static int write_pll0_ndiv_mdiv(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  struct clk *clk;
+  unsigned long regdata, sta, frequ;
+  int ndiv=0, mdiv=0;
+  int ndiv_mdiv=simple_strtoul(buffer, NULL, 10);
+#if defined(STX7105) || defined(STX7111)
+  unsigned long regdata1;
+#endif
+
+#ifdef STB7100
+  mdiv = (ndiv_mdiv >> 0) & 0xff;
+  ndiv = (ndiv_mdiv >> 8) & 0xff;
+#endif
+#if defined(STX7105) || defined(STX7111)
+  mdiv = (ndiv_mdiv >> 0) & 0x07;
+  ndiv = (ndiv_mdiv >> 8) & 0xff;
+#endif
+
+  if(mdiv<0 || mdiv>255)
+  {
+    dprintk("[CPU_FREQU] mdiv not correct, use another PLL0 Frequenze (%d)\n", mdiv);
+    return count;
+  }
+  if(ndiv<3 || ndiv>255)
+  {
+    dprintk("[CPU_FREQU] ndiv not correct, use another PLL0 Frequenze (%d)\n", ndiv);
+    return count;
+  }
+
+#ifdef STB7100
+  ctrl_outl(0xC0DE, CKGA_LCK);
+#endif
+
+  regdata = ctrl_inl(CKGA_PLL0_CFG);  // get data from register
+
+#ifdef STB7100
+  regdata = regdata | 1 << 20;  // set to SYSACLKIN
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+  regdata = regdata & ~(1 << 19);  // disable PLL0
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+#endif
+#if defined(STX7105) || defined(STX7111)
+//  regdata1 = ctrl_inl(CKGA_POWER_CFG);  // get data from register
+//  regdata1 = regdata1 | 0x1;
+//  ctrl_outl(regdata1, CKGA_POWER_CFG);  //power down PLL0
+#endif
+
+#ifdef STB7100
+  regdata = regdata & ~(0xff);  // clear MDIV
+  regdata = regdata & ~(0xff) << 8;   // clear NDIV
+  regdata = regdata & ~(0x07) << 16;  // clear PDIV
+
+  regdata = regdata | mdiv;  // set MDIV
+  regdata = regdata | ndiv << 8;  // set NDIV
+  regdata = regdata | (0x0 & 0x7)  << 16;  // set PDIV
+#endif
+#if defined(STX7105) || defined(STX7111)
+  regdata = regdata & ~(0x07);  // clear MDIV
+  regdata = regdata & ~(0xff) << 8;   // clear NDIV
+
+  regdata = regdata | mdiv;  // set MDIV
+  regdata = regdata | ndiv << 8;  // set NDIV
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+#endif
+
+#ifdef STB7100
+  regdata = regdata | 1 << 19;  // aktivate PLL0
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+#endif
+#if defined(STX7105) || defined(STX7111)
+//  regdata1 = regdata1 & ~(0x1);
+//  ctrl_outl(regdata1, CKGA_POWER_CFG);  //power up PLL0
+#endif
+
+#ifdef STB7100
+  // wait for lock
+  sta = ctrl_inl(CKGA_PLL0_LCK_STA);
+  while((sta & 0x01) == 0x00)
+  {
+    sta = ctrl_inl(CKGA_PLL0_LCK_STA);
+  }
+#endif
+#if defined(STX7105) || defined(STX7111)
+//  sta = ctrl_inl(CKGA_PLL0_CFG);
+//  while((sta & 0x80000000) == 0x00)
+//  {
+//    sta = ctrl_inl(CKGA_PLL0_CFG);
+//  }
+#endif
+
+#ifdef STB7100
+  regdata = regdata & ~(1 << 20);  // set to PLL0 CLK
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+#endif
+
+#ifdef STB7100
+  ctrl_outl(0x0, CKGA_LCK);
+
+  // set /proc
+  clk=set_clock("pll0_clk", 0);
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+    clk_disable(clk);
+    clk_enable(clk);
+#else
+    clk->rate = get_pll0_frequ();
+    clk=set_clock("pll0_clk", 0);
+#endif
+  }
+#endif
+
+#if defined(STX7105) || defined(STX7111)
+  // set /proc does not work in smt23
+  frequ = get_pll0_frequ();
+  //set_clock("CLKA_PLL0HS", frequ);
+  //set_clock("CLKA_PLL0LS", frequ / 2);
+  //set_clock("CLKA_ST40_ICK", frequ / 2);
+  //set_clock("CLKA_LX_DMU_CPU", frequ / 2);
+  //set_clock("CLKA_LX_AUD_CPU", frequ / 2);
+  //set_clock("CLKA_ETH_PHY", frequ / 36);
+  update_bogomips(frequ / 2);
+#endif
+
+#ifdef STB7100
+  clk=set_clock("sh4_clk", 0);
+  if(clk)
+  {
+    // set bogomips in /proc/cpuinfo (use sh4 clock - 3)
+    // measured bogomit not always correct in running system
+    update_bogomips(clk_get_rate(clk));
+  }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+  set_clock("sh4_ic_clk", 0);
+#else
+  set_clock("st40_ic_clk", 0);
+#endif
+
+  clk=set_clock("module_clk", 0);
+  if(clk)
+    update_tmu(clk_get_rate(clk));
+
+  set_clock("slim_clk", 0);
+#endif
+
+  return count;
+}
+
+#ifdef STB7100
+static int write_sh4_ratio(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value;
+  int sh4_ratio=simple_strtoul(buffer, NULL, 10);
+  struct clk *clk;
+
+  switch(sh4_ratio) {
+    case 2:value=0x0;break;
+    case 4:value=0x1;break;
+    case 6:value=0x2;break;
+    case 8:value=0x3;break;
+    case 12:value=0x4;break;
+    case 16:value=0x5;break;
+    default:
+      dprintk("[CPU_FREQU] sh4 ratio (%d) not correct, use 2,4,8,12 or 16\n", sh4_ratio);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  //0x0=1, 0x1=2, 0x2=3, 0x3=4, 0x4=6, 0x5=8
+  ctrl_outl(value, CKGA_PLL0_CLK1);  // set sh4 ratio
+  ctrl_outl(0x0, CKGA_LCK);
+
+  clk=set_clock("sh4_clk", 0);
+  if(clk)
+  {
+    // set bogomips in /proc/cpuinfo (use sh4 clock - 3)
+    // measured bogomit not always correct in running system
+    update_bogomips(clk_get_rate(clk));
+  }
+
+  return count;
+}
+
+static int write_sh4_ic_ratio(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value;
+  int sh4_ic_ratio=simple_strtoul(buffer, NULL, 10);
+
+  switch(sh4_ic_ratio) {
+    case 2:value=0x0;break;
+    case 4:value=0x1;break;
+    case 6:value=0x2;break;
+    case 8:value=0x3;break;
+    case 12:value=0x4;break;
+    case 16:value=0x5;break;
+    default:
+      dprintk("[CPU_FREQU] sh4_ic ratio (%d) not correct, use 2,4,6,8,12 or 16\n", sh4_ic_ratio);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  //0x0=1, 0x1=2, 0x2=3, 0x3=4, 0x4=6, 0x5=8
+  ctrl_outl(value, CKGA_PLL0_CLK2);  // set sh4_ic ratio
+  ctrl_outl(0x0, CKGA_LCK);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+  set_clock("sh4_ic_clk", 0);
+#else
+  set_clock("st40_ic_clk", 0);
+#endif
+
+  return count;
+}
+
+static int write_module_ratio(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value;
+  int module_ratio=simple_strtoul(buffer, NULL, 10);
+  struct clk *clk;
+
+  switch(module_ratio) {
+    case 8:value=0x0;break;
+    case 4:value=0x1;break;
+    case 12:value=0x4;break;
+    case 16:value=0x5;break;
+    default:
+      dprintk("[CPU_FREQU] module ratio (%d) not correct, use 4,8,12 or 16\n", module_ratio);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  //0x0=4, 0x1=2, 0x2=4, 0x3=4, 0x4=6, 0x5=8
+  ctrl_outl(value, CKGA_PLL0_CLK3);  // set module ratio
+  ctrl_outl(0x0, CKGA_LCK);
+
+  clk=set_clock("module_clk", 0);
+  if(clk)
+    update_tmu(clk_get_rate(clk));
+
+  return count;
+}
+
+static int write_slim_ratio(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value;
+  int slim_ratio=simple_strtoul(buffer, NULL, 10);
+
+  switch(slim_ratio) {
+    case 2:value=0x0;break;
+    case 4:value=0x1;break;
+    case 6:value=0x2;break;
+    case 8:value=0x3;break;
+    case 12:value=0x4;break;
+    case 16:value=0x5;break;
+    default:
+      dprintk("[CPU_FREQU] slim ratio (%d) not correct, use 2,4,6,8,12 or 16\n", slim_ratio);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  //0x0=1, 0x1=2, 0x2=3, 0x3=4, 0x4=6, 0x5=8
+  ctrl_outl(value, CKGA_PLL0_CLK4);  // set slim ratio
+  ctrl_outl(0x0, CKGA_LCK);
+
+  set_clock("slim_clk", 0);
+
+  return count;
+}
+
+static int write_pll1_fdma_bypass(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value;
+  int pll1_bypass=simple_strtoul(buffer, NULL, 10);
+
+  switch(pll1_bypass) {
+    case 0:value=0x0;break;
+    case 1:value=0x1;break;
+    default:
+      dprintk("[CPU_FREQU] pll1_fdma_bypass (%d) not correct, use 0 or 1\n", pll1_bypass);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  ctrl_outl(value, CKGA_PLL1_BYPASS);  // set FDMA to PPL1 HZ
+  ctrl_outl(0x0, CKGA_LCK);
+
+  set_clock("slim_clk", 0);
+
+  return count;
+}
+
+static int write_sysaclkout(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  int val_sysaclkout=simple_strtoul(buffer, NULL, 10);
+
+  if(val_sysaclkout<0 || val_sysaclkout>11)
+  {
+    dprintk("[CPU_FREQU] sysaclkout (%d) not correct, use 0 to 11\n", val_sysaclkout);
+    return count;
+  }
+        
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  ctrl_outl(val_sysaclkout, CKGA_CLKOUT_SEL);  // set CKGA_CLKOUT_SEL
+  ctrl_outl(0x0, CKGA_LCK);
+
+  return count;
+}
+
+static int write_pll1_clk_div(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  int clk_div=simple_strtoul(buffer, NULL, 10);
+        
+  if(clk_div<0 || clk_div>15)
+  {
+    dprintk("[CPU_FREQU] pll1_clk_div (%d) not correct, use 0 to 15\n", clk_div);
+    return count;
+  }
+        
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  ctrl_outl(clk_div, CKGA_CLK_DIV);  // set CKGA_CLK_DIV
+  ctrl_outl(0x0, CKGA_LCK);
+
+  return count;
+}
+#endif
+
+static int write_m_hz(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  modul_hz=simple_strtoul(buffer, NULL, 10);
+
+  return count;
+}
+
+int __init cpu_frequ_init(void)
+{
+  dprintk("[CPU_FREQU] initializing ...\n");
+
+  cpu_dir=proc_mkdir("cpu_frequ",NULL);
+  if(cpu_dir==NULL)
+    return -ENOMEM;
+
+  pll0_ndiv_mdiv=create_proc_entry("pll0_ndiv_mdiv",0644,cpu_dir);
+  pll0_ndiv_mdiv->read_proc=read_ratio;
+  pll0_ndiv_mdiv->write_proc=write_pll0_ndiv_mdiv;
+
+  pll1_ndiv_mdiv=create_proc_entry("pll1_ndiv_mdiv",0644,cpu_dir);
+  pll1_ndiv_mdiv->read_proc=read_ratio;
+  pll1_ndiv_mdiv->write_proc=write_pll1_ndiv_mdiv;
+
+#ifdef STB7100
+  sh4_ratio=create_proc_entry("sh4_ratio",0644,cpu_dir);
+  sh4_ratio->read_proc=read_ratio;
+  sh4_ratio->write_proc=write_sh4_ratio;
+
+  sh4_ic_ratio=create_proc_entry("sh4_ic_ratio",0644,cpu_dir);
+  sh4_ic_ratio->read_proc=read_ratio;
+  sh4_ic_ratio->write_proc=write_sh4_ic_ratio;
+
+  module_ratio=create_proc_entry("module_ratio",0644,cpu_dir);
+  module_ratio->read_proc=read_ratio;
+  module_ratio->write_proc=write_module_ratio;
+
+  slim_ratio=create_proc_entry("slim_ratio",0644,cpu_dir);
+  slim_ratio->read_proc=read_ratio;
+  slim_ratio->write_proc=write_slim_ratio;
+
+  pll1_fdma_bypass=create_proc_entry("pll1_fdma_bypass",0644,cpu_dir);
+  pll1_fdma_bypass->read_proc=read_ratio;
+  pll1_fdma_bypass->write_proc=write_pll1_fdma_bypass;
+ 	
+  pll1_clk_div=create_proc_entry("pll1_clk_div",0644,cpu_dir);
+  pll1_clk_div->read_proc=read_ratio;
+  pll1_clk_div->write_proc=write_pll1_clk_div;
+ 	
+  sysaclkout=create_proc_entry("sysaclkout",0644,cpu_dir);
+  sysaclkout->read_proc=read_ratio;
+  sysaclkout->write_proc=write_sysaclkout;
+#endif
+ 	
+  m_hz=create_proc_entry("modul_hz",0644,cpu_dir);
+  m_hz->read_proc=read_ratio;
+  m_hz->write_proc=write_m_hz;
+
+ return 0;
+}
+
+void __exit cpu_frequ_exit(void)
+{
+  dprintk("[CPU_FREQU] unloading ...\n");
+  remove_proc_entry("pll0_ndiv_mdiv", cpu_dir);
+  remove_proc_entry("pll1_ndiv_mdiv", cpu_dir);
+#ifdef STB7100
+  remove_proc_entry("sh4_ratio", cpu_dir);
+  remove_proc_entry("sh4_ic_ratio", cpu_dir);
+  remove_proc_entry("module_ratio", cpu_dir);
+  remove_proc_entry("slim_ratio", cpu_dir);
+  remove_proc_entry("pll1_fdma_bypass", cpu_dir);
+  remove_proc_entry("pll1_clk_div", cpu_dir);
+  remove_proc_entry("sysaclkout", cpu_dir);
+#endif
+  remove_proc_entry("modul_hz", cpu_dir);
+  //remove_proc_entry("cpu_dir", &proc_root);
+}
+
+module_init(cpu_frequ_init);
+module_exit(cpu_frequ_exit);
+
+MODULE_DESCRIPTION("Set CPU Frequenze on STb710x");
+MODULE_AUTHOR("nit");
+MODULE_LICENSE("GPL");
diff --git a/tdt/cvs/driver/cpu_frequ/cpu_frequ_stb7100.c b/tdt/cvs/driver/cpu_frequ/cpu_frequ_stb7100.c
new file mode 100644
index 0000000..2f7075e
--- /dev/null
+++ b/tdt/cvs/driver/cpu_frequ/cpu_frequ_stb7100.c
@@ -0,0 +1,1021 @@
+/*
+ * cpu_frequ.c
+ * 
+ * nit 08.11.2010
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/clock.h>
+#include <asm/timer.h>
+
+#ifdef DEBUG
+#define dprintk(fmt, args...) printk(fmt, ##args)
+#else
+#define dprintk(fmt, args...)
+#endif
+
+//#define STB7100
+#define STX7105
+
+#ifdef STB7100
+#define CKGA_BASE_ADDR          0xb9213000
+#define CKGA_LCK                (CKGA_BASE_ADDR + 0x00) 
+#define CKGA_MD_STA             (CKGA_BASE_ADDR + 0x04) 
+#define CKGA_PLL0_CFG           (CKGA_BASE_ADDR + 0x08) 
+#define CKGA_PLL0_LCK_STA       (CKGA_BASE_ADDR + 0x10) 
+#define CKGA_PLL0_CLK1          (CKGA_BASE_ADDR + 0x14)
+#define CKGA_PLL0_CLK2          (CKGA_BASE_ADDR + 0x18)
+#define CKGA_PLL0_CLK3          (CKGA_BASE_ADDR + 0x1c)
+#define CKGA_PLL0_CLK4          (CKGA_BASE_ADDR + 0x20)
+#define CKGA_PLL1_CFG           (CKGA_BASE_ADDR + 0x24) 
+#define CKGA_PLL1_LCK_STA       (CKGA_BASE_ADDR + 0x2c) 
+#define CKGA_CLK_DIV            (CKGA_BASE_ADDR + 0x30) 
+#define CKGA_CLK_EN             (CKGA_BASE_ADDR + 0x34) 
+#define CKGA_CLKOUT_SEL         (CKGA_BASE_ADDR + 0x38) 
+#define CKGA_PLL1_BYPASS        (CKGA_BASE_ADDR + 0x3c) 
+
+#define TMU_TSTR_INIT           0x3    /* enable both TMU0 and TMU1 */
+#endif
+
+#ifdef STX7105 
+#define CKGA_BASE_ADDR          0xFE213000
+
+/*
+#define CKGA_LCK                (CKGA_BASE_ADDR + 0x00) 
+#define CKGA_MD_STA             (CKGA_BASE_ADDR + 0x04) 
+#define CKGA_PLL0_LCK_STA       (CKGA_BASE_ADDR + 0x10) 
+#define CKGA_PLL0_CLK1          (CKGA_BASE_ADDR + 0x14)
+#define CKGA_PLL0_CLK2          (CKGA_BASE_ADDR + 0x18)
+#define CKGA_PLL0_CLK3          (CKGA_BASE_ADDR + 0x1c)
+#define CKGA_PLL0_CLK4          (CKGA_BASE_ADDR + 0x20)
+#define CKGA_PLL1_LCK_STA       (CKGA_BASE_ADDR + 0x2c) 
+#define CKGA_CLK_DIV            (CKGA_BASE_ADDR + 0x30) 
+#define CKGA_CLK_EN             (CKGA_BASE_ADDR + 0x34) 
+#define CKGA_CLKOUT_SEL         (CKGA_BASE_ADDR + 0x38) 
+#define CKGA_PLL1_BYPASS        (CKGA_BASE_ADDR + 0x3c) 
+*/
+
+#define CKGA_PLL0_CFG           (CKGA_BASE_ADDR + 0x00) 
+#define CKGA_PLL1_CFG           (CKGA_BASE_ADDR + 0x04) 
+
+#define TMU_TSTR_INIT           0x7   /* enable TMU0/1/2 */
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  void set_actual_latch(unsigned long val_actual_latch);
+#else
+  #define TMU_TSTR TMU_012_TSTR
+  #define CONFIG_SH_EXTERNAL_CLOCK 27000000
+#endif
+
+int modul_hz = HZ;
+static struct proc_dir_entry 
+*cpu_dir, 
+*pll0_ndiv_mdiv, 
+*pll1_ndiv_mdiv, 
+#ifdef STB7100
+*pll1_clk_div, 
+*pll1_fdma_bypass, 
+*sh4_ratio, 
+*sh4_ic_ratio, 
+*module_ratio, 
+*slim_ratio, 
+*sysaclkout, 
+#endif
+*m_hz; 
+
+void update_bogomips(unsigned long sh4_hz)
+{
+  unsigned long bogomips;
+
+  bogomips=(sh4_hz / 1000000) - 3;
+  bogomips=bogomips * (500000/modul_hz);
+  boot_cpu_data.loops_per_jiffy = bogomips;
+  current_cpu_data.loops_per_jiffy = bogomips;
+  loops_per_jiffy = bogomips;
+}
+
+int update_tmu(unsigned long module_rate)
+{
+  struct clk *clk;
+  unsigned long actual_latch = LATCH;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("tmu0_clk");
+#else
+  clk=clk_get(NULL, "tmu0_clk");
+#endif
+  if(clk)
+  {
+    clk->parent->rate = module_rate;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+    // set tmu0 to actual frequ
+    actual_latch = (clk_get_rate(clk) + modul_hz / 2) / modul_hz;
+    while(ctrl_inl(TMU0_TCNT) != 0x0);  // wait for tmu0 interrupt
+    ctrl_outb(ctrl_inb(TMU_TSTR) & ~(TMU_TSTR_INIT), TMU_TSTR); // stop all tmu
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    set_actual_latch(actual_latch);  // set actual latch in kernel
+#endif
+    ctrl_outl(actual_latch, TMU0_TCOR);
+    ctrl_outl(actual_latch, TMU0_TCNT);
+  }
+  else
+    printk("[CPU_FREQU] tmu0_clk not found\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("tmu1_clk");
+#else
+  clk=clk_get(NULL, "tmu1_clk");
+#endif
+  if(clk)
+  {
+    clk->parent->rate = module_rate;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+    ctrl_outl(~0, TMU1_TCOR);
+    ctrl_outl(~0, TMU1_TCNT);
+    ctrl_outb(ctrl_inb(TMU_TSTR) | TMU_TSTR_INIT, TMU_TSTR); // start all tmu
+  }
+  else
+    printk("[CPU_FREQU] tmu1_clk not found\n");
+
+  return 0;
+}
+
+void __delay(unsigned long loops)
+{
+  __asm__ __volatile__(
+    "tst    %0, %0\n\t"
+    "1:\t"
+    "bf/s   1b\n\t"
+    " dt    %0"
+    : "=r" (loops)
+    : "0" (loops)
+    : "t");
+}
+
+unsigned long calc_bogomips(void)
+{
+  unsigned long ticks, loopbit;
+  int lps_precision = 8;
+
+  loops_per_jiffy = (1<<12);
+
+  while ((loops_per_jiffy <<= 1) != 0) {
+    /* wait for "start of" clock tick */
+    ticks = jiffies;
+    while (ticks == jiffies)
+      /* nothing */;
+    /* Go .. */
+    ticks = jiffies;
+    __delay(loops_per_jiffy);
+    ticks = jiffies - ticks;
+    if (ticks)
+      break;
+  }
+  /*
+  * Do a binary approximation to get loops_per_jiffy set to
+  * equal one clock (up to lps_precision bits)
+  */
+  loops_per_jiffy >>= 1;
+  loopbit = loops_per_jiffy;
+  while (lps_precision-- && (loopbit >>= 1)) {
+    loops_per_jiffy |= loopbit;
+    ticks = jiffies;
+    while (ticks == jiffies)
+      /* nothing */;
+    ticks = jiffies;
+    __delay(loops_per_jiffy);
+    if (jiffies != ticks)   /* longer than 1 tick */
+      loops_per_jiffy &= ~loopbit;
+  }	
+
+  return (loops_per_jiffy);
+}
+
+static int read_ratio(char *page, char **start,
+                        off_t off, int count,
+                        int *eof, void *data)
+{
+  int len=0;
+  unsigned long value, bogomips;
+#ifdef STB7100
+  int sh4_div=2, sh4_ic_div=2, module_div=2, slim_div=2, slim_bypass=0;
+  unsigned long freq_pll0, freq_pll1, ndiv, pdiv, mdiv, val_sysaclkout=0;
+#endif
+
+  len+=sprintf(page+len, "Modul HZ = %d\n", modul_hz);
+
+#ifdef STB7100
+  value = ctrl_inl(CKGA_LCK);
+  len+=sprintf(page+len, "CKGA_LCK = %lx\n", value);
+
+  value = ctrl_inl(CKGA_MD_STA);
+  len+=sprintf(page+len, "CKGA_MD_STA = %lx\n", value);
+#endif
+
+  value = ctrl_inl(CKGA_PLL0_CFG);
+  len+=sprintf(page+len, "CKGA_PLL0_CFG = %lx\n", value);
+
+#ifdef STB7100
+  mdiv = (value >>  0) & 0xff;
+  ndiv = (value >>  8) & 0xff;
+  pdiv = (value >> 16) & 0x7;
+  freq_pll0 = (((2 * (CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv) / (1 << pdiv)) * 1000;
+  freq_pll0=freq_pll0 / 1000000;
+
+  value = ctrl_inl(CKGA_PLL0_LCK_STA);
+  len+=sprintf(page+len, "CKGA_PLL0_LCK_STA = %lx\n", value);
+
+  value = ctrl_inl(CKGA_PLL0_CLK1);
+  len+=sprintf(page+len, "CKGA_PLL0_CLK1 = %lx\n", value);
+
+  switch(value) {
+    case 0: sh4_div=2;break;
+    case 1: sh4_div=4;break;
+    case 2: sh4_div=6;break;
+    case 3: sh4_div=8;break;
+    case 4: sh4_div=12;break;
+    case 5: sh4_div=16;break;
+    case 6: sh4_div=2;break;
+    case 7: sh4_div=2;break;
+  }
+
+  value = ctrl_inl(CKGA_PLL0_CLK2);
+  len+=sprintf(page+len, "CKGA_PLL0_CLK2 = %lx\n", value);
+
+  switch(value) {
+    case 0: sh4_ic_div=2;break;
+    case 1: sh4_ic_div=4;break;
+    case 2: sh4_ic_div=6;break;
+    case 3: sh4_ic_div=8;break;
+    case 4: sh4_ic_div=12;break;
+    case 5: sh4_ic_div=16;break;
+    case 6: sh4_ic_div=4;break;
+    case 7: sh4_ic_div=4;break;
+  }
+
+  value = ctrl_inl(CKGA_PLL0_CLK3);
+  len+=sprintf(page+len, "CKGA_PLL0_CLK3 = %lx\n", value);
+
+  switch(value) {
+    case 0: module_div=8;break;
+    case 1: module_div=4;break;
+    case 2: module_div=8;break;
+    case 3: module_div=8;break;
+    case 4: module_div=12;break;
+    case 5: module_div=16;break;
+    case 6: module_div=8;break;
+    case 7: module_div=8;break;
+  }
+
+  value = ctrl_inl(CKGA_PLL0_CLK4);
+  len+=sprintf(page+len, "CKGA_PLL0_CLK4 = %lx\n", value);
+
+  switch(value) {
+    case 0: slim_div=2;break;
+    case 1: slim_div=4;break;
+    case 2: slim_div=6;break;
+    case 3: slim_div=8;break;
+    case 4: slim_div=12;break;
+    case 5: slim_div=16;break;
+    case 6: slim_div=6;break;
+    case 7: slim_div=6;break;
+  }
+#endif
+
+  value = ctrl_inl(CKGA_PLL1_CFG);
+  len+=sprintf(page+len, "CKGA_PLL1_CFG = %lx\n", value);
+
+#ifdef STB7100
+  mdiv = (value >>  0) & 0xff;
+  ndiv = (value >>  8) & 0xff;
+  pdiv = (value >> 16) & 0x7;
+  freq_pll1 = (((2 * (CONFIG_SH_EXTERNAL_CLOCK / 1000) * ndiv) / mdiv) / (1 << pdiv)) * 1000;
+  freq_pll1=freq_pll1 / 1000000;
+
+  value = ctrl_inl(CKGA_PLL1_LCK_STA);
+  len+=sprintf(page+len, "CKGA_PLL1_LCK_STA = %lx\n", value);
+
+  value = ctrl_inl(CKGA_CLK_DIV);
+  len+=sprintf(page+len, "CKGA_CLK_DIV = %lx\n", value);
+
+  value = ctrl_inl(CKGA_CLK_EN);
+  len+=sprintf(page+len, "CKGA_CLK_EN = %lx\n", value);
+	
+  value = ctrl_inl(CKGA_PLL1_BYPASS);
+  len+=sprintf(page+len, "CKGA_PLL1_BYPASS = %lx\n", value);
+  slim_bypass=value & 0x01;
+
+  value = ctrl_inl(CKGA_CLKOUT_SEL);
+  len+=sprintf(page+len, "CKGA_CLKOUT_SEL = %lx\n", value);
+	
+  switch(value) {
+    case 0: val_sysaclkout=freq_pll0/sh4_div;break;
+    case 1: val_sysaclkout=freq_pll0/sh4_ic_div;break;
+    case 2: val_sysaclkout=freq_pll0/module_div;break;
+    case 3: if(slim_bypass == 0) 
+              val_sysaclkout=freq_pll0/slim_div;
+            else
+              val_sysaclkout=freq_pll1;
+            break;
+    case 4: val_sysaclkout=freq_pll0/slim_div;break;
+    case 5: val_sysaclkout=freq_pll1;break;
+    case 6: val_sysaclkout=freq_pll1;break;
+    case 7: val_sysaclkout=freq_pll1;break;
+    case 8: val_sysaclkout=freq_pll1;break;
+    case 9: val_sysaclkout=freq_pll1/2;break;
+    case 10: val_sysaclkout=freq_pll1/4;break;
+    case 11: val_sysaclkout=freq_pll1/4;break;
+  }
+  len+=sprintf(page+len, "SYSACLKOUT (standard 266MHZ) = %ldMHZ\n", val_sysaclkout);
+#endif
+
+  value = ctrl_inl(TMU0_TCOR);
+  len+=sprintf(page+len, "TMU0_TCOR = %lx\n", value);
+
+  value = ctrl_inl(TMU0_TCNT);
+  len+=sprintf(page+len, "TMU0_TCNT = %lx\n", value);
+
+  value = ctrl_inl(TMU1_TCOR);
+  len+=sprintf(page+len, "TMU1_TCOR = %lx\n", value);
+
+  value = ctrl_inl(TMU1_TCNT);
+  len+=sprintf(page+len, "TMU1_TCNT = %lx\n", value);
+
+#ifdef STX7105
+  value = ctrl_inl(TMU1_TCOR);
+  len+=sprintf(page+len, "TMU2_TCOR = %lx\n", value);
+
+  value = ctrl_inl(TMU1_TCNT);
+  len+=sprintf(page+len, "TMU2_TCNT = %lx\n", value);
+#endif
+
+#ifdef STB7100
+  len+=sprintf(page+len, "\n");
+  len+=sprintf(page+len, "BOGOMIPS (static)= %ld\n", (freq_pll0 / sh4_div) - 3);
+#endif
+
+  bogomips = calc_bogomips();
+  bogomips = bogomips/(500000/modul_hz);
+  len+=sprintf(page+len, "BOGOMIPS (measured)= %ld\n", bogomips);
+
+#ifdef STB7100
+  len+=sprintf(page+len, "\n");
+  len+=sprintf(page+len, "PLL0     = %ld MHZ\n", freq_pll0);
+  len+=sprintf(page+len, "SH4      = %ld MHZ\n", freq_pll0 / sh4_div);
+  len+=sprintf(page+len, "SH4_IC   = %ld MHZ\n", freq_pll0 / sh4_ic_div);
+  len+=sprintf(page+len, "MODULE   = %ld MHZ\n", freq_pll0 / module_div);
+
+  if(slim_bypass == 0)
+    len+=sprintf(page+len, "SLIM     = %ld MHZ\n", freq_pll0 / slim_div);
+  else
+    len+=sprintf(page+len, "SLIM     = %ld MHZ\n", freq_pll1);
+
+  len+=sprintf(page+len, "PLL1     = %ld MHZ\n", freq_pll1);
+  len+=sprintf(page+len, "COMMS    = %ld MHZ\n", freq_pll1 / 4);
+  len+=sprintf(page+len, "TMU0     = %ld MHZ\n", (freq_pll0 / module_div) / 4);
+  len+=sprintf(page+len, "TMU1     = %ld MHZ\n", (freq_pll0 / module_div) / 4);
+
+  len+=sprintf(page+len, "\n");
+  len+=sprintf(page+len, "sh4 ratio (2,4,6,8,12,16)\n");
+  len+=sprintf(page+len, "sh4_ic ratio (2,4,6,8,12,16)\n");
+  len+=sprintf(page+len, "module ratio (4,8,12,16)\n");
+  len+=sprintf(page+len, "slim ratio (2,4,6,8,12,16)\n");
+#endif
+
+  return len;
+}
+
+static int write_pll1_ndiv_mdiv(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  struct clk *clk;
+  unsigned long regdata;
+  int ndiv=0, mdiv=0;
+  int ndiv_mdiv=simple_strtoul(buffer, NULL, 10);
+
+#ifdef STB7100
+  mdiv = (ndiv_mdiv >> 0) & 0xff;
+  ndiv = (ndiv_mdiv >> 8) & 0xff;
+#endif
+#ifdef STX7105
+  mdiv = (ndiv_mdiv >> 0) & 0x07;
+  ndiv = (ndiv_mdiv >> 8) & 0xff;
+#endif
+
+  if(mdiv<0 || mdiv>255)
+  {
+    dprintk("[CPU_FREQU] mdiv not correct, use another PLL1 Frequenze (%d)\n", mdiv);
+    return count;
+  }
+  if(ndiv<3 || ndiv>255)
+  {
+    dprintk("[CPU_FREQU] ndiv not correct, use another PLL1 Frequenze (%d)\n", ndiv);
+    return count;
+  }
+
+  regdata = ctrl_inl(CKGA_PLL1_CFG);  // get data from register
+#ifdef STB7100
+  regdata = regdata & 0xfff80000;  // clear mdiv, ndiv and pdiv
+  regdata = regdata | mdiv | (ndiv << 8) | (0x01 << 16);  // set mdiv, ndiv and pdiv
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+#endif
+#ifdef STX7105
+  regdata = regdata & 0xfffff800;  // clear mdiv, ndiv
+  regdata = regdata | mdiv | (ndiv << 8);  // set mdiv, ndiv
+#endif
+
+  //ctrl_outl(0x00000002, CKGA_PLL1_BYPASS);  // set to SYSACLKIN
+
+/*
+  regdata = ctrl_inl(CKGA_PLL1_CFG);  // get data from register
+  regdata = regdata & ~(1 << 19);  // disable PLL1
+  ctrl_outl(regdata1, CKGA_PLL1_CFG);
+
+  regdata = regdata & ~(0xff);  // clear MDIV
+  regdata = regdata & ~(0xff) << 8;   // clear NDIV
+  regdata = regdata & ~(0x07) << 16;  // clear PDIV
+
+  regdata = regdata | mdiv;  // set MDIV
+  regdata = regdata | ndiv << 8;  // set NDIV
+  regdata = regdata | (0x1 & 0x7)  << 16;  // set PDIV
+
+  regdata = regdata | 1 << 19;  // aktivate PLL1
+*/
+  ctrl_outl(regdata, CKGA_PLL1_CFG);  // write register
+
+  // wait for lock
+  //while((ctrl_inl(CKGA_PLL1_LCK_STA) & 0x01) == 0x00);
+
+  //ctrl_outl(0x00000000, CKGA_PLL1_BYPASS);  // set to PLL1_CLK
+
+#ifdef STB7100
+  ctrl_outl(0x0, CKGA_LCK);
+#endif
+
+  // set /proc/cpuinfo
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("pll1_clk");
+#else
+  clk=clk_get(NULL, "pll1_clk");
+#endif
+  if(clk)
+  {
+    clk_disable(clk);
+    clk_enable(clk);
+  }
+  else
+    printk("[CPU_FREQU] pll1_clk not found\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("comms_clk");
+#else
+  clk=clk_get(NULL, "comms_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+  }
+  else
+    printk("[CPU_FREQU] comms_clk not found\n");
+
+  return count;
+}
+
+static int write_pll0_ndiv_mdiv(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  struct clk *clk;
+  unsigned long regdata, module_rate=0, sh4_hz;
+  int ndiv=0, mdiv=0;
+  int ndiv_mdiv=simple_strtoul(buffer, NULL, 10);
+#ifdef STB7100
+  unsigned long sta;
+
+  mdiv = (ndiv_mdiv >> 0) & 0xff;
+  ndiv = (ndiv_mdiv >> 8) & 0xff;
+#endif
+#ifdef STX7105
+  mdiv = (ndiv_mdiv >> 0) & 0x07;
+  ndiv = (ndiv_mdiv >> 8) & 0xff;
+#endif
+
+  if(mdiv<0 || mdiv>255)
+  {
+    dprintk("[CPU_FREQU] mdiv not correct, use another PLL0 Frequenze (%d)\n", mdiv);
+    return count;
+  }
+  if(ndiv<3 || ndiv>255)
+  {
+    dprintk("[CPU_FREQU] ndiv not correct, use another PLL0 Frequenze (%d)\n", ndiv);
+    return count;
+  }
+
+#ifdef STB7100
+  ctrl_outl(0xC0DE, CKGA_LCK);
+#endif
+
+  regdata = ctrl_inl(CKGA_PLL0_CFG);  // get data from register
+
+  regdata = regdata | 1 << 20;  // set to SYSACLKIN
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+
+  regdata = regdata & ~(1 << 19);  // disable PLL0
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+
+#ifdef STB7100
+  regdata = regdata & ~(0xff);  // clear MDIV
+  regdata = regdata & ~(0xff) << 8;   // clear NDIV
+  regdata = regdata & ~(0x07) << 16;  // clear PDIV
+
+  regdata = regdata | mdiv;  // set MDIV
+  regdata = regdata | ndiv << 8;  // set NDIV
+  regdata = regdata | (0x0 & 0x7)  << 16;  // set PDIV
+#endif
+#ifdef STX7105
+  regdata = regdata & ~(0x07);  // clear MDIV
+  regdata = regdata & ~(0xff) << 8;   // clear NDIV
+
+  regdata = regdata | mdiv;  // set MDIV
+  regdata = regdata | ndiv << 8;  // set NDIV
+#endif
+
+  regdata = regdata | 1 << 19;  // aktivate PLL0
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+
+#ifdef STB7100
+  // wait for lock
+  sta = ctrl_inl(CKGA_PLL0_LCK_STA);
+  while((sta & 0x01) == 0x00)
+  {
+    sta = ctrl_inl(CKGA_PLL0_LCK_STA);
+  }
+#endif
+
+  regdata = regdata & ~(1 << 20);  // set to PLL0 CLK
+  ctrl_outl(regdata, CKGA_PLL0_CFG);
+
+#ifdef STB7100
+  ctrl_outl(0x0, CKGA_LCK);
+#endif
+
+  // set /proc/cpuinfo
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("pll0_clk");
+#else
+  clk=clk_get(NULL, "pll0_clk");
+#endif
+  if(clk)
+  {
+    clk_disable(clk);
+    clk_enable(clk);
+  }
+  else
+    printk("[CPU_FREQU] pll0_clk not found\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("sh4_clk");
+#else
+  clk=clk_get(NULL, "sh4_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+    // set bogomips in /proc/cpuinfo (use sh4 clock - 3)
+    // measured bogomit not always correct in running system
+    sh4_hz=clk_get_rate(clk);
+    update_bogomips(sh4_hz);
+  }
+  else
+    printk("[CPU_FREQU] sh4_clk not found\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("sh4_ic_clk");
+#else
+  clk=clk_get(NULL, "sh4_ic_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+  }
+  else
+    printk("[CPU_FREQU] sh4_ic_clk not found\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("module_clk");
+#else
+  clk=clk_get(NULL, "module_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+    module_rate=clk_get_rate(clk);
+  }
+  else
+    printk("[CPU_FREQU] module_clk not found\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("slim_clk");
+#else
+  clk=clk_get(NULL, "slim_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+  }
+  else
+    printk("[CPU_FREQU] slim_clk not found\n");
+
+  if(module_rate)
+    update_tmu(module_rate);
+
+  return count;
+}
+
+#ifdef STB7100
+static int write_sh4_ratio(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value, sh4_hz;
+  int sh4_ratio=simple_strtoul(buffer, NULL, 10);
+  struct clk *clk;
+
+  switch(sh4_ratio) {
+    case 2:value=0x0;break;
+    case 4:value=0x1;break;
+    case 6:value=0x2;break;
+    case 8:value=0x3;break;
+    case 12:value=0x4;break;
+    case 16:value=0x5;break;
+    default:
+      dprintk("[CPU_FREQU] sh4 ratio (%d) not correct, use 2,4,8,12 or 16\n", sh4_ratio);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  //0x0=1, 0x1=2, 0x2=3, 0x3=4, 0x4=6, 0x5=8
+  ctrl_outl(value, CKGA_PLL0_CLK1);  // set sh4 ratio
+  ctrl_outl(0x0, CKGA_LCK);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("sh4_clk");
+#else
+  clk=clk_get(NULL, "sh4_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+    // set bogomips in /proc/cpuinfo (use sh4 clock - 3)
+    // measured bogomit not always correct in running system
+    sh4_hz=clk_get_rate(clk);
+    update_bogomips(sh4_hz);
+  }
+  else
+    printk("[CPU_FREQU] sh4_clk not found\n"); 
+
+  return count;
+}
+
+static int write_sh4_ic_ratio(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value;
+  int sh4_ic_ratio=simple_strtoul(buffer, NULL, 10);
+  struct clk *clk;
+
+  switch(sh4_ic_ratio) {
+    case 2:value=0x0;break;
+    case 4:value=0x1;break;
+    case 6:value=0x2;break;
+    case 8:value=0x3;break;
+    case 12:value=0x4;break;
+    case 16:value=0x5;break;
+    default:
+      dprintk("[CPU_FREQU] sh4_ic ratio (%d) not correct, use 2,4,6,8,12 or 16\n", sh4_ic_ratio);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  //0x0=1, 0x1=2, 0x2=3, 0x3=4, 0x4=6, 0x5=8
+  ctrl_outl(value, CKGA_PLL0_CLK2);  // set sh4_ic ratio
+  ctrl_outl(0x0, CKGA_LCK);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("sh4_ic_clk");
+#else
+  clk=clk_get(NULL, "sh4_ic_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+  }
+  else
+    printk("[CPU_FREQU] sh4_ic_clk not found\n");
+
+  return count;
+}
+
+static int write_module_ratio(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value, module_rate;
+  int module_ratio=simple_strtoul(buffer, NULL, 10);
+  struct clk *clk;
+
+  switch(module_ratio) {
+    case 8:value=0x0;break;
+    case 4:value=0x1;break;
+    case 12:value=0x4;break;
+    case 16:value=0x5;break;
+    default:
+      dprintk("[CPU_FREQU] module ratio (%d) not correct, use 4,8,12 or 16\n", module_ratio);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  //0x0=4, 0x1=2, 0x2=4, 0x3=4, 0x4=6, 0x5=8
+  ctrl_outl(value, CKGA_PLL0_CLK3);  // set module ratio
+  ctrl_outl(0x0, CKGA_LCK);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("module_clk");
+#else
+  clk=clk_get(NULL, "module_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+    module_rate=clk_get_rate(clk);
+    update_tmu(module_rate);
+  }
+  else
+    printk("[CPU_FREQU] module_clk not found\n");
+
+  return count;
+}
+
+static int write_slim_ratio(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value;
+  int slim_ratio=simple_strtoul(buffer, NULL, 10);
+  struct clk *clk;
+
+  switch(slim_ratio) {
+    case 2:value=0x0;break;
+    case 4:value=0x1;break;
+    case 6:value=0x2;break;
+    case 8:value=0x3;break;
+    case 12:value=0x4;break;
+    case 16:value=0x5;break;
+    default:
+      dprintk("[CPU_FREQU] slim ratio (%d) not correct, use 2,4,6,8,12 or 16\n", slim_ratio);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  //0x0=1, 0x1=2, 0x2=3, 0x3=4, 0x4=6, 0x5=8
+  ctrl_outl(value, CKGA_PLL0_CLK4);  // set slim ratio
+  ctrl_outl(0x0, CKGA_LCK);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("slim_clk");
+#else
+  clk=clk_get(NULL, "slim_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+  }
+  else
+    printk("[CPU_FREQU] slim_clk not found\n");
+
+  return count;
+}
+
+static int write_pll1_fdma_bypass(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  unsigned long value;
+  int pll1_bypass=simple_strtoul(buffer, NULL, 10);
+  struct clk *clk;
+
+  switch(pll1_bypass) {
+    case 0:value=0x0;break;
+    case 1:value=0x1;break;
+    default:
+      dprintk("[CPU_FREQU] pll1_fdma_bypass (%d) not correct, use 0 or 1\n", pll1_bypass);
+      return count;break;
+  }
+
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  ctrl_outl(value, CKGA_PLL1_BYPASS);  // set FDMA to PPL1 HZ
+  ctrl_outl(0x0, CKGA_LCK);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+  clk=clk_get("slim_clk");
+#else
+  clk=clk_get(NULL, "slim_clk");
+#endif
+  if(clk)
+  {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+    clk_recalc_rate(clk);
+#else
+    clk->ops->recalc(clk);
+#endif
+  }
+  else
+    printk("[CPU_FREQU] slim_clk not found\n");
+
+  return count;
+}
+
+static int write_sysaclkout(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  int val_sysaclkout=simple_strtoul(buffer, NULL, 10);
+
+  if(val_sysaclkout<0 || val_sysaclkout>11)
+  {
+    dprintk("[CPU_FREQU] sysaclkout (%d) not correct, use 0 to 11\n", val_sysaclkout);
+    return count;
+  }
+        
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  ctrl_outl(val_sysaclkout, CKGA_CLKOUT_SEL);  // set CKGA_CLKOUT_SEL
+  ctrl_outl(0x0, CKGA_LCK);
+
+  return count;
+}
+
+static int write_pll1_clk_div(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  int clk_div=simple_strtoul(buffer, NULL, 10);
+        
+  if(clk_div<0 || clk_div>15)
+  {
+    dprintk("[CPU_FREQU] pll1_clk_div (%d) not correct, use 0 to 15\n", clk_div);
+    return count;
+  }
+        
+  ctrl_outl(0xC0DE, CKGA_LCK);
+  ctrl_outl(clk_div, CKGA_CLK_DIV);  // set CKGA_CLK_DIV
+  ctrl_outl(0x0, CKGA_LCK);
+
+  return count;
+}
+#endif
+
+static int write_m_hz(struct file *file, const char *buffer,
+                        unsigned long count, void *data)
+{
+  modul_hz=simple_strtoul(buffer, NULL, 10);
+
+  return count;
+}
+
+int __init cpu_frequ_init(void)
+{
+  dprintk("[CPU_FREQU] initializing ...\n");
+
+  cpu_dir=proc_mkdir("cpu_frequ",NULL);
+  if(cpu_dir==NULL)
+    return -ENOMEM;
+
+  pll0_ndiv_mdiv=create_proc_entry("pll0_ndiv_mdiv",0644,cpu_dir);
+  pll0_ndiv_mdiv->read_proc=read_ratio;
+  pll0_ndiv_mdiv->write_proc=write_pll0_ndiv_mdiv;
+
+  pll1_ndiv_mdiv=create_proc_entry("pll1_ndiv_mdiv",0644,cpu_dir);
+  pll1_ndiv_mdiv->read_proc=read_ratio;
+  pll1_ndiv_mdiv->write_proc=write_pll1_ndiv_mdiv;
+
+#ifdef STB7100
+  sh4_ratio=create_proc_entry("sh4_ratio",0644,cpu_dir);
+  sh4_ratio->read_proc=read_ratio;
+  sh4_ratio->write_proc=write_sh4_ratio;
+
+  sh4_ic_ratio=create_proc_entry("sh4_ic_ratio",0644,cpu_dir);
+  sh4_ic_ratio->read_proc=read_ratio;
+  sh4_ic_ratio->write_proc=write_sh4_ic_ratio;
+
+  module_ratio=create_proc_entry("module_ratio",0644,cpu_dir);
+  module_ratio->read_proc=read_ratio;
+  module_ratio->write_proc=write_module_ratio;
+
+  slim_ratio=create_proc_entry("slim_ratio",0644,cpu_dir);
+  slim_ratio->read_proc=read_ratio;
+  slim_ratio->write_proc=write_slim_ratio;
+
+  pll1_fdma_bypass=create_proc_entry("pll1_fdma_bypass",0644,cpu_dir);
+  pll1_fdma_bypass->read_proc=read_ratio;
+  pll1_fdma_bypass->write_proc=write_pll1_fdma_bypass;
+ 	
+  pll1_clk_div=create_proc_entry("pll1_clk_div",0644,cpu_dir);
+  pll1_clk_div->read_proc=read_ratio;
+  pll1_clk_div->write_proc=write_pll1_clk_div;
+ 	
+  sysaclkout=create_proc_entry("sysaclkout",0644,cpu_dir);
+  sysaclkout->read_proc=read_ratio;
+  sysaclkout->write_proc=write_sysaclkout;
+#endif
+ 	
+  m_hz=create_proc_entry("modul_hz",0644,cpu_dir);
+  m_hz->read_proc=read_ratio;
+  m_hz->write_proc=write_m_hz;
+
+ return 0;
+}
+
+void __exit cpu_frequ_exit(void)
+{
+  dprintk("[CPU_FREQU] unloading ...\n");
+  remove_proc_entry("pll0_ndiv_mdiv", cpu_dir);
+  remove_proc_entry("pll1_ndiv_mdiv", cpu_dir);
+#ifdef STB7100
+  remove_proc_entry("sh4_ratio", cpu_dir);
+  remove_proc_entry("sh4_ic_ratio", cpu_dir);
+  remove_proc_entry("module_ratio", cpu_dir);
+  remove_proc_entry("slim_ratio", cpu_dir);
+  remove_proc_entry("pll1_fdma_bypass", cpu_dir);
+  remove_proc_entry("pll1_clk_div", cpu_dir);
+  remove_proc_entry("sysaclkout", cpu_dir);
+#endif
+  remove_proc_entry("modul_hz", cpu_dir);
+  remove_proc_entry("cpu_dir", &proc_root);
+}
+
+module_init(cpu_frequ_init);
+module_exit(cpu_frequ_exit);
+
+MODULE_DESCRIPTION("Set CPU Frequenze on STb710x");
+MODULE_AUTHOR("nit");
+MODULE_LICENSE("GPL");
diff --git a/tdt/cvs/driver/cpu_frequ/pll0_check_stb7100.c b/tdt/cvs/driver/cpu_frequ/pll0_check_stb7100.c
new file mode 100644
index 0000000..9643a41
--- /dev/null
+++ b/tdt/cvs/driver/cpu_frequ/pll0_check_stb7100.c
@@ -0,0 +1,65 @@
+/*
+ * pll0_check_stb7100.c
+ * 
+ * nit 08.11.2010
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+ 
+main(int argc, char * argv[])
+{
+ int ndiv=0, mdiv=0;
+ float frequ = 0, frequ_check=1;
+ unsigned long ndiv_mdiv=0;
+
+ if(argc != 2)
+ {
+	printf("usage: %s frequenz\n", argv[0]);
+	exit(1);
+ }
+
+ frequ=atoi(argv[1]);
+
+ frequ=frequ / 2 / 27;
+
+ while(frequ_check != ndiv && mdiv<=255 && ndiv<=255)
+ {
+  mdiv++;
+  frequ_check = frequ * mdiv;
+  ndiv = frequ_check;
+ }
+
+ if(mdiv<0 || mdiv>255)	
+ {
+	printf("mdiv not correct (%d)\n", mdiv);
+	printf("frequenz can't be used\n");
+	exit(1);
+ }
+ if(ndiv<3 || ndiv>255)	
+ {
+	printf("ndiv not correct (%d)\n", ndiv);
+	printf("frequenz can't be used\n");
+	exit(1);
+ }
+ 
+ printf("frequ=%s\n",argv[1]);
+ printf("ndiv=%d (%x)\n",ndiv, ndiv);
+ printf("mdiv=%d (%x)\n",mdiv, mdiv);
+ ndiv_mdiv = mdiv;
+ ndiv_mdiv += (ndiv << 8);
+ printf("pll0_ndiv_mdiv for module=%ld (%lx)\n",ndiv_mdiv, ndiv_mdiv);
+ printf("frequenz is ok\n");
+}
diff --git a/tdt/cvs/driver/cpu_frequ/pll1_check_stb7100.c b/tdt/cvs/driver/cpu_frequ/pll1_check_stb7100.c
new file mode 100644
index 0000000..c48d184
--- /dev/null
+++ b/tdt/cvs/driver/cpu_frequ/pll1_check_stb7100.c
@@ -0,0 +1,65 @@
+/*
+ * pll1_check_stb7100.c
+ * 
+ * nit 08.11.2010
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+ 
+main(int argc, char * argv[])
+{
+ int ndiv=0, mdiv=0;
+ float frequ = 0, frequ_check=1;
+ unsigned long ndiv_mdiv=0;
+
+ if(argc != 2)
+ {
+	printf("usage: %s frequenz\n", argv[0]);
+	exit(1);
+ }
+
+ frequ=atoi(argv[1]);
+
+ frequ=frequ / 2 / 27;
+
+ while(frequ_check != ndiv && mdiv<=255 && ndiv<=255)
+ {
+  mdiv++;
+  frequ_check = frequ * (mdiv *2);
+  ndiv = frequ_check;
+ }
+
+ if(mdiv<0 || mdiv>255)	
+ {
+	printf("mdiv not correct (%d)\n", mdiv);
+	printf("frequenz can't be used\n");
+	exit(1);
+ }
+ if(ndiv<3 || ndiv>255)	
+ {
+	printf("ndiv not correct (%d)\n", ndiv);
+	printf("frequenz can't be used\n");
+	exit(1);
+ }
+ 
+ printf("frequ=%s\n",argv[1]);
+ printf("ndiv=%d (%x)\n",ndiv, ndiv);
+ printf("mdiv=%d (%x)\n",mdiv, mdiv);
+ ndiv_mdiv = mdiv;
+ ndiv_mdiv += (ndiv << 8);
+ printf("pll1_ndiv_mdiv for module=%ld (%lx)\n",ndiv_mdiv, ndiv_mdiv);
+ printf("frequenz is ok\n");
+}
diff --git a/tdt/cvs/driver/cpu_frequ/pll_check_stx7105.c b/tdt/cvs/driver/cpu_frequ/pll_check_stx7105.c
new file mode 100644
index 0000000..caa9645
--- /dev/null
+++ b/tdt/cvs/driver/cpu_frequ/pll_check_stx7105.c
@@ -0,0 +1,65 @@
+/*
+ * pll_check_stx7105.c
+ * 
+ * nit 08.11.2010
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+main(int argc, char * argv[])
+{
+ int ndiv=0, mdiv=0;
+ float frequ = 0, frequ_check=1;
+ unsigned long ndiv_mdiv=0;
+
+ if(argc != 2)
+ {
+	printf("usage: %s frequenz\n", argv[0]);
+	exit(1);
+ }
+
+ frequ=atoi(argv[1]);
+
+ frequ=frequ / 2 / 30;
+
+ while(frequ_check != ndiv && mdiv<=7 && ndiv<=255)
+ {
+  mdiv++;
+  frequ_check = frequ * mdiv;
+  ndiv = frequ_check;
+ }
+
+ if(mdiv<0 || mdiv>7)	
+ {
+	printf("mdiv not correct (%d)\n", mdiv);
+	printf("frequenz can't be used\n");
+	exit(1);
+ }
+ if(ndiv<3 || ndiv>255)	
+ {
+	printf("ndiv not correct (%d)\n", ndiv);
+	printf("frequenz can't be used\n");
+	exit(1);
+ }
+ 
+ printf("frequ=%s\n",argv[1]);
+ printf("ndiv=%d (%x)\n",ndiv, ndiv);
+ printf("mdiv=%d (%x)\n",mdiv, mdiv);
+ ndiv_mdiv = mdiv;
+ ndiv_mdiv += (ndiv << 8);
+ printf("pll0_ndiv_mdiv for module=%ld (%lx)\n",ndiv_mdiv, ndiv_mdiv);
+ printf("frequenz is ok\n");
+}
diff --git a/tdt/cvs/driver/pti/Makefile b/tdt/cvs/driver/pti/Makefile
index e323c5a..a734ae3 100644
--- a/tdt/cvs/driver/pti/Makefile
+++ b/tdt/cvs/driver/pti/Makefile
@@ -1,18 +1,12 @@
-TREE_ROOT?=$(DRIVER_TOPDIR)/player2
+TREE_ROOT?=$(DRIVER_TOPDIR)/
 CONFIG_STGFB_PATH?=$(DRIVER_TOPDIR)/stgfb/stmfb
-CCFLAGSY += -I$(TREE_ROOT)/linux/include/linux/stm/ 
-CCFLAGSY += -I$(TREE_ROOT)/linux/drivers/media/video/stm/ 
 CCFLAGSY += -I$(KERNEL_LOCATION)/drivers/media/dvb/dvb-core 
 CCFLAGSY += -I$(CONFIG_STGFB_PATH)/include 
 CCFLAGSY += -DDEBUG_DVB
-
-ifeq ($(CONFIG_PLAYER_131),y)
-CCFLAGSY+= -DPLAYER_131
-else ifeq ($(CONFIG_PLAYER_179),y)
-CCFLAGSY+= -DPLAYER_179
-else ifeq ($(CONFIG_PLAYER_191),y)
-CCFLAGSY+= -DPLAYER_191
-endif
+CCFLAGSY += -I$(TREE_ROOT)/include 
+CCFLAGSY += -I$(TREE_ROOT)/player2/linux/include 
+CCFLAGSY += -I$(TREE_ROOT)/player2/player/standards
+CCFLAGSY += -O2
 
 ifneq (,$(findstring 2.6.3,$(KERNELVERSION)))
 ccflags-y += $(CCFLAGSY)
@@ -20,6 +14,13 @@ else
 CFLAGS += $(CCFLAGSY)
 endif
 
-pti-objs:= pti_main.o
+pti-objs:=	pti_main.o \
+		pti_session.o \
+		pti_slot.o \
+		pti_buffer.o \
+		pti_hal.o \
+		pti_descrambler.o \
+		pti_process.o \
+		pti_filter.o
 
 obj-m += pti.o
diff --git a/tdt/cvs/driver/pti/Makefile.public b/tdt/cvs/driver/pti/Makefile.public
new file mode 100644
index 0000000..6507664
--- /dev/null
+++ b/tdt/cvs/driver/pti/Makefile.public
@@ -0,0 +1,8 @@
+TREE_ROOT?=../
+CFLAGS += -I$(TREE_ROOT)/include 
+CFLAGS += -I$(TREE_ROOT)/player2/linux/include 
+CFLAGS += -I$(KERNEL_LOCATION)/include 
+
+pti-objs:= ptiall.o
+
+obj-m += pti.o
diff --git a/tdt/cvs/driver/pti/compile b/tdt/cvs/driver/pti/compile
new file mode 100755
index 0000000..18d7a1a
--- /dev/null
+++ b/tdt/cvs/driver/pti/compile
@@ -0,0 +1,8 @@
+#!/bin/sh 
+
+DIR=($PWD)
+#KERNELDIR=/path/to/your/kernel/
+KERNELDIR=../../cdk/linux/
+
+make -C $KERNELDIR ARCH=sh CROSS_COMPILE=sh4-linux- M=$DIR modules
+
diff --git a/tdt/cvs/driver/pti/pti.h b/tdt/cvs/driver/pti/pti.h
index fafbbdf..88a6a9e 100644
--- a/tdt/cvs/driver/pti/pti.h
+++ b/tdt/cvs/driver/pti/pti.h
@@ -1,99 +1,1016 @@
 #ifndef _PTI_H_
 #define _PTI_H_
 
-#ifdef CONFIG_CPU_SUBTYPE_STB5301
-#define PTI_BASE_ADDRESS 0x20E00000
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+#include <linux/delay.h>
+#include <linux/time.h>
+#include <linux/errno.h>
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
 #endif
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
 
-#if defined(CONFIG_CPU_SUBTYPE_STB7100)  || defined (CONFIG_CPU_SUBTYPE_STX7100)
-#define PTI_BASE_ADDRESS 0x19230000
+#include <asm/io.h>
+
+#if defined (CONFIG_KERNELVERSION) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#include <linux/bpa2.h>
+#else
+#include <linux/bigphysarea.h>
 #endif
+/* doesn't run very stable on ufs910,
+ * all other should try this
+ */
+#undef use_irq
 
-#define PTI_BASE_SIZE    0x10000
+#define USE_ONE_DMA
+
+#define A18 /* stapi a18 */
 
-#define PTI_IRAM_BASE 0xC000
-#define PTI_IRAM_SIZE (0x10000 - 0xC000)
-#define PTI_DRAM_BASE 0x8000
-#define PTI_DRAM_SIZE (0xC000 - 0x8000)
+/* ufs912 
+ * ! all 7109er architectures should use secure lite 1 but
+ * this is not implemented currently.
+ */
+#if defined(UFS912) || defined(ATEVIO7500)
+#define SECURE_LITE2
+#endif
 
-/* Interrupt registers */
-#define PTI_STATUS(x)    (x * 0x4)
-#define PTI_ENABLE(x)    (((x * 0x4) + 0x10))
-#define PTI_ACK(x)       (((x * 0x4) + 0x20))
+/* external declaration */
+struct tBuffer;
 
-/* DMA Registers */
-#define PTI_DMAEMPTY_STAT       (0x0034)
+#define TC_DMA_THRESHOLD_LOW 1
+#define TC_DMA_THRESHOLD_HIGH 128
+
+#define PTI_BASE_ADDRESS 0x19230000
+#define PTI_BASE_SIZE    0x10000
 #define PTI_DMAEMPTY_EN         (0x0038)
-#define PTI_DMA_0_BASE          (0x1000)
-#define PTI_DMA_0_TOP           (0x1004)
-#define PTI_DMA_0_WRITE         (0x1008)
-#define PTI_DMA_0_READ          (0x100C)
-#define PTI_DMA_0_SETUP         (0x1010)
-#define PTI_DMA_0_HOLDOFF       (0x1014)
-#define PTI_DMA_0_STATUS        (0x1018)
-#define PTI_DMA_ENABLE          (0x101C)
-#define PTI_DMA_1_BASE          (0x1020)
-#define PTI_DMA_1_TOP           (0x1024)
-#define PTI_DMA_1_WRITE         (0x1028)
-#define PTI_DMA_1_READ          (0x102C)
-#define PTI_DMA_1_SETUP         (0x1030)
-#define PTI_DMA_1_HOLDOFF       (0x1034)
-#define PTI_DMA_1_CD_ADDR       (0x1038)
-#define PTI_DMA_SECT_START      (0x103C)
-#define PTI_DMA_2_BASE          (0x1040)
-#define PTI_DMA_2_TOP           (0x1044)
-#define PTI_DMA_2_WRITE         (0x1048)
-#define PTI_DMA_2_READ          (0x104C)
-#define PTI_DMA_2_SETUP         (0x1050)
-#define PTI_DMA_2_HOLDOFF       (0x1054)
-#define PTI_DMA_2_CD_ADDR       (0x1058)
-#define PTI_DMA_FLUSH           (0x105C)
-#define PTI_DMA_3_BASE          (0x1060)
-#define PTI_DMA_3_TOP           (0x1064)
-#define PTI_DMA_3_WRITE         (0x1068)
-#define PTI_DMA_3_READ          (0x106C)
-#define PTI_DMA_3_SETUP         (0x1070)
-#define PTI_DMA_3_HOLDOFF       (0x1074)
-#define PTI_DMA_3_CD_ADDR       (0x1078)
-
-#define PTI_DMA_PTI3_PROG       (0x107C)
-
-/* DMA Settings */
-#define PTI_DMA_DONE            (1<<0)
-
-
-/* Mode Register */
-#define PTI_MODE         (0x0030)
-
-#define PTI_MODE_ENABLE      (1 << 0)
-
-/* IIF Registers */
-#define PTI_IIF_FIFO_COUNT      (0x2000)
-#define PTI_IIF_FIFO_COUNT_BYTES(value) (value & 0x7f)
-#define PTI_IIF_FIFO_FULL       (1<<7)
-
-#define PTI_IIF_ALT_FIFO_COUNT  (0x2004)
-#define PTI_IIF_ALT_FIFO_COUNT_BYTES(value) (value & 0xff)
-
-#define PTI_IIF_FIFO_ENABLE     (0x2008)
-#define PTI_IIF_ALT_LATENCY     (0x2010)
-#define PTI_IIF_SYNC_LOCK       (0x2014)
-#define PTI_IIF_SYNC_DROP       (0x2018)
-#define PTI_IIF_SYNC_CONFIG     (0x201C)
-#define PTI_IIF_SYNC_PERIOD     (0x2020)
-#define PTI_IIF_HFIFO_COUNT     (0x2024)
-
-
-/* REGISTERS BELOW NOT TO BE ALLOWED INTO PUBLIC DOMAIN, DEBUG PURPOSE ONLY,
- * (c) STMicroelectronics 2005, not for redistribution
- */
+#define STPTI_MAXCHANNEL 32
+#define STPTI_MAXADAPTER 3
+
+
+#if !defined(SECURE_LITE2)
+#define TC_DATA_RAM_SIZE           6656         /* (6.5 * 1024) */
+#define TC_CODE_RAM_SIZE           7680         /* (7.5 * 1024) */
+#else
+#define TC_DATA_RAM_SIZE          13824         /* (13.5 * 1024) */
+#define TC_CODE_RAM_SIZE          16384         /* (16 * 1024)   */
+#endif
+
+#define TC_NUMBER_OF_HARDWARE_SECTION_FILTERS 32
+#define TC_NUMBER_OF_HARDWARE_NOT_FILTERS 32
+
+#define SF_BYTES_PER_CAM       768  /* Fixed value from hardware specs. */
+#define SF_FILTER_LENGTH         8  /* Minimum CAM filter length, must be multiple of 8 (8=short section filter mode) */
+#define SF_CAMLINE_WIDTH         4  /* Fixed value from hardware specs. */
+#define SF_BYTES_PER_MIN_ALLOC ( SF_CAMLINE_WIDTH * (SF_FILTER_LENGTH * 2)) /* N filters of M bytes & masks */
+
+#define SF_NUM_BLOCKS_PER_CAM  ( SF_BYTES_PER_CAM / SF_BYTES_PER_MIN_ALLOC )
+#define SF_NUM_FILTERS_PER_BLOCK ( SF_CAMLINE_WIDTH * 2 )       /* block spans the 2 CAMs each holding SF_CAMLINE_WIDTH filters */
+
+/* MAGIC numbers for the CAM_CFG register */
+#define CAM_CFG_8_FILTERS       0x0000  /* bits 5:3 (number of filters) */
+#define CAM_CFG_16_FILTERS      0x0008
+#define CAM_CFG_32_FILTERS      0x0010
+#define CAM_CFG_64_FILTERS      0x0018
+#define CAM_CFG_96_FILTERS      0x0020
+
+#define INVALID_FILTER_INDEX ((u32)0xffffffff)
+
+#define TC_INVALID_PID             ((unsigned int)0xe000)
+#define TC_INVALID_LINK            ((unsigned int)0xf000)
+#define SESSION_NOT_ALLOCATED 	   0xDEAD
+
+#define STATUS_FLAGS_TRANSPORT_ERROR              0x00000001
+#define STATUS_FLAGS_SECTION_CRC_ERROR            0x00000002
+#define STATUS_FLAGS_INVALID_DESCRAMBLE_KEY       0x00000004
+#define STATUS_FLAGS_INVALID_PARAMETER            0x00000008
+#define STATUS_FLAGS_INVALID_CC                   0x00000010
+#define STATUS_FLAGS_TC_CODE_FAULT                0x00000020
+#define STATUS_FLAGS_PACKET_SIGNAL                0x00000040
+#define STATUS_FLAGS_PES_ERROR                    0x00000080
+
+#define STATUS_FLAGS_DMA_COMPLETE                 0x00000100
+#define STATUS_FLAGS_SUBSTITUTE_COMPLETE          0x00000400
+#define STATUS_FLAGS_RECORD_BUFFER_OVERFLOW       0x00000800
+#define STATUS_FLAGS_CWP_FLAG                     0x00002000    /* (DSS only) */
+#define STATUS_FLAGS_INVALID_LINK                 0x00004000
+#define STATUS_FLAGS_BUFFER_OVERFLOW              0x00008000
+
+#define STATUS_FLAGS_ADAPTATION_EXTENSION_FLAG    0x00010000    /* (DVB only) */
+#define STATUS_FLAGS_PRIVATE_DATA_FLAG            0x00020000    /* (DVB only) */
+#define STATUS_FLAGS_SPLICING_POINT_FLAG          0x00040000    /* (DVB only) */
+#define STATUS_FLAGS_OPCR_FLAG                    0x00080000    /* (DVB only) */
+#define STATUS_FLAGS_PCR_FLAG                     0x00100000
+#define STATUS_FLAGS_PRIORITY_INDICATOR           0x00200000    /* (DVB only) */
+#define STATUS_FLAGS_RANDOM_ACCESS_INDICATOR      0x00400000    /* (DVB only) */
+#define STATUS_FLAGS_CURRENT_FIELD_FLAG           0x00400000    /* (DSS only) */
+#define STATUS_FLAGS_DISCONTINUITY_INDICATOR      0x00800000    /* (DVB only) */
+#define STATUS_FLAGS_MODIFIABLE_FLAG              0x00800000    /* (DSS only) */
+
+#define STATUS_FLAGS_START_CODE_FLAG              0x01000000    /* (DVB only) */
+#define STATUS_FLAGS_TIME_CODE                    0x01000000    /* (DSS only) */
+#define STATUS_FLAGS_PUSI_FLAG                    0x02000000    /* (DVB only) */
+#define STATUS_FLAGS_SCRAMBLE_CHANGE              0x04000000
+#define STATUS_FLAGS_FIRST_RECORDED_PACKET        0x08000000
+#define STATUS_FLAGS_BUNDLE_BOUNDARY              0x10000000    /* (DSS only) */
+#define STATUS_FLAGS_AUXILIARY_PACKET             0x20000000    /* (DSS only) */
+#define STATUS_FLAGS_SESSION_NUMBER_MASK          0x30000000    /* (DVB only) */
+#define STATUS_FLAGS_PACKET_SIGNAL_RECORD_BUFFER  0x40000000
+#define STATUS_FLAGS_INDX_TIMEOUT_TICK            0x80000000    /* Only used for STPTI_TIMER_TICK feature */
+
+#define TC_GLOBAL_DATA_DISCARD_SYNC_BYTE_SET                   0x0001
+
+/* SessionSectionParams: */
+
+#define TC_SESSION_INFO_FILTER_TYPE_FIELD       0xF000
+
+#define TC_SESSION_INFO_FILTER_TYPE_IREDETO_ECM 0x2000
+#define TC_SESSION_INFO_FILTER_TYPE_IREDETO_EMM 0x3000
+#define TC_SESSION_INFO_FILTER_TYPE_SHORT       0x4000
+#define TC_SESSION_INFO_FILTER_TYPE_LONG        0x5000
+#define TC_SESSION_INFO_FILTER_TYPE_MAC         0x6000
+#define TC_SESSION_INFO_FILTER_TYPE_NEG_MATCH   0x7000
+
+
+#define TC_SESSION_INFO_FORCECRCSTATE           0x0001
+#define TC_SESSION_INFO_DISCARDONCRCERROR       0x0002
+
+#define TC_SESSION_DVB_PACKET_FORMAT            0x0010
+
+#define TC_DMA_CONFIG_SIGNAL_MODE_FLAGS_SIGNAL_DISABLE    0x1
+#define TC_DMA_CONFIG_SIGNAL_MODE_TYPE_MASK               0xe
+#define TC_DMA_CONFIG_SIGNAL_MODE_TYPE_NO_SIGNAL          0x0
+#define TC_DMA_CONFIG_SIGNAL_MODE_TYPE_QUANTISATION       0x2
+#define TC_DMA_CONFIG_SIGNAL_MODE_TYPE_EVERY_TS           0x4
+#define TC_DMA_CONFIG_SIGNAL_MODE_SWCDFIFO                0x8
+#define TC_DMA_CONFIG_OUTPUT_WITHOUT_META_DATA            0x10
+#define TC_DMA_CONFIG_WINDBACK_ON_ERROR                   0x20
+
+#define SESSION_USE_MERGER_FOR_STC              0x8000
+#define SESSION_MASK_STC_SOURCE                 0x7FFF
+
+#define SLOT_STATE_INITIAL_SCRAMBLE_STATE      0x4000
+
+#define STPTI_BUFFER_ALIGN_MULTIPLE 0x20
+#define STPTI_BUFFER_SIZE_MULTIPLE 0x20
+
+#define DMAScratchAreaSize       (STPTI_BUFFER_SIZE_MULTIPLE+STPTI_BUFFER_ALIGN_MULTIPLE)
+#define NO_OF_DVB_STATUS_BLOCKS  2048
+
+#define NO_OF_STATUS_BLOCKS NO_OF_DVB_STATUS_BLOCKS
+
+#define TC_DSRAM_BASE 0x8000
+
+#define TC_SLOT_TYPE_NULL                       0x0000
+#define TC_SLOT_TYPE_SECTION                    0x0001
+#define TC_SLOT_TYPE_PES                        0x0002
+#define TC_SLOT_TYPE_RAW                        0x0003
+#define TC_SLOT_TYPE_EMM                        0x0005
+#define TC_SLOT_TYPE_ECM                        0x0006
+
+#define TC_MAIN_INFO_PES_STREAM_ID_FILTER_ENABLED            0x0100
+
+#define TC_MAIN_INFO_SLOT_STATE_ODD_SCRAMBLED                 0x0001
+#define TC_MAIN_INFO_SLOT_STATE_TRANSPORT_SCRAMBLED           0x0002
+#define TC_MAIN_INFO_SLOT_STATE_SCRAMBLED                     0x0004
+#define TC_MAIN_INFO_SLOT_STATE_SCRAMBLE_STATE_FIELD          (TC_MAIN_INFO_SLOT_STATE_SCRAMBLED | \
+                                                                TC_MAIN_INFO_SLOT_STATE_TRANSPORT_SCRAMBLED| \
+                                                                TC_MAIN_INFO_SLOT_STATE_ODD_SCRAMBLED) 
+
+#define TC_MAIN_INFO_SLOT_STATE_DMA_IN_PROGRESS               0x1000
+#define TC_MAIN_INFO_SLOT_STATE_SEEN_PACKET                   0x2000
+#define TC_MAIN_INFO_SLOT_STATE_SEEN_TS_SCRAMBLED             0x4000
+#define TC_MAIN_INFO_SLOT_STATE_SEEN_PES_SCRAMBLED            0x8000
+#define TC_MAIN_INFO_SLOT_STATE_SEEN_FIELD                    (TC_MAIN_INFO_SLOT_STATE_SEEN_PACKET | \
+                                                                TC_MAIN_INFO_SLOT_STATE_SEEN_TS_SCRAMBLED | \
+                                                                TC_MAIN_INFO_SLOT_STATE_SEEN_PES_SCRAMBLED)
+                                                             
+#define TC_MAIN_INFO_SLOT_MODE_ALTERNATE_OUTPUT_CLEAR          0x0010
+#define TC_MAIN_INFO_SLOT_MODE_ALTERNATE_OUTPUT_DESCRAMBLED    0x0020
+#define TC_MAIN_INFO_SLOT_MODE_ALTERNATE_OUTPUT_FIELD          (TC_MAIN_INFO_SLOT_MODE_ALTERNATE_OUTPUT_CLEAR | \
+                                                                 TC_MAIN_INFO_SLOT_MODE_ALTERNATE_OUTPUT_DESCRAMBLED)
+                                                                 
+#define TC_MAIN_INFO_SLOT_MODE_IGNORE_SCRAMBLING               0x0040
+#define TC_MAIN_INFO_SLOT_MODE_INJECT_SEQ_ERROR_MODE           0x0080
+#define TC_MAIN_INFO_SLOT_MODE_SUBSTITUTE_STREAM               0x0100
+
+#define TC_MAIN_INFO_SLOT_MODE_DMA_1                           0x0200
+#define TC_MAIN_INFO_SLOT_MODE_DMA_2                           0x0400
+#define TC_MAIN_INFO_SLOT_MODE_DMA_3                           0x0600
+#define TC_MAIN_INFO_SLOT_MODE_DMA_FIELD                       0x0600
+
+#define TC_MAIN_INFO_SLOT_MODE_DISABLE_CC_CHECK                0x0800
+
+/* For Watch & record reuses Startcode detection word*/
+#define TC_MAIN_INFO_REC_BUFFER_MODE_ENABLE                    0x0100
+#define TC_MAIN_INFO_REC_BUFFER_MODE_DESCRAMBLE                0x0200
+
+#define TC_MAIN_INFO_STARTCODE_DETECTION_OFFSET_MASK           0x00FF
+
+#define IIF_SYNC_CONFIG_USE_SOP             0x01
+
+typedef enum STPTI_StreamID_s
+{
+    STPTI_STREAM_ID_TSIN0 = 0x20,
+    STPTI_STREAM_ID_TSIN1,
+    STPTI_STREAM_ID_TSIN2,
+#if defined(UFS912) || defined(ATEVIO7500) /* 7111/7105 arch */
+    STPTI_STREAM_ID_TSIN3,
+#endif
+    STPTI_STREAM_ID_SWTS0,
+#ifdef UFS922 /* 7109 arch */
+    STPTI_STREAM_ID_SWTS1,
+    STPTI_STREAM_ID_SWTS2,
+#endif
+    STPTI_STREAM_ID_ALTOUT,
+    STPTI_STREAM_ID_NOTAGS = 0x80,  /* if tsmerger not configured to emit tag bytes */
+    STPTI_STREAM_ID_NONE  /*Use to deactivate a virtual PTI*/
+
+} STPTI_StreamID_t ;
+
+
+/* BOOL type constant values */
+#ifndef TRUE
+    #define TRUE (1 == 1)
+#endif
+#ifndef FALSE
+    #define FALSE (!TRUE)
+#endif
+
+typedef volatile u32 *STPTI_DevicePtr_t;
+
+#ifdef A18
+
+typedef volatile struct TCSessionInfo_s
+{
+    u16 SessionInputPacketCount;
+    u16 SessionInputErrorCount;
+    
+    u16 SessionCAMFilterStartAddr;   /* PTI4L (ram cam) only */
+    u16 SessionCAMConfig;            /* PTI4L (ram cam) only */
+
+    u16 SessionPIDFilterStartAddr;
+    u16 SessionPIDFilterLength;
+
+    u16 SessionSectionParams;        /* SF_Config (crc & filter type etc.) */
+    u16 SessionTSmergerTag;
+
+    u16 SessionProcessState;
+    u16 SessionModeFlags;
+
+    u16 SessionNegativePidSlotIdent;
+    u16 SessionNegativePidMatchingEnable;
+
+    u16 SessionUnmatchedSlotMode;
+    u16 SessionUnmatchedDMACntrl_p;    
+
+    u16 SessionInterruptMask0;
+    u16 SessionInterruptMask1;
+
+    u16 SessionSTCWord0;
+    u16 SessionSTCWord1;
+
+    u16 SessionSTCWord2;
+    u16 SessionDiscardParams;
+
+    u32 SessionPIPFilterBytes;
+    u32 SessionPIPFilterMask;
+
+    u32 SessionCAPFilterBytes;
+    u32 SessionCAPFilterMask;
+
+    u16 SessionEMMFilterOffset;
+    u16 SessionSpare;
+
+    u32 SectionEnables_0_31;
+    
+    u32 SectionEnables_32_63;
+    
+#if defined(SECURE_LITE2)
+    u32 SectionEnables_64_95;
+    
+    u32 SectionEnables_96_127;
+
+    u16 SessionLastEvtTick_0;
+    u16 SessionLastEvtTick_1;
+
+    u16 SessionTickDMA_p;
+    u16 SessionTickDMA_Slot;
+
+    u16 SessionSBoxInfo;
+    u16 SessionSpareRegister;  
+#endif
+
+} TCSessionInfo_t;
+
+#else
+
+typedef volatile struct TCSessionInfo_s
+{
+    u16 SessionInputPacketCount;
+    u16 SessionInputErrorCount;
+    
+    u16 SessionCAMFilterStartAddr;   /* PTI4L (ram cam) only */
+    u16 SessionCAMConfig;            /* PTI4L (ram cam) only */
+
+    u16 SessionPIDFilterStartAddr;
+    u16 SessionPIDFilterLength;
+
+    u16 SessionSectionParams;        /* SF_Config (crc & filter type etc.) */
+    u16 SessionTSmergerTag;
+
+    u16 SessionProcessState;
+    u16 SessionModeFlags;
+
+    u16 SessionNegativePidSlotIdent;
+    u16 SessionNegativePidMatchingEnable;
+
+    u16 SessionUnmatchedSlotMode;
+    u16 SessionUnmatchedDMACntrl_p;    
+
+    u16 SessionInterruptMask0;
+    u16 SessionInterruptMask1;
+
+    u32 SectionEnables_0_31;
+    u32 SectionEnables_32_63;
+
+    u16 SessionSTCWord0;
+    u16 SessionSTCWord1;
+
+    u16 SessionSTCWord2;
+    u16 SessionDiscardParams;
+
+    u32 SessionPIPFilterBytes;
+    u32 SessionPIPFilterMask;
+
+    u32 SessionCAPFilterBytes;
+    u32 SessionCAPFilterMask;
+
+} TCSessionInfo_t;
+#endif
+
+#if defined(A18)
+typedef volatile struct TCGlobalInfo_s
+{
+    u16 GlobalPacketHeader;              /* (TC)   */
+    u16 GlobalHeaderDesignator;          /* (TC)   */
+
+    u32 GlobalLastQWrite;                /* (TC)   GlobalLastQWrite_0:16  GlobalLastQWrite_1:16 */
+
+    u16 GlobalQPointsInPacket;           /* (TC)   */
+    u16 GlobalProcessFlags;              /* (TC)   */
+
+    u16 GlobalSlotMode;                  /* (TC)   */
+    u16 GlobalDMACntrl_p;                /* (TC)   */
+
+    u32 GlobalPktCount;                  /* (TC)   Global Input Packet Count */
+
+    u16 GlobalSignalModeFlags;           /* (TC)   */
+    u16 GlobalCAMArbiterIdle;            /* (TC)   For GNBvd18811 */
+    
+    u16 GlobalSFTimeouts;                /* (TC)   */
+    u16 GlobalDTVPktBufferPayload_p;     /* (TC)   */
+    
+    u16 GlobalResidue;                   /* (TC)   */
+    u16 GlobalPid;                       /* (TC)   */
+
+    u16 GlobalIIFCtrl;                   /* (TC)   */
+    u16 GlobalProfilerCount;             /* (TC)   */
+
+    u16 GlobalRecordDMACntrl_p;          /* (TC)   Holds the address of the DMA structure for the Record Buffer */
+    u16 GlobalDescramblingAllowed;       /* (TC)  */
+
+    u16 GlobalCAMArbiterInhibit;         /* (Host) For GNBvd18811 */
+    u16 GlobalModeFlags;                 /* (Host) */
+    
+    u32 GlobalScratch;                   /* (Host) GlobalScratch_0 GlobalScratch_1 */
+
+    u16 GlobalNegativePidSlotIdent;      /* (Host) */
+    u16 GlobalNegativePidMatchingEnable; /* (Host) */
+
+    u16 GlobalSwts_Params;               /* (Host) */
+    u16 GlobalSFTimeout;                 /* (Host) */
+
+    u16 GlobalTSDumpDMA_p;               /* (Host) */
+    u16 GlobalTSDumpCount;               /* (Host) */
+
+    u16 GlobalICAMVersion;               /* (Host)  Host sets this word to tell TC what is the ICAM version used on this silicon */
+    u16 GlobalCAAllowEcmEmm;             /* (TC) */
+
+    u16 GlobalCurrentSessionNo;          /* (TC)   Holds the current packet's session number, currently uses 8bits, when reused add mask to all the users appropriately */
+    u16 GlobalSpare1;                    /* FREE VARIABLE, USED FOR ALIGNMENT NOW */
+
+    /* Required for passage/overlay support */
+    u16 GlobalShadowMainInfo;             /* (TC)  */
+    u16 GlobalLegacyMainInfo;             /* (TC)  */
+
+#if defined(SECURE_LITE2)
+    u16 GlobalLastTickSessionNumber;     /* (TC )  */
+    u16 GlobalTickEnable;                /* (Host) */
+
+    u16 GlobalTickTemp_0;                /* (TC)   */
+    u16 GlobalTickTemp_1;                /* (TC)   */
+
+    u16 GlobalLastTickSlotNumber;        /* (TC )  */
+    u16 GlobalSkipSetDiscard;            /* (TC )  */
+#endif
+
+} TCGlobalInfo_t;
+
+#else
+typedef volatile struct TCGlobalInfo_s
+{
+    u16 GlobalPacketHeader;              /* (TC)   */
+    u16 GlobalHeaderDesignator;          /* (TC)   */
+
+    u32 GlobalLastQWrite;                /* (TC)   GlobalLastQWrite_0:16  GlobalLastQWrite_1:16 */
+
+    u16 GlobalQPointsInPacket;           /* (TC)   */
+    u16 GlobalProcessFlags;              /* (TC)   */
+
+    u16 GlobalSlotMode;                  /* (TC)   */
+    u16 GlobalDMACntrl_p;                /* (TC)   */
+
+    u32 GlobalPktCount;                  /* (TC)   Global Input Packet Count */
+
+    u16 GlobalSignalModeFlags;           /* (TC)   */
+    u16 GlobalCAMArbiterIdle;            /* (TC)   For GNBvd18811 */
+    
+    u16 GlobalSFTimeouts;                /* (TC)   */
+    u16 GlobalDTVPktBufferPayload_p;     /* (TC)   */
+    
+    u16 GlobalResidue;                   /* (TC)   */
+    u16 GlobalPid;                       /* (TC)   */
+
+    u16 GlobalIIFCtrl;                   /* (TC)   */
+    u16 GlobalProfilerCount;             /* (TC)   */
+
+    u16 GlobalRecordDMACntrl_p;          /* (TC)   Holds the address of the DMA structure for the Record Buffer */
+    u16 GlobalSpare1;                    /* (TC)   Filter Address for the Start Code Detector */
+
+    u16 GlobalCAMArbiterInhibit;         /* (Host) For GNBvd18811 */
+    u16 GlobalModeFlags;                 /* (Host) */
+    
+    u32 GlobalScratch;                   /* (Host) GlobalScratch_0 GlobalScratch_1 */
+
+    u16 GlobalNegativePidSlotIdent;      /* (Host) */
+    u16 GlobalNegativePidMatchingEnable; /* (Host) */
+
+    u16 GlobalSwts_Params;               /* (Host) */
+    u16 GlobalSFTimeout;                 /* (Host) */
+
+/* Only used for STPTI_TIMER_TICK feature */
+    u16 GlobalTSDumpDMA_p;               /* (Host) */
+    u16 GlobalTSDumpCount;               /* (Host) */
+
+    u16 GlobalLastTickSessionNumber;     /* (TC )  */
+    u16 GlobalTickEnable;                /* (Host) */
+
+    u16 GlobalTickTemp_0;                /* (TC)   */
+    u16 GlobalTickTemp_1;                /* (TC)   */
+    
+    u16 GlobalLastTickSlotNumber;        /* (TC )  */
+    u16 GlobalSkipSetDiscard;            /* (TC )  */
+ /* End of STPTI_TIMER_TICK feature variables */
+
+} TCGlobalInfo_t;
+#endif
+
+typedef volatile struct
+{
+    u32 SFFilterDataLS;
+    u32 SFFilterMaskLS;
+    u32 SFFilterDataMS;
+    u32 SFFilterMaskMS;
+} TCSectionFilter_t;
+
+#ifdef FRAG_MICH_KEINER_WARUMS_DIE_STRUKTUR_ZWEIMAL_GIBT
+typedef volatile struct
+{
+    TCSectionFilter_t FilterA  [TC_NUMBER_OF_HARDWARE_SECTION_FILTERS];
+    TCSectionFilter_t FilterB  [TC_NUMBER_OF_HARDWARE_SECTION_FILTERS];
+    u32               NotFilter[TC_NUMBER_OF_HARDWARE_SECTION_FILTERS];
+} TCSectionFilterArrays_t;
+#endif
+
+typedef volatile union TCFilterLine_s 
+{
+    struct
+    {
+        u8 Filter[SF_CAMLINE_WIDTH];
+    } Element;
+
+    u32 Word;
+
+} TCFilterLine_t;
+
+typedef volatile struct TCCamEntry_s 
+{
+    TCFilterLine_t Data;
+    TCFilterLine_t Mask;
+} TCCamEntry_t;
+
+typedef volatile struct TCCamIndex_s 
+{
+    TCCamEntry_t Index[ SF_FILTER_LENGTH ];
+} TCCamIndex_t;
+
+typedef volatile struct TCSectionFilterArrays_s 
+{
+    TCCamIndex_t CamA_Block[ SF_NUM_BLOCKS_PER_CAM ];
+    u32          ReservedA[256/4];
+
+    TCCamIndex_t CamB_Block[ SF_NUM_BLOCKS_PER_CAM ];
+    u32          ReservedB[256/4];
+
+    u32          NotFilter[ TC_NUMBER_OF_HARDWARE_NOT_FILTERS ];
+} TCSectionFilterArrays_t;
+
+typedef volatile struct TCDevice_s 
+{
+    u32 PTIIntStatus0;
+    u32 PTIIntStatus1;
+    u32 PTIIntStatus2;
+    u32 PTIIntStatus3;
+
+    u32 PTIIntEnable0;
+    u32 PTIIntEnable1;
+    u32 PTIIntEnable2;
+    u32 PTIIntEnable3;
+
+    u32 PTIIntAck0;
+    u32 PTIIntAck1;
+    u32 PTIIntAck2;
+    u32 PTIIntAck3;
+
+    u32 TCMode;
+
+    u32 DMAempty_STAT;   /* 3 bits RO */
+    u32 DMAempty_EN;     /* 3 bits RW */
+
+    u32 TCPadding_0;
+
+    u32 PTIAudPTS_31_0;
+    u32 PTIAudPTS_32;
+
+    u32 PTIVidPTS_31_0;
+    u32 PTIVidPTS_32;
+
+    u32 STCTimer0;
+    u32 STCTimer1;
+
+    u32 TCPadding_1[(0x1000 - 22 * sizeof(u32)) / sizeof(u32)];
+
+    u32 DMA0Base;
+    u32 DMA0Top;
+    u32 DMA0Write;
+    u32 DMA0Read;
+    u32 DMA0Setup;
+    u32 DMA0Holdoff;
+    u32 DMA0Status;
+    u32 DMAEnable;
+    
+    u32 DMA1Base;
+    u32 DMA1Top;
+    u32 DMA1Write;
+    u32 DMA1Read;
+    u32 DMA1Setup;
+    u32 DMA1Holdoff;
+    u32 DMA1CDAddr;
+    u32 DMASecStart;
+
+    u32 DMA2Base;
+    u32 DMA2Top;
+    u32 DMA2Write;
+    u32 DMA2Read;
+    u32 DMA2Setup;
+    u32 DMA2Holdoff;
+    u32 DMA2CDAddr;
+    u32 DMAFlush;
+
+    u32 DMA3Base;
+    u32 DMA3Top;
+    u32 DMA3Write;
+    u32 DMA3Read;
+    u32 DMA3Setup;
+    u32 DMA3Holdoff;
+    u32 DMA3CDAddr;
+    u32 DMAPTI3Prog;
+
+    u32 TCPadding_2[(0x2000 - (0x1000 + 32 * sizeof(u32))) / sizeof(u32)];
+
+    u32 TCPadding_4[(0x20e0 - 0x2000) / sizeof(u32)];
+
+    u32 IIFCAMode;
+
+    u32 TCPadding_5[(0x4000 - (0x2000 + 57 * sizeof(u32))) / sizeof(u32)];
+
+    TCSectionFilterArrays_t TC_SectionFilterArrays; /* std or ram cam */
+
+    u32 TCPadding_6[(0x6000 - (0x4000 + sizeof(TCSectionFilterArrays_t))) / sizeof(u32)];
+
+    u32 IIFFIFOCount;
+    u32 IIFAltFIFOCount;
+    u32 IIFFIFOEnable;
+    u32 TCPadding_3[1];
+    u32 IIFAltLatency;
+    u32 IIFSyncLock;
+    u32 IIFSyncDrop;
+    u32 IIFSyncConfig;
+    u32 IIFSyncPeriod;
+
+    u32 TCPadding_7[(0x7000 - (0x6000 + 9 * sizeof(u32))) / sizeof(u32)];
+
+    u32 TCRegA;
+    u32 TCRegB;
+    u32 TCRegC;
+    u32 TCRegD;
+    u32 TCRegP;
+    u32 TCRegQ;
+    u32 TCRegI;
+    u32 TCRegO;
+    u32 TCIPtr;
+    u32 TCRegE0;
+    u32 TCRegE1;
+    u32 TCRegE2;
+    u32 TCRegE3;
+    u32 TCRegE4;
+    u32 TCRegE5;
+    u32 TCRegE6;
+    u32 TCRegE7;    
+                
+    u32 TCPadding_8[(0x8000 - (0x7000 + 17 * sizeof(u32))) / sizeof(u32)];                                
+
+    u32 TC_Data[TC_DATA_RAM_SIZE / sizeof(u32)];
+
+    u32 TCPadding_9[(0xC000 - (0x8000 + TC_DATA_RAM_SIZE)) / sizeof(u32)];
+
+    u32 TC_Code[TC_CODE_RAM_SIZE / sizeof(u32)];
+} TCDevice_t;
+
+typedef struct
+{
+    STPTI_DevicePtr_t TC_CodeStart;
+    size_t            TC_CodeSize;
+    STPTI_DevicePtr_t TC_DataStart;
+
+    STPTI_DevicePtr_t TC_LookupTableStart;
+    STPTI_DevicePtr_t TC_GlobalDataStart;
+    STPTI_DevicePtr_t TC_StatusBlockStart;
+    STPTI_DevicePtr_t TC_MainInfoStart;
+    STPTI_DevicePtr_t TC_DMAConfigStart;
+    STPTI_DevicePtr_t TC_DescramblerKeysStart;
+    STPTI_DevicePtr_t TC_TransportFilterStart;
+    STPTI_DevicePtr_t TC_SCDFilterTableStart;
+    STPTI_DevicePtr_t TC_PESFilterStart;
+    STPTI_DevicePtr_t TC_SubstituteDataStart;
+    STPTI_DevicePtr_t TC_SystemKeyStart;    /* Descambler support */
+    STPTI_DevicePtr_t TC_SFStatusStart;
+    STPTI_DevicePtr_t TC_InterruptDMAConfigStart;
+    STPTI_DevicePtr_t TC_EMMStart;
+    STPTI_DevicePtr_t TC_ECMStart;              /* Possibly redundant */
+    STPTI_DevicePtr_t TC_MatchActionTable;
+    STPTI_DevicePtr_t TC_SessionDataStart;
+    STPTI_DevicePtr_t TC_VersionID;
+
+    u16               TC_NumberCarousels;
+    u16               TC_NumberSystemKeys;    /* Descambler support */
+    u16               TC_NumberDMAs;
+    u16               TC_NumberDescramblerKeys;
+    u16               TC_SizeOfDescramblerKeys;
+    u16               TC_NumberIndexs;
+    u16               TC_NumberPesFilters;
+    u16               TC_NumberSectionFilters;
+    u16               TC_NumberSlots;
+    u16               TC_NumberTransportFilters;
+    u16               TC_NumberEMMFilters;
+    u16               TC_SizeOfEMMFilter;
+    u16               TC_NumberECMFilters;
+    u16               TC_NumberOfSessions;
+    u16               TC_NumberSCDFilters;
+
+    int              TC_AutomaticSectionFiltering;
+    int              TC_MatchActionSupport;
+    int              TC_SignalEveryTransportPacket;
+
+} STPTI_TCParameters_t;
+
+typedef volatile struct TCMainInfo_s
+{
+    u16 SlotState;
+    u16 PacketCount;
+
+    u16 SlotMode;
+    u16 DescramblerKeys_p;          /* a.k.a. CAPAccumulatedCount, CAPAccumulatedCount */
+
+    u16 DMACtrl_indices;
+    u16 IndexMask;
+
+    u16 SectionPesFilter_p; 
+    u16 RemainingPESLength;         /* a.k.a. ECMFilterMask */
+    
+    u16 PESStuff;                   /* a.k.a. CAPFilterResult, RawCorruptionParams, ECMFilterData */
+    u16 StartCodeIndexing_p;        /* a.k.a. RecordBufferMode */
+
+#if defined(SECURE_LITE2)
+    u16 Overlay_p;                  /* passage support only */
+    u16 MainInfoSpare;              /* SPARE REGISTER - ADDED FOR ALIGNMENT */
+#endif
+} TCMainInfo_t;
+
+typedef volatile struct TCInterruptDMAConfig_s 
+{
+    u32 DMABase_p;
+    u32 DMATop_p;
+    u32 DMAWrite_p;
+    u32 DMARead_p;
+} TCInterruptDMAConfig_t;
+
+#if defined(A18)
+
+#define STPTI_MAX_START_CODES_SUPPORTED 7
+
+typedef struct StartCode_s 
+{
+    u8 Offset;
+    u8 Code;
+} StartCode_t;
+
+typedef volatile struct TCStatus_s 
+{
+    u32 Flags;
+    
+    u32 SlotError:8;
+    u32 SlotNumber:8;
+    u32 Odd_Even:1;
+    u32 PESScrambled:1;
+    u32 Scrambled:1;
+    u32 Padding:13;
+    
+    u32 ArrivalTime0:16;
+    u32 ArrivalTime1:16;
+    
+    u32 ArrivalTime2:16;
+    u32 DMACtrl:16;
+    
+    u32 Pcr0:16;
+    u32 Pcr1:16;
+    
+    u32 Pcr2:16;
+    u32 NumberStartCodes:8;
+    u32 PayloadLength:8;
+    
+    u32 BufferPacketNumber;
+    u32 BufferPacketOffset;
+    u32 RecordBufferPacketNumber;
+
+    u32 CarouselInfo;
+
+#if defined(SECURE_LITE2)
+    u32 StartCodePreviousBPN:8;
+    u32 StartCodePreviousRecordBPN:8;
+    StartCode_t StartCodes[STPTI_MAX_START_CODES_SUPPORTED];
+#endif
+
+} TCStatus_t;
+#else
+typedef volatile struct TCStatus_s 
+{
+    u32 Flags;
+    
+    u32 SlotError:8;
+    u32 SlotNumber:8;
+    u32 Odd_Even:1;
+    u32 PESScrambled:1;
+    u32 Scrambled:1;
+    u32 Padding:13;
+    
+    u32 ArrivalTime0:16;
+    u32 ArrivalTime1:16;
+    
+    u32 ArrivalTime2:16;
+    u32 DMACtrl:16;
+    
+    u32 Pcr0:16;
+    u32 Pcr1:16;
+    
+    u32 Pcr2:16;
+    u32 NumberStartCodes:8;
+    u32 PayloadLength:8;
+    
+    u32 BufferPacketNumber;
+    u32 BufferPacketOffset;
+    u32 RecordBufferPacketNumber;
+
+} TCStatus_t;
+#endif
+
+typedef volatile struct TCDMAConfig_s
+{
+    u32 DMABase_p;
+    u32 DMATop_p;
+    u32 DMAWrite_p;
+    u32 DMARead_p;
+    u32 DMAQWrite_p;
+    u32 BufferPacketCount;
+
+    u16 SignalModeFlags;
+    u16 Threshold;
+#if defined(SECURE_LITE2)
+    u16 BufferLevelThreshold;
+    u16 DMAConfig_Spare;
+#endif
+} TCDMAConfig_t;
+
+struct TCDMAConfigExt_s
+{
+    u32 BasePtr_physical;
+    u32 TopPtr_physical;
+    u8 *pBuf;
+    u32 bufSize;
+    u32 bufSize_sub_188;
+    u32 bufSize_div_188;
+    u32 bufSize_div_188_div_2;
+};
+
+/* Note that when writing host to TC the key undergoes an endian swap,
+this is more complex for the extended AES keys as they are split in 2 sections.
+Thus even keys 3:0 are effectively keys 7:4 for AES 16 byte keys... etc
+This maintains compatibility with 8 byte keys, and gives the simplest (fastest)
+TC access to the extended AES keys */
+
+typedef volatile struct TCKey_s
+{
+    u16 KeyValidity;
+    u16 KeyMode;
+
+    u16 EvenKey3;
+    u16 EvenKey2;
+
+    u16 EvenKey1;
+    u16 EvenKey0;
+
+    u16 OddKey3;
+    u16 OddKey2;
+
+    u16 OddKey1;
+    u16 OddKey0;
+/* This is the end of the used portion for non-AES keys */
+
+    u16 EvenKey7;
+    u16 EvenKey6;
+    u16 EvenKey5;
+    u16 EvenKey4;
+
+    u16 EvenIV7;
+    u16 EvenIV6;
+    u16 EvenIV5;
+    u16 EvenIV4;
+    u16 EvenIV3;
+    u16 EvenIV2;
+    u16 EvenIV1;
+    u16 EvenIV0;
+
+    u16 OddKey7;
+    u16 OddKey6;
+    u16 OddKey5;
+    u16 OddKey4;
+
+    u16 OddIV7;
+    u16 OddIV6;
+    u16 OddIV5;
+    u16 OddIV4;
+    u16 OddIV3;
+    u16 OddIV2;
+    u16 OddIV1;
+    u16 OddIV0;
+    
+} TCKey_t;
+
+#define TCKEY_VALIDITY_TS_EVEN     0x0001
+#define TCKEY_VALIDITY_TS_ODD      0x0002
+#define TCKEY_VALIDITY_PES_EVEN    0x0100
+#define TCKEY_VALIDITY_PES_ODD     0x0200
+
+#define TCKEY_ALGORITHM_DVB        0x0000
+#define TCKEY_ALGORITHM_DSS        0x1000
+#define TCKEY_ALGORITHM_FAST_I     0x2000
+#define TCKEY_ALGORITHM_AES        0x3000
+#define TCKEY_ALGORITHM_MULTI2     0x4000
+#define TCKEY_ALGORITHM_MASK       0xF000
+
+#define TCKEY_CHAIN_ALG_ECB        0x0000
+#define TCKEY_CHAIN_ALG_CBC        0x0010
+#define TCKEY_CHAIN_ALG_ECB_IV     0x0020
+#define TCKEY_CHAIN_ALG_CBC_IV     0x0030
+#define TCKEY_CHAIN_ALG_OFB        0x0040
+#define TCKEY_CHAIN_ALG_CTS        0x0050
+#define TCKEY_CHAIN_ALG_MASK       0x00F0
+
+#define TCKEY_CHAIN_MODE_LR        0x0004
+
+
+/*
+  Use for   TCSectionFilterInfo_t
+            TCSessionInfo_t
+            TCMainInfo_t
+            TCGlobalInfo_t
+            TCKey_t
+            TCDMAConfig_t
+
+   The TC registers definded in pti4.h that are u32:16 bit fields
+   need be read modified and written back.
+
+   A single 16 bit write to ether the high or low part of a u32 is written
+   to both the low and high parts.
+
+   So the unchanged part needs to be read and ORed with the changed part and
+   written as a u32.
+
+   This function does just that.
+
+   It may not be the best way to do it but it works!!
+*/
+
+/* This macro determines whether the write is to the high or low word.
+   Reads in the complete 32 bit word writes in the high or low portion and
+   then writes the whole word back.
+   It get around the TC read modify write problem.
+   This macro is a more efficient vertion of the macro below and the function
+   below that.        */
+#define STSYS_WriteTCReg16LE( reg, u16value ) \
+{ \
+    u32 u32value = readl( (void*)((u32)(reg) & 0xfffffffC) );\
+    *(u16*)((u32)&u32value + ((u32)(reg) & 0x02)) = (u16value);\
+    writel(u32value, (void*)((u32)(reg) & 0xfffffffC) );\
+}
+
+/* Read the register and OR in the value and write it back. */
+#define STSYS_SetTCMask16LE( reg, u16value)\
+{\
+    STSYS_WriteTCReg16LE(reg, readw(reg) | u16value);\
+}
+
+/* Read the register and AND in the complement(~) of the value and write it back. */
+#define STSYS_ClearTCMask16LE( reg, u16value)\
+{\
+    STSYS_WriteTCReg16LE(reg, readw(reg) & ~u16value);\
+}
+
+#define GetTCData(ptr, x) {                                                 \
+                            u32 tmp;                                        \
+                            STPTI_DevicePtr_t p;                            \
+                            if(((u32)(ptr) % 4) == 0)                       \
+                            {                                               \
+                                p = (STPTI_DevicePtr_t)(ptr);               \
+                                tmp = readl( (void*)p );          \
+                            }                                               \
+                            else                                            \
+                            {                                               \
+                                p = (STPTI_DevicePtr_t)((u32)(ptr) & ~0x3); \
+                                tmp = readl( (void*)p );          \
+                                tmp >>= 16;                                 \
+                            }                                               \
+                            tmp &= 0xffff;                                  \
+                            (x) = tmp;                                      \
+                        }
+
+
+#define PutTCData(ptr, x) {                                                 \
+                            u32 tmp;                                        \
+                            STPTI_DevicePtr_t p;                            \
+                            if(((u32)(ptr) % 4) == 0)                       \
+                            {                                               \
+                                p = (STPTI_DevicePtr_t)(ptr);               \
+                                tmp = readl( (void*)p );          \
+                                tmp &= 0xffff0000;                          \
+                                tmp |= ((x)&0xffff);                        \
+                            }                                               \
+                            else                                            \
+                            {                                               \
+                                p = (STPTI_DevicePtr_t)((u32)(ptr) & ~0x3); \
+                                tmp = readl( (void*)p );          \
+                                tmp &= 0x0000ffff;                          \
+                                tmp |= ((x)<<16);                           \
+                            }                                               \
+                            writel( tmp, (void*)p );              \
+                         }
 
-#define PTI_MODE_RESET_IPTR  (1 << 1)
-#define PTI_MODE_SINGLE_STEP (1 << 2)
-#define PTI_MODE_SOFT_RESET  (1 << 3)
+extern irqreturn_t pti_interrupt_handler ( int irq, void *data,
+				    struct pt_regs *regs );
 
+extern int pti_task ( void *data );
 
-#define PTI_REGISTERS(x) ((((x & 0xf) < 8 ? x : x+1) * 0x4) + 0x7000)
-#define PTI_IPTR         (0x7020)
+extern int debug ;
+#define dprintk(x...) do { if (debug) printk(KERN_WARNING x); } while (0)
 
 #endif //_PTI_H_
diff --git a/tdt/cvs/driver/pti/pti_buffer.c b/tdt/cvs/driver/pti/pti_buffer.c
new file mode 100644
index 0000000..ddd43ec
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_buffer.c
@@ -0,0 +1,374 @@
+/*
+ * Authors: Dagobert, Phantomias
+ * Buffer Pool Handling for the pti. We allocate two pools of buffer.
+ * One pool is for BIG buffersizes and one for SMALL (the amount is configurable).
+ *
+ * The buffer pools are located in the lim_sys.
+ *
+ * The Addreesing will be done by the constants PTI_POOL_BIG, PTI_POOL_SMALL.
+ * The buffer allocation whill be done in ts packet size (188 Bytes) and is
+ * alligned to the STPTI_BUFFER_SIZE_MULTIPLE (0x20).
+ */
+
+#include <asm/io.h>
+
+#include <linux/version.h>
+
+#if defined (CONFIG_KERNELVERSION) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#include <linux/bpa2.h>
+#else
+#include <linux/bigphysarea.h>
+#include <linux/bpa2.h>
+#endif
+
+#include "pti.h"
+#include "pti_buffer.h"
+#include "pti_main.h"
+
+static struct semaphore sem;
+static struct tBuffer *bufferArray;
+static int poolNumber;
+
+struct TCDMAConfigExt_s *TCDMAConfigExt_t;
+
+typedef struct
+{
+  int bufSize;
+  int freeBuffers;
+  struct tBuffer *pList;
+} tPool;
+
+static tPool *poolArray;
+
+static size_t adjustSize( size_t size )
+{
+    return (( size + STPTI_BUFFER_SIZE_MULTIPLE - 1 ) &
+                                       ( ~( STPTI_BUFFER_SIZE_MULTIPLE - 1 )));
+}
+
+static void * alignAddress( void *pAddress )
+{
+  return ( void * ) ((( u32 ) pAddress + STPTI_BUFFER_ALIGN_MULTIPLE - 1 ) &
+				   ( ~( STPTI_BUFFER_ALIGN_MULTIPLE - 1 )));
+}
+
+// the function pushes the buffer on stack
+static void freeBuffer(tPool *pPool, struct tBuffer *pBuffer)
+{
+  if(pBuffer->inUse == 0)
+    printk("%s: FREEING UNUSED BUFFER\n", __func__);
+
+  if(down_interruptible (&sem))
+  {
+    printk("%s(): error taking semaphore\n", __func__);
+  }
+
+  pBuffer->inUse = 0;
+  pPool->freeBuffers++;
+
+  /* attach the buffer at the list head */
+  pBuffer->pNext = pPool->pList;
+  pPool->pList = pBuffer;
+
+  printk("%s(): free = %d\n", __func__, pPool->freeBuffers);
+
+  up(&sem);
+}
+
+// the function pops a buffer from stack
+static struct tBuffer * getBuffer(tPool *pPool)
+{
+  struct tBuffer *pBuffer;
+
+  if(down_interruptible (&sem))
+  {
+    printk("%s(): error taking semaphore\n", __func__);
+  }
+
+  printk("%s(): free = %d\n", __func__, pPool->freeBuffers);
+
+  /* get the pointer after locking the semaphore */
+  pBuffer = pPool->pList;
+
+  if(pPool->pList != NULL)
+  {
+    // update the buffer and the pool
+    if(pBuffer->inUse != 0)
+      printk("%s: ALLOCATING USED BUFFER\n", __func__);
+
+    pBuffer->inUse = 1;
+    pPool->freeBuffers--;
+
+    pPool->pList = pBuffer->pNext;
+
+    /* invalidate the chain */
+    pBuffer->pNext = NULL;
+  }
+
+  up(&sem);
+
+  return pBuffer;
+}
+
+static void pti_init_dma(int tc_dma_index, u32 BufferPhys_p, int ActualSize)
+{
+    TCDMAConfig_t * DMAConfig_p = &((TCDMAConfig_t *)tc_params.TC_DMAConfigStart)[tc_dma_index];
+
+    u32 base = (u32)(BufferPhys_p);
+    u32 top  = (u32) (base + ActualSize);
+
+    printk("DMA(%d) base = %x, top = %x, buffer = %x, size %d\n", tc_dma_index, base, top, BufferPhys_p, ActualSize);
+
+    TCDMAConfigExt_t[tc_dma_index].BasePtr_physical = base;
+    TCDMAConfigExt_t[tc_dma_index].TopPtr_physical = (top - 1) & ~0xf;
+    TCDMAConfigExt_t[tc_dma_index].pBuf = ( u8 * ) phys_to_virt ( TCDMAConfigExt_t[tc_dma_index].BasePtr_physical );
+    TCDMAConfigExt_t[tc_dma_index].bufSize = ( TCDMAConfigExt_t[tc_dma_index].TopPtr_physical - TCDMAConfigExt_t[tc_dma_index].BasePtr_physical ) + 0x10;
+    TCDMAConfigExt_t[tc_dma_index].bufSize_sub_188 = TCDMAConfigExt_t[tc_dma_index].bufSize - 188;
+    TCDMAConfigExt_t[tc_dma_index].bufSize_div_188 = TCDMAConfigExt_t[tc_dma_index].bufSize / 188;
+    TCDMAConfigExt_t[tc_dma_index].bufSize_div_188_div_2 = TCDMAConfigExt_t[tc_dma_index].bufSize / 188 / 2;
+
+    writel(base, (void*)&DMAConfig_p->DMABase_p );
+    writel((top - 1) & ~0xf , (void*)&DMAConfig_p->DMATop_p);
+    writel(base, (void*)&DMAConfig_p->DMARead_p );
+    writel(base, (void*)&DMAConfig_p->DMAWrite_p );
+    writel(base, (void*)&DMAConfig_p->DMAQWrite_p );
+    writel(0 , (void*)&DMAConfig_p->BufferPacketCount);
+
+    /* Reset SignalModeFlags as this could have been a previously used DMA and the flags may be in an
+     * un-defined state
+     */
+    STSYS_ClearTCMask16LE((void*)&DMAConfig_p->SignalModeFlags, TC_DMA_CONFIG_SIGNAL_MODE_TYPE_MASK );
+
+    //TC_DMA_CONFIG_SIGNAL_MODE_TYPE_EVERY_TS, TC_DMA_CONFIG_SIGNAL_MODE_SWCDFIFO TC_DMA_CONFIG_SIGNAL_MODE_TYPE_QUANTISATION...
+    STSYS_SetTCMask16LE((void*)&DMAConfig_p->SignalModeFlags,
+                        TC_DMA_CONFIG_SIGNAL_MODE_TYPE_EVERY_TS | 
+                        TC_DMA_CONFIG_OUTPUT_WITHOUT_META_DATA | 
+                        TC_DMA_CONFIG_WINDBACK_ON_ERROR);
+
+    STSYS_WriteTCReg16LE((void*)&DMAConfig_p->Threshold, TC_DMA_THRESHOLD_LOW);
+
+    // disable signalling
+    STSYS_SetTCMask16LE((void*)&DMAConfig_p->SignalModeFlags, TC_DMA_CONFIG_SIGNAL_MODE_FLAGS_SIGNAL_DISABLE );
+
+}
+
+int pti_buffer_pool_init(int poolNum, int *pSizes, int *pCount)
+{
+  int i;
+  int bufSize;
+  u8 *pBuffer;
+  int pages;
+  int poolInd;
+  int totalBuffers = 0;
+  int offset = 0;
+
+  /* init the access semaphore */
+  sema_init(&sem, 1);
+
+  poolNumber = poolNum;
+
+  for(poolInd = 0; poolInd < poolNum; poolInd++)
+    totalBuffers += pCount[poolInd];
+
+  // allocate memory for all buffer control structures
+  // (avoids memory fragmentation)
+  bufferArray = kmalloc(sizeof(struct tBuffer) * totalBuffers, GFP_KERNEL);
+  memset(bufferArray, 0, sizeof(struct tBuffer) * totalBuffers);
+
+  // allocate memory for all pool control structures
+  // (avoids memory fragmentation)
+  poolArray = kmalloc(sizeof(tPool) * poolNum, GFP_KERNEL);
+  memset(poolArray, 0, sizeof(tPool) * poolNum);
+
+  // allocate memory for all Dma extra Bytes for speed up pti_task
+  TCDMAConfigExt_t = kmalloc(sizeof(struct TCDMAConfigExt_s) * totalBuffers, GFP_KERNEL);
+  memset(TCDMAConfigExt_t, 0, sizeof(struct TCDMAConfigExt_s) * totalBuffers);
+
+  for(poolInd = 0; poolInd < poolNum; poolInd++)
+  {
+    // init pool data
+    poolArray[poolInd].freeBuffers = 0;
+    poolArray[poolInd].bufSize = pSizes[poolInd];
+    poolArray[poolInd].pList = NULL;
+
+    // compute the buffer size including overhead and the corresponding
+    // number of pages
+    bufSize = adjustSize(pSizes[poolInd]);
+    pages = bufSize / PAGE_SIZE;
+    if (bufSize % PAGE_SIZE)
+      pages++;
+
+    // initialize buffer control structures for this pool
+    for(i = 0; i < pCount[poolInd]; i++)
+    {
+      int j = i + offset;
+
+      // allocate big buffers at once
+      pBuffer = bigphysarea_alloc_pages(pages, 0, GFP_KERNEL | __GFP_DMA);
+
+      printk("pti: %s: allocate %d pages (%lu bytes)\n", __func__, pages, pages * PAGE_SIZE);
+
+      if(pBuffer == NULL)
+      {
+        printk("%s(): failed to allocate buffer (%d, %d)\n",
+                __func__, bufSize, pages);
+        break;
+      }
+
+      // store the requested buffer size
+      bufferArray[j].bufSize = pSizes[poolInd];
+
+      // partition the big buffer area
+      bufferArray[j].pBuffer = pBuffer;
+#if defined (CONFIG_KERNELVERSION) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+      bufferArray[j].pAlignedBuffer = alignAddress((void*)virt_to_phys(pBuffer));
+#else
+      bufferArray[j].pAlignedBuffer = alignAddress((void*)virt_to_bus(pBuffer));
+#endif
+      bufferArray[j].pMappedBuffer = ioremap_nocache((int)bufferArray[j].pAlignedBuffer, bufSize);
+      /* set the inUse flag before frreing the buffer */
+      bufferArray[j].inUse = 1;
+
+      // initialize DMA
+      bufferArray[j].dmaIndex = j;
+      bufferArray[j].threshold = TC_DMA_THRESHOLD_LOW;
+      pti_init_dma(j, (u32) bufferArray[j].pAlignedBuffer, bufSize);
+
+      // put into the pool
+      freeBuffer(&poolArray[poolInd], &bufferArray[j]);
+    }
+
+    // increment the offset within the buffer array
+    offset += i;
+  }
+
+  return 0;
+}
+
+struct tBuffer * pti_buffer_get(int size)
+{
+  int i;
+  struct tBuffer *pBuffer = NULL;
+
+  for(i = 0; i < poolNumber; i++)
+  {
+    if(poolArray != NULL)
+    {
+      // check the buffer size
+      if(poolArray[i].bufSize == size)
+      {
+        pBuffer = getBuffer(&poolArray[i]);
+        break;
+      }
+    }
+  }
+
+  printk("%s(%d) => %p\n", __func__, size, pBuffer);
+  if(pBuffer == NULL)
+  {
+    printk("%s(): NO FREE BUFFER (%d)\n", __func__, size);
+  }
+  else
+  {
+    TCDMAConfig_t * DMAConfig_p = &((TCDMAConfig_t *)tc_params.TC_DMAConfigStart)[pBuffer->dmaIndex];
+
+    u32 base = (u32)pBuffer->pAlignedBuffer;
+    u32 top  = (u32) (base + pBuffer->bufSize);
+
+    if((readl((void*)&DMAConfig_p->DMAWrite_p) != base) ||
+       (readl((void*)&DMAConfig_p->BufferPacketCount) != 0))
+    {
+      printk("\n%s(): inconsistent DMA settings %d\n\n", __func__, pBuffer->dmaIndex);
+    }
+
+    TCDMAConfigExt_t[pBuffer->dmaIndex].BasePtr_physical = base;
+    TCDMAConfigExt_t[pBuffer->dmaIndex].TopPtr_physical = (top - 1) & ~0xf;
+    TCDMAConfigExt_t[pBuffer->dmaIndex].pBuf = ( u8 * ) phys_to_virt ( TCDMAConfigExt_t[pBuffer->dmaIndex].BasePtr_physical );
+    TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize = ( TCDMAConfigExt_t[pBuffer->dmaIndex].TopPtr_physical - TCDMAConfigExt_t[pBuffer->dmaIndex].BasePtr_physical ) + 0x10;
+    TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize_sub_188 = TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize - 188;
+    TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize_div_188 = TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize / 188;
+    TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize_div_188_div_2 = TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize / 188 / 2;
+
+    writel(base, (void*)&DMAConfig_p->DMABase_p );
+    writel((top - 1) & ~0xf , (void*)&DMAConfig_p->DMATop_p);
+    writel(base, (void*)&DMAConfig_p->DMARead_p );
+    writel(base, (void*)&DMAConfig_p->DMAWrite_p );
+    writel(base, (void*)&DMAConfig_p->DMAQWrite_p );
+    writel(0 , (void*)&DMAConfig_p->BufferPacketCount);
+
+    /* Reset SignalModeFlags as this could have been a previously used DMA and the flags may be in an
+     * un-defined state
+     */
+    STSYS_ClearTCMask16LE((void*)&DMAConfig_p->SignalModeFlags, TC_DMA_CONFIG_SIGNAL_MODE_TYPE_MASK );
+
+    //TC_DMA_CONFIG_SIGNAL_MODE_TYPE_EVERY_TS, TC_DMA_CONFIG_SIGNAL_MODE_SWCDFIFO TC_DMA_CONFIG_SIGNAL_MODE_TYPE_QUANTISATION...
+    STSYS_SetTCMask16LE((void*)&DMAConfig_p->SignalModeFlags,
+                        TC_DMA_CONFIG_SIGNAL_MODE_TYPE_EVERY_TS |
+                        TC_DMA_CONFIG_OUTPUT_WITHOUT_META_DATA |
+                        TC_DMA_CONFIG_WINDBACK_ON_ERROR);
+
+    STSYS_WriteTCReg16LE((void*)&DMAConfig_p->Threshold, TC_DMA_THRESHOLD_LOW);
+
+    // disable signalling
+    STSYS_SetTCMask16LE((void*)&DMAConfig_p->SignalModeFlags, TC_DMA_CONFIG_SIGNAL_MODE_FLAGS_SIGNAL_DISABLE );
+  }
+
+  return pBuffer;
+}
+
+void pti_buffer_free(struct tBuffer *pBuffer)
+{
+  int i;
+  TCDMAConfig_t * DMAConfig_p = &((TCDMAConfig_t *)tc_params.TC_DMAConfigStart)[pBuffer->dmaIndex];
+
+#if defined (CONFIG_KERNELVERSION) /* ST Linux 2.3 */
+  printk("%s(%p, %d) - delta 0x%8x, thr 0x%x\n", __func__, pBuffer, pBuffer->bufSize,
+         readl((void*)&DMAConfig_p->DMAWrite_p ) - readl((void*)&DMAConfig_p->DMABase_p ), readw((void*)&DMAConfig_p->Threshold) );
+#else
+  printk("%s(%p, %d) - delta 0x%8lx, thr 0x%lx\n", __func__, pBuffer, pBuffer->bufSize,
+         readl((void*)&DMAConfig_p->DMAWrite_p ) - readl((void*)&DMAConfig_p->DMABase_p ), readw((void*)&DMAConfig_p->Threshold) );
+#endif
+
+  for(i = 0; i < poolNumber; i++)
+  {
+    if(poolArray[i].bufSize == pBuffer->bufSize)
+    {
+      TCDMAConfig_t * DMAConfig_p = &((TCDMAConfig_t *)tc_params.TC_DMAConfigStart)[pBuffer->dmaIndex];
+
+      u32 base = (u32)pBuffer->pAlignedBuffer;
+      u32 top  = (u32) (base + pBuffer->bufSize);
+
+      STSYS_WriteTCReg16LE((void*)&DMAConfig_p->SignalModeFlags, TC_DMA_CONFIG_SIGNAL_MODE_FLAGS_SIGNAL_DISABLE);
+
+      TCDMAConfigExt_t[pBuffer->dmaIndex].BasePtr_physical = base;
+      TCDMAConfigExt_t[pBuffer->dmaIndex].TopPtr_physical = (top - 1) & ~0xf;
+      TCDMAConfigExt_t[pBuffer->dmaIndex].pBuf = ( u8 * ) phys_to_virt ( TCDMAConfigExt_t[pBuffer->dmaIndex].BasePtr_physical );
+      TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize = ( TCDMAConfigExt_t[pBuffer->dmaIndex].TopPtr_physical - TCDMAConfigExt_t[pBuffer->dmaIndex].BasePtr_physical ) + 0x10;
+      TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize_sub_188 = TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize - 188;
+      TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize_div_188 = TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize / 188;
+      TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize_div_188_div_2 = TCDMAConfigExt_t[pBuffer->dmaIndex].bufSize / 188 / 2;
+
+      writel(base, (void*)&DMAConfig_p->DMABase_p );
+      writel((top - 1) & ~0xf , (void*)&DMAConfig_p->DMATop_p);
+      writel(base, (void*)&DMAConfig_p->DMARead_p );
+      writel(base, (void*)&DMAConfig_p->DMAWrite_p );
+      writel(base, (void*)&DMAConfig_p->DMAQWrite_p );
+      writel(0 , (void*)&DMAConfig_p->BufferPacketCount);
+
+      /* Reset SignalModeFlags as this could have been a previously used DMA and the flags may be in an
+       * un-defined state
+       */
+
+
+      STSYS_WriteTCReg16LE((void*)&DMAConfig_p->Threshold, TC_DMA_THRESHOLD_LOW);
+
+      freeBuffer(&poolArray[i], pBuffer);
+
+      break;
+    }
+  }
+
+  if(i == poolNumber)
+    printk("%s(): NO POOL FOUND (%p, %d)\n", __func__, pBuffer, pBuffer->bufSize);
+}
+
diff --git a/tdt/cvs/driver/pti/pti_buffer.h b/tdt/cvs/driver/pti/pti_buffer.h
new file mode 100644
index 0000000..0a2d9de
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_buffer.h
@@ -0,0 +1,25 @@
+#ifndef _PTI_BUFFER_H_
+#define _PTI_BUFFER_H_
+
+#include "pti_hal.h"
+
+struct tBuffer
+{
+  struct tBuffer *pNext;
+  int dmaIndex;
+  int sessionHandle;
+  int inUse;
+  int slotCount;
+  u8* pBuffer;
+  u8* pMappedBuffer;
+  u8* pAlignedBuffer;
+  int bufSize;
+  int threshold;
+};
+
+int pti_buffer_pool_init(int poolNum, int *pSizes, int *pCount);
+
+struct tBuffer * pti_buffer_get(int size);
+void pti_buffer_free(struct tBuffer *pBuffer);
+
+#endif
diff --git a/tdt/cvs/driver/pti/pti_descrambler.c b/tdt/cvs/driver/pti/pti_descrambler.c
new file mode 100644
index 0000000..c6714a6
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_descrambler.c
@@ -0,0 +1,225 @@
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+#include <linux/delay.h>
+#include <linux/time.h>
+#include <linux/errno.h>
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
+#endif
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+
+#include "pti.h"
+#include "pti_main.h"
+
+void pti_descrambler_allocate(u32 tc_descrambler_index)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    TCKey_t              *Key_p;
+
+    if (tc_descrambler_index < 0)
+    {
+    	printk("%s: Invalid descrambler index passed %d\n", __func__, tc_descrambler_index);
+	return;
+    }
+
+    Key_p         = 
+    (TCKey_t *)((u32)(&(TC_Params_p->TC_DescramblerKeysStart)[0])
+    		 + ((u16) tc_descrambler_index * TC_Params_p->TC_SizeOfDescramblerKeys));
+
+    /* mark as not valid */
+    STSYS_SetTCMask16LE((void*)&Key_p->KeyValidity, 0);
+
+}
+
+/* fixme: logisch gesehen auch eher link slot with descrambler ;) */
+void pti_descrambler_associate_with_slot(u32 tc_descrambler_index, u32 tc_slot_index)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    TCKey_t              *Key_p;
+    TCMainInfo_t *MainInfo_p;
+
+    if (tc_descrambler_index < 0)
+    {
+    	printk("%s: Invalid descrambler index passed %d\n", __func__, tc_descrambler_index);
+	return;
+    }
+
+    if (tc_slot_index < 0)
+    {
+    	printk("%s: Invalid slot index passed %d\n", __func__, tc_slot_index);
+	return;
+    }
+
+    Key_p         = 
+    (TCKey_t *)((u32)(&(TC_Params_p->TC_DescramblerKeysStart)[0])
+    		 + ((u16) tc_descrambler_index * TC_Params_p->TC_SizeOfDescramblerKeys));
+
+    printk("(da %d, %d)", tc_descrambler_index, tc_slot_index);
+
+    MainInfo_p = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+
+    /* convert ST20.40 address in TCKey_p to one that the TC understands */
+    STSYS_WriteTCReg16LE((void*)&MainInfo_p->DescramblerKeys_p,(u32) ( (u8 *)Key_p - (u8 *)TC_Params_p->TC_DataStart + (u8 *)TC_DSRAM_BASE ));
+
+    /* slot now does not ignore the descrambler */
+    STSYS_ClearTCMask16LE((void*)&MainInfo_p->SlotMode, (TC_MAIN_INFO_SLOT_MODE_IGNORE_SCRAMBLING) );
+}
+
+/* auch eher eine reine slot aktion */
+void pti_descrambler_disassociate_from_slot(u32 tc_descrambler_index, u32 tc_slot_index)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    TCMainInfo_t *MainInfo_p;
+
+    if (tc_slot_index < 0)
+    {
+    	printk("%s: Invalid slot index passed %d\n", __func__, tc_slot_index);
+	return;
+    }
+
+    MainInfo_p = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+
+    STSYS_WriteTCReg16LE((u32)&MainInfo_p->DescramblerKeys_p,TC_INVALID_LINK);
+}
+
+/* wenn werte richtig dann, assignment pid - slot in beiden versionen dumpen */
+void dumpDescrambler(TCKey_t* Key_p)
+{
+int vLoop = 1;
+	   dprintk("%d. Validity = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->KeyValidity));
+	   dprintk("%d. Mode     = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->KeyMode));
+	   dprintk("%d. Even0    = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->EvenKey0));
+	   dprintk("%d. Even1    = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->EvenKey1));
+	   dprintk("%d. Even2    = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->EvenKey2));
+	   dprintk("%d. Even3    = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->EvenKey3));
+	   dprintk("%d. Odd0     = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->OddKey0));
+	   dprintk("%d. Odd1     = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->OddKey1));
+	   dprintk("%d. Odd2     = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->OddKey2));
+	   dprintk("%d. Odd3     = 0x%.4x\n", vLoop, (unsigned int) readw(&Key_p ->OddKey3));
+}
+
+void pti_descrambler_set(u32 tc_descrambler_index, int Parity, u8 *Data)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+#ifdef xdebug
+    int vLoop;
+#endif
+    TCKey_t              *Key_p; 
+
+    u16 KeyCheck, KeyValidity = 0;
+
+    if (tc_descrambler_index < 0)
+    {
+    	printk("%s: Invalid descrambler index passed %d\n", __func__, tc_descrambler_index);
+	return;
+    }
+
+    Key_p         = 
+    (TCKey_t *)((u32)(&(TC_Params_p->TC_DescramblerKeysStart)[0])
+    		 + ((u16) tc_descrambler_index * TC_Params_p->TC_SizeOfDescramblerKeys));
+
+    dprintk("%s > (%d)\n", __func__, tc_descrambler_index);
+
+#ifdef xdebug
+    for (vLoop = 0; vLoop < 8; vLoop++)
+       dprintk("cw[%d] = %0.2x\n", vLoop, Data[vLoop]);
+#endif
+
+    /* As the key could be in use we update KeyValidity in a single write */
+    KeyValidity = readw((void*)&Key_p->KeyValidity);
+    
+    /* Mask off the Algorithm, Chaining Mode, and Residue Mode (LeftResidue or RightResidue) */
+    KeyValidity &= ~TCKEY_ALGORITHM_MASK;
+    KeyValidity &= ~(TCKEY_CHAIN_ALG_MASK | TCKEY_CHAIN_MODE_LR);
+
+/*    STSYS_ClearTCMask16LE((void*)&Key_p->KeyValidity, TCKEY_ALGORITHM_MASK);
+    STSYS_ClearTCMask16LE((void*)&Key_p->KeyValidity, TCKEY_ALGORITHM_DVB);
+
+    STSYS_SetTCMask16LE((void*)&Key_p->KeyValidity, TCKEY_ALGORITHM_DVB);
+*/
+    KeyValidity |= TCKEY_ALGORITHM_DVB;
+    
+    /* fixme: das hab ich geaendert im gegensatz zum orig */
+    if ((Data[0] == 0) && (Data[1] == 0) && (Data[2] == 0) && (Data[3] == 0) && 
+        (Data[4] == 0) && (Data[5] == 0) && (Data[6] == 0) && (Data[7] == 0))
+    {
+        if (Parity == 0 /* even */)
+        {
+            STSYS_WriteTCReg16LE((void*)&Key_p->EvenKey0, 0);
+            STSYS_WriteTCReg16LE((void*)&Key_p->EvenKey1, 0);
+            STSYS_WriteTCReg16LE((void*)&Key_p->EvenKey2, 0);
+            STSYS_WriteTCReg16LE((void*)&Key_p->EvenKey3, 0);
+
+        }
+        else       /* STPTI_KEY_PARITY_ODD_PARITY */
+        {
+            STSYS_WriteTCReg16LE((void*)&Key_p->OddKey0, 0);
+            STSYS_WriteTCReg16LE((void*)&Key_p->OddKey1, 0);
+            STSYS_WriteTCReg16LE((void*)&Key_p->OddKey2, 0);
+            STSYS_WriteTCReg16LE((void*)&Key_p->OddKey3, 0);
+        }
+
+        KeyCheck  = readw((void*)&Key_p->EvenKey0) |
+                    readw((void*)&Key_p->EvenKey1) |
+                    readw((void*)&Key_p->EvenKey2) |
+                    readw((void*)&Key_p->EvenKey3);
+        KeyCheck |= readw((void*)&Key_p->OddKey0)  |
+                    readw((void*)&Key_p->OddKey1)  |
+                    readw((void*)&Key_p->OddKey2)  |
+                    readw((void*)&Key_p->OddKey3);
+
+        if (0 == KeyCheck)
+        {
+             /* if all keys zero then mark as not valid */
+            STSYS_SetTCMask16LE((void*)&Key_p->KeyValidity, 0);
+        }
+
+        return;
+    }
+
+    /* --- valid key of some type to process --- */
+
+    if (Parity == 0 /* even */)
+    {
+    	//dprintk("%s seeting even key\n", __func__);
+
+        STSYS_WriteTCReg16LE((void*)&Key_p->EvenKey0, (Data[0] << 8) | Data[1]);
+        STSYS_WriteTCReg16LE((void*)&Key_p->EvenKey1, (Data[2] << 8) | Data[3]);
+        STSYS_WriteTCReg16LE((void*)&Key_p->EvenKey2, (Data[4] << 8) | Data[5]);
+        STSYS_WriteTCReg16LE((void*)&Key_p->EvenKey3, (Data[6] << 8) | Data[7]);
+
+        KeyValidity |= TCKEY_VALIDITY_TS_EVEN;
+        KeyValidity |= TCKEY_VALIDITY_PES_EVEN;
+       /* STSYS_SetTCMask16LE((void*)&Key_p->KeyValidity, TCKEY_VALIDITY_TS_EVEN);*/
+    }
+    else      /* STPTI_KEY_PARITY_ODD_PARITY */
+    {
+    	//dprintk("%s seeting odd key\n", __func__);
+
+        STSYS_WriteTCReg16LE((void*)&Key_p->OddKey0, (Data[0] << 8) | Data[1]);
+        STSYS_WriteTCReg16LE((void*)&Key_p->OddKey1, (Data[2] << 8) | Data[3]);
+        STSYS_WriteTCReg16LE((void*)&Key_p->OddKey2, (Data[4] << 8) | Data[5]);
+        STSYS_WriteTCReg16LE((void*)&Key_p->OddKey3, (Data[6] << 8) | Data[7]);
+
+        KeyValidity |= TCKEY_VALIDITY_TS_ODD;
+        KeyValidity |= TCKEY_VALIDITY_PES_ODD;
+        /*STSYS_SetTCMask16LE((void*)&Key_p->KeyValidity, TCKEY_VALIDITY_TS_ODD);*/
+    }
+    
+    STSYS_SetTCMask16LE((void*)&Key_p->KeyValidity, KeyValidity);
+
+    //dumpDescrambler(Key_p);
+
+    dprintk("%s <\n", __func__);
+    return;
+}
+
diff --git a/tdt/cvs/driver/pti/pti_descrambler.h b/tdt/cvs/driver/pti/pti_descrambler.h
new file mode 100644
index 0000000..13358a1
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_descrambler.h
@@ -0,0 +1,9 @@
+#ifndef pti_descrambler_123
+#define pti_descrambler_123
+
+void pti_descrambler_allocate(u32 tc_descrambler_index);
+void pti_descrambler_associate_with_slot(u32 tc_descrambler_index, u32 tc_slot_index);
+void pti_descrambler_disassociate_from_slot(u32 tc_descrambler_index, u32 tc_slot_index);
+void pti_descrambler_set(u32 tc_descrambler_index, int Parity, u8 *Data);
+
+#endif
diff --git a/tdt/cvs/driver/pti/pti_filter.c b/tdt/cvs/driver/pti/pti_filter.c
new file mode 100644
index 0000000..47821f6
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_filter.c
@@ -0,0 +1,4 @@
+/*
+ * pti filter functions on hw level
+ */
+
diff --git a/tdt/cvs/driver/pti/pti_hal.c b/tdt/cvs/driver/pti/pti_hal.c
new file mode 100644
index 0000000..095e637
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_hal.c
@@ -0,0 +1,2030 @@
+/* 
+ * indent -bl -bli0 -cdb -sc -bap -bad -pcs -prs -bls -lp -npsl -bbb
+ *
+ * Hardware Abstraction Layer for our pti driver
+ *
+ *		  Session
+ *                   |
+ *		     |
+ *          Slot1 ...... SlotN
+ *            | (N:1)      | (N:1)
+ *            |            |
+ *           DMA      Descrambler
+ *         
+ * Currently Missing is the presentation of multiple ptis
+ * as for 7109 architecture. Must think on this ;-)
+ */
+
+/* FIXME: 
+ * - Da wir nur noch einen Buffer pro Session benutzen kann Session Loop eigentlich 
+ * bei buffer sachen raus
+ * - Descrambler sind auch nicht wirklich pro Slot ?!; muss ich noch einbauen
+ */
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+#include <linux/delay.h>
+#include <linux/time.h>
+#include <linux/errno.h>
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
+#endif
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#if defined (CONFIG_KERNELVERSION) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#include <linux/bpa2.h> 
+#else
+#include <linux/bigphysarea.h>
+#endif
+#include <dvb_demux.h>
+
+/* fixme: this one is still sucking */
+#include "../player2/linux/drivers/media/dvb/stm/dvb/dvb_module.h"
+
+#include "pti_hal.h"
+#include "pti.h"
+#include "pti_main.h"
+#include "pti_session.h"
+#include "pti_slot.h"
+#include "pti_buffer.h"
+#include "pti_descrambler.h"
+
+extern void setDmaThreshold(int a, int b);
+
+/* ********************************
+ * Definitions
+ */
+
+#define SessionHandleStart	10000
+#define SlotHandleStart		20000
+#define DMAHandleStart		30000	/* DMA Handle = Buffer Handle */
+#define DescramblerHandleStart	40000
+
+/* fixme: bringt e2 zum haengen
+ * mal mit spin lock probieren?!
+ */
+#undef use_hal_mutex
+
+/* ********************************
+ * Global Vars
+ */
+
+static int numberOfAvailableDMAs = 0;
+static int numberOfAvailableSlots = 0;
+static int numberOfAvailableCarousels = 0;	/* not used */
+static int numberOfAvailableSectionFilter = 0;
+static int numberOfAvailableSessions = 0;
+static int numberOfAvailableSectionIndex = 0;
+static int numberOfAvailableDescramblerKeys = 0;
+
+/* fixme: hacky ->think about this */
+void (*demultiplexDvbPackets)(struct dvb_demux* demux, const u8 *buf, int count) = NULL;
+struct stpti *pti = NULL;
+
+#define AUD_BUF_SIZE (128 * 188)
+#define MISC_BUF_SIZE (256 * 188)
+
+#define AUD_BUF_NUM 10
+#define MISC_BUF_NUM 3
+
+extern int videoMem;
+// see TC_Params_p->TC_NumberDMAs
+int max_pti_dma = 0X0037;
+
+static int BufferSizes[] =
+{
+  0
+};
+
+static int BufferCounts[] =
+{
+  1
+};
+  
+
+/* ********************************
+ * Structures
+ */
+
+struct tSlot
+{
+  int Handle;			/* Our Handle */
+
+  u32 TCIndex;			/* Index in the TC Structure */
+
+  int inUse;
+
+  int SessionHandle;		/* Our Session Handle */
+  struct tBuffer *pBuffer;	/* Our Buffer/DMA Handle if linked */
+  int DescramblerHandle;	/* Our Descrambler Handle if linked */
+
+  u16 pid;			/* Current set pid */
+
+  int dvb_type;			/* linuxDVB Type */
+  int dvb_pes_type;		/* linuxDVB pes Type */
+
+  struct dvb_demux *demux;	/* linuxDVB Demuxer */
+
+  struct StreamContext_s *DemuxStream;
+  struct DeviceContext_s *DeviceContext;
+
+};
+
+struct tDescrambler
+{
+  int Handle;			/* Our Handle */
+
+  u32 TCIndex;			/* Index in the TC Structure */
+
+  int inUse;
+
+  int SlotHandle;		/* Our Slot Handle if linked */
+
+};
+
+struct tSession
+{
+  int Handle;			/* Our Handle */
+
+  u32 TCIndex;			/* Index in the TC Structure */
+  u32 TSMergerTag;
+
+  int inUse;
+
+  struct tSlot **vSlots;
+  struct tDescrambler **vDescrambler;
+
+  struct tBuffer *pBufferList;
+};
+
+static struct tSession **vSessions = NULL;
+
+#ifdef use_hal_mutex
+
+/* fixme: hatte vor das ganze mal mit spinlocks zu testen
+ * deshalb hier mit eigenen funktionen
+ */
+
+static struct mutex HALLock;
+
+int hal_mutex_lock ( struct mutex *lock )
+{
+  mutex_lock ( lock );
+}
+
+int hal_mutex_unlock ( struct mutex *lock )
+{
+  mutex_unlock ( lock );
+}
+
+#endif
+
+static int pti_hal_convert_source ( const tInputSource source, int *pTag );
+
+/* **************************************************************
+ * Intialize our data structures depening on TC-Code. For this
+ * reason we call pti_main_loadtc() here.
+ */
+void pti_hal_init ( struct stpti *pti , struct dvb_demux* demux, void (*_demultiplexDvbPackets)(struct dvb_demux* demux, const u8 *buf, int count), int numVideoBuffers)
+{
+  STPTI_TCParameters_t *TC_Params_p = &tc_params;
+  int vLoopSession, vLoopSlots, vLoopDescrambler;
+  int i;
+
+  dprintk ( "%s >\n", __func__ );
+
+  pti_main_loadtc ( pti );
+
+  numberOfAvailableSessions = TC_Params_p->TC_NumberOfSessions;
+
+  numberOfAvailableCarousels = TC_Params_p->TC_NumberCarousels;
+  numberOfAvailableDMAs = TC_Params_p->TC_NumberDMAs;
+  numberOfAvailableDescramblerKeys =
+    TC_Params_p->TC_NumberDescramblerKeys / TC_Params_p->TC_NumberOfSessions;
+  numberOfAvailableSectionFilter = TC_Params_p->TC_NumberSectionFilters;
+  numberOfAvailableSlots =
+    TC_Params_p->TC_NumberSlots / TC_Params_p->TC_NumberOfSessions;
+  numberOfAvailableSectionIndex = TC_Params_p->TC_NumberIndexs;
+
+#ifdef use_hal_mutex
+  mutex_init ( &HALLock );
+#endif
+
+  BufferCounts[0] = numVideoBuffers;
+
+  /* Dagobert: goHackHack: I would like to make the buffer adjustable,
+   * vor first glance I only make the videoBufferSize adjustable 
+   * and assume it is on position 0 in this array!
+   */
+  BufferSizes[0] = videoMem * 188; 
+
+  // calc the max dma buffers for pti_task
+  // use of static value (TC_Params_p->TC_NumberDMAs) needs performance
+  max_pti_dma = 0;
+  for(i=0; i<sizeof(BufferCounts)/sizeof(BufferCounts[0]); i++)
+  {
+     max_pti_dma += BufferCounts[i];
+  }
+
+  printk("using videoMem = %d (packets = %d)\n", videoMem * 188, videoMem);
+
+  /* initialize the buffer pools */
+  pti_buffer_pool_init(sizeof(BufferSizes)/sizeof(BufferSizes[0]),
+                       BufferSizes, BufferCounts);
+
+  /*
+   * very memory wasting but I think its ok 
+   */
+
+  vSessions =
+    kmalloc ( sizeof ( struct tSession * ) * numberOfAvailableSessions,
+	      GFP_KERNEL );
+
+  for ( vLoopSession = 0; vLoopSession < numberOfAvailableSessions;
+	vLoopSession++ )
+  {
+    vSessions[vLoopSession] =
+      kmalloc ( sizeof ( struct tSession ), GFP_KERNEL );
+
+    memset ( vSessions[vLoopSession], 0, sizeof ( struct tSession ) );
+
+    /*
+     * set-up handle 
+     */
+    vSessions[vLoopSession]->Handle = SessionHandleStart + vLoopSession;
+
+    vSessions[vLoopSession]->TCIndex = vLoopSession;
+
+    vSessions[vLoopSession]->vSlots =
+      kmalloc ( sizeof ( struct tSlot * ) * numberOfAvailableSlots,
+		GFP_KERNEL );
+
+    for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots; vLoopSlots++ )
+    {
+      vSessions[vLoopSession]->vSlots[vLoopSlots] =
+	kmalloc ( sizeof ( struct tSlot ), GFP_KERNEL );
+
+      memset ( vSessions[vLoopSession]->vSlots[vLoopSlots], 0,
+	       sizeof ( struct tSlot ) );
+
+      /*
+       * set-up handles 
+       */
+      vSessions[vLoopSession]->vSlots[vLoopSlots]->Handle =
+	SlotHandleStart + vLoopSlots + ( vLoopSession * 1000 );
+
+      /*
+       * slots will be count globally from 0 to max 
+       */
+      vSessions[vLoopSession]->vSlots[vLoopSlots]->TCIndex =
+	vLoopSession * numberOfAvailableSlots + vLoopSlots;
+    }
+
+    vSessions[vLoopSession]->vDescrambler =
+      kmalloc ( sizeof ( struct tDescrambler * ) *
+		numberOfAvailableDescramblerKeys, GFP_KERNEL );
+
+    for ( vLoopDescrambler = 0;
+	  vLoopDescrambler < numberOfAvailableDescramblerKeys;
+	  vLoopDescrambler++ )
+    {
+      vSessions[vLoopSession]->vDescrambler[vLoopDescrambler] =
+	kmalloc ( sizeof ( struct tDescrambler ), GFP_KERNEL );
+
+      memset ( vSessions[vLoopSession]->vDescrambler[vLoopDescrambler], 0,
+	       sizeof ( struct tDescrambler ) );
+
+      /*
+       * set-up handles 
+       */
+      vSessions[vLoopSession]->vDescrambler[vLoopDescrambler]->Handle =
+	DescramblerHandleStart + vLoopDescrambler + ( vLoopSession * 1000 );
+
+      /*
+       * descrambler will be count globally from 0 to max 
+       */
+      vSessions[vLoopSession]->vDescrambler[vLoopDescrambler]->TCIndex =
+	vLoopSession * numberOfAvailableDescramblerKeys + vLoopDescrambler;
+    }
+
+  }
+
+  demultiplexDvbPackets = _demultiplexDvbPackets;
+
+  // FIXME: remove
+  //pti_session_init ( STPTI_STREAM_ID_TSIN1, vSessions[0]->vSlots[0]->TCIndex,
+  //		     numberOfAvailableSlots );
+#ifdef use_irq
+  dprintk ( "%s !!!!!!!!!!!!! start irq !!!!!!!!!!!!!!!\n", __func__ );
+
+  if ( request_irq
+       ( 160, pti_interrupt_handler, SA_INTERRUPT, "PTI", pti ) != 0 )
+  {
+    dprintk ( "request irq failed\n" );
+  }
+
+  //enable the pti interrupt     
+  {
+  TCDevice_t *myTC = ( TCDevice_t * ) pti->pti_io;
+
+  writel ( 3, ( void * ) &myTC->PTIIntEnable0 );
+  //writel ( 0x7, pti->pti_io + PTI_DMAEMPTY_EN );
+  }
+#endif
+
+  spin_lock_init ( &pti->irq_lock );
+  kernel_thread ( pti_task, pti, 0 );
+
+  dprintk ( "%s <\n", __func__ );
+}
+
+/* ************************************************************* 
+ * Helper Functions for Sessions
+ */
+
+/* *********************************
+ * Get a new session handle.
+ * pti_hal_init must be called before.
+ * 
+ * O: Errorcode or session handle
+ */
+int pti_hal_get_new_session_handle ( tInputSource source, struct dvb_demux * demux )
+{
+  int session_handle = cHALNoFreeSession;
+  int vLoopSessions;
+  int srcTag = 0;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+  if ( pti_hal_convert_source ( source, &srcTag ) != 0 )
+  {
+    return cHALNotInitialized;
+  }
+
+#ifdef use_hal_mutex
+  hal_mutext_lock ( &( HALLock ) );
+#endif
+
+  // FIXME: start with 0
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->inUse == 0 )
+    {
+      session_handle = vSessions[vLoopSessions]->Handle;
+      vSessions[vLoopSessions]->inUse = 1;
+      vSessions[vLoopSessions]->TSMergerTag = srcTag;
+
+      vSessions[vLoopSessions]->TCIndex =
+	//pti_session_init(srcTag,
+	pti_session_init ( STPTI_STREAM_ID_NONE, //STPTI_STREAM_ID_TSIN0 + vLoopSessions,
+                           vSessions[vLoopSessions]->vSlots[0]->TCIndex,
+                           numberOfAvailableSlots );
+
+      /*
+       * this should never happen! 
+       */
+      if ( vSessions[vLoopSessions]->TCIndex == -1 )
+      {
+	vSessions[vLoopSessions]->inUse = 0;
+	session_handle = cHALNoFreeSession;
+      }
+
+      break;
+    }
+  }
+
+#ifdef use_hal_mutex
+  hal_mutex_unlock ( &( HALLock ) );
+#endif
+
+  dprintk ( "%s (%d) <\n", __func__, session_handle );
+  return session_handle;
+}
+
+int pti_hal_get_session_handle ( int tc_session_number )
+{
+  int session_handle = cHALNotInitialized;
+  int vLoopSessions;
+
+//      dprintk("%s >\n", __func__);
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( ( vSessions[vLoopSessions]->inUse == 1 )
+	 && ( vSessions[vLoopSessions]->TCIndex == tc_session_number ) )
+    {
+      session_handle = vSessions[vLoopSessions]->Handle;
+      break;
+    }
+  }
+
+//      dprintk("%s (%d)<\n", __func__, session_handle);
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+
+  return session_handle;
+}
+
+/* **************************************
+ * Die Slots sind zwar global definiert
+ * aber auf die Sessions aufgeteilt,
+ * so koennen wir bestimmen wie die
+ * interne session nummer ist.
+ */
+int pti_hal_get_session_number_from_tc_slot_number ( int tc_slot_number )
+{
+  int tc_session_number = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+
+//      dprintk("%s >\n", __func__);
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->inUse == 1 )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 ) &&
+	     ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->TCIndex ==
+	       tc_slot_number ) )
+	{
+	  tc_session_number = vSessions[vLoopSessions]->TCIndex;
+	  break;
+	}
+      }
+    }
+  }
+
+//      dprintk("%s (%d) <\n", __func__, tc_session_number);
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return tc_session_number;
+}
+
+struct dvb_demux * pti_hal_get_demux_from_dma_index ( int dmaIndex )
+{
+  int vLoopSessions;
+  int vLoopSlots;
+  struct dvb_demux *pDemux = NULL;
+
+  if ( vSessions == NULL )
+    return NULL;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->inUse == 1 )
+    {
+      struct tBuffer *pBuffer = vSessions[vLoopSessions]->pBufferList;
+
+      /* find the buffer assigned to the specified DMA */
+      while ( pBuffer != NULL)
+      {
+	if ( pBuffer->dmaIndex == dmaIndex )
+	{
+          /* all slots of a session must be assigned to the same demux,
+             so take the demux from the first valid slot */
+	  for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+		vLoopSlots++ )
+	  {
+	    if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	    {
+	      pDemux = vSessions[vLoopSessions]->vSlots[vLoopSlots]->demux;
+	      break;
+	    }
+	  }
+	}
+	pBuffer = pBuffer->pNext;
+      }
+      if(pDemux != NULL)
+        break;
+    }
+  }
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return pDemux;
+}
+
+int pti_hal_free_session ( int session_handle )
+{
+
+/* fixme: free all slots, dmas ... */
+  printk ( "FIXME: %s not implemented currently \n", __func__ );
+  return -1;
+}
+
+/* ************************************************************* 
+ *
+ * Helper function for setting the session source (frontend)
+ *
+ *************************************************************/
+static int pti_hal_convert_source ( const tInputSource source, int *pTag )
+{
+  *pTag = source + STPTI_STREAM_ID_TSIN0;
+
+  return 0;
+}
+
+int pti_hal_set_source ( int session_handle, const tInputSource source )
+{
+  int i;
+  int tsmerger_tag = 0;
+
+  if ( pti_hal_convert_source ( source, &tsmerger_tag ) != 0 )
+  {
+    return -EINVAL;
+  }
+
+  for ( i = 0; i < numberOfAvailableSessions; i++ )
+  {
+    if ( vSessions[i]->Handle == session_handle )
+    {
+      pti_session_set_source ( vSessions[i]->TCIndex, tsmerger_tag );
+      vSessions[i]->TSMergerTag = tsmerger_tag;
+      printk( "%s(): %d, %d\n", __func__, vSessions[i]->TCIndex, tsmerger_tag);
+      break;
+    }
+  }
+
+  if ( i == numberOfAvailableSessions )
+  {
+    printk ( "%s(): invalid session (%x)\n", __func__, session_handle );
+    return -EINVAL;
+  }
+
+  return 0;
+}
+
+/* ************************************************************* 
+ * Helper Functions for Slots
+ */
+
+int pti_hal_get_new_slot_handle ( int session_handle, int dvb_type,
+				  int dvb_pes_type, struct dvb_demux *demux,
+				  struct StreamContext_s *DemuxStream,
+				  struct DeviceContext_s *DeviceContext )
+{
+  int slot_handle = cHALNotInitialized;
+  int noFree = 0;
+  int vLoopSessions, vLoopSlots;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 0 )
+	{
+	  slot_handle = vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle;
+	  pti_slot_allocate ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+			      TCIndex, dvb_type, dvb_pes_type );
+
+	  /*
+	   * this should never happen 
+	   */
+	  if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->TCIndex == -1 )
+	  {
+	    slot_handle = cHALNoFreeSlot;
+	  }
+	  else
+	  {
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->demux = demux;
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->DemuxStream =
+	      DemuxStream;
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->DeviceContext =
+	      DeviceContext;
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_type = dvb_type;
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_pes_type =
+	      dvb_pes_type;
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->SessionHandle =
+	      vSessions[vLoopSessions]->Handle;
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse = 1;
+	  }
+
+	  noFree = 1;
+	  break;
+	}
+      }				/* for slots */
+
+      if ( noFree == 0 )
+	slot_handle = cHALNoFreeSlot;
+
+    }
+  }				/* for sessions */
+
+  dprintk ( "%s (%d) <\n", __func__, slot_handle );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return slot_handle;
+}
+
+int pti_hal_slot_set_pid ( int session_handle, int slot_handle, u16 pid )
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	     slot_handle )
+	{
+	  if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+	       DescramblerHandle != 0 )
+	  {
+	    int vLoopDescrambler;
+
+	    for ( vLoopDescrambler = 0;
+		  vLoopDescrambler < numberOfAvailableDescramblerKeys;
+		  vLoopDescrambler++ )
+	    {
+	      if ( ( vSessions[vLoopSessions]->
+		     vDescrambler[vLoopDescrambler]->Handle ==
+		     vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+		     DescramblerHandle )
+		   && ( vSessions[vLoopSessions]->
+			vDescrambler[vLoopDescrambler]->inUse == 1 ) )
+	      {
+		//u8 Data[8] = {0,0,0,0,0,0,0,0};        
+		/*
+		 * set descrambler invalid 
+		 * pti_descrambler_set(vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->TCIndex, 0, &Data[0]);
+		 * pti_descrambler_set(vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->TCIndex, 1, &Data[0]);
+		 */
+	      }
+	    }
+	  }
+	  vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid = pid;
+	  pti_slot_set_pid ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+			     TCIndex, pid );
+	  error = cHALNoError;
+
+	  break;
+	}
+      }				/* for slots */
+    }
+  }				/* for sessions */
+
+  dprintk ( "%s (%d) <\n", __func__, error );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+
+int pti_hal_slot_clear_pid ( int session_handle, int slot_handle )
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	     slot_handle )
+	{
+	  if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+	       DescramblerHandle != 0 )
+	  {
+	    int vLoopDescrambler;
+
+	    for ( vLoopDescrambler = 0;
+		  vLoopDescrambler < numberOfAvailableDescramblerKeys;
+		  vLoopDescrambler++ )
+	    {
+	      if ( ( vSessions[vLoopSessions]->
+		     vDescrambler[vLoopDescrambler]->Handle ==
+		     vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+		     DescramblerHandle )
+		   && ( vSessions[vLoopSessions]->
+			vDescrambler[vLoopDescrambler]->inUse == 1 ) )
+	      {
+		//u8 Data[8] = {0,0,0,0,0,0,0,0};        
+		/*
+		 * set descrambler invalid 
+		 * pti_descrambler_set(vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->TCIndex, 0, &Data[0]);
+		 * pti_descrambler_set(vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->TCIndex, 1, &Data[0]);
+		 */
+	      }
+	    }
+	  }
+	  vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid = 0;
+
+	  pti_slot_clear_pid ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+			       TCIndex,
+			       pti_hal_get_tc_dma_number ( session_handle,
+							   slot_handle ), 1 );
+
+	  error = cHALNoError;
+
+	  break;
+	}
+      }				/* for slots */
+    }
+  }				/* for sessions */
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+
+int pti_hal_slot_link_buffer ( int session_handle, int slot_handle,
+			       BUFFER_TYPE bufType)
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+  struct tBuffer *pBuffer = NULL;
+  int found = 0;
+  int allocated = 0;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	     slot_handle )
+	{
+	  if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->pBuffer !=
+	       NULL )
+	  {
+	    error = cHALSlotAlreadyInUse;
+	  }
+	  else
+	  {
+            found = 1;
+	    break;
+	  }
+	}
+      }	
+      if(found)
+        break;
+    }
+  }
+
+  if(found)
+  {
+#if defined(SEPARATE_MISC_BUFFERS)
+
+    /* SEC and TS types other than video and audio are
+       collected in separate buffers */
+    if (bufType == MISC_BUFFER)
+    {
+      pBuffer = pti_buffer_get( MISC_BUF_SIZE);
+      allocated = 1;
+    }
+
+#endif
+
+#if defined(SEPARATE_AUDIO_BUFFERS)
+
+    /* audio TS packets are collected in separate buffers */
+    if (bufType == AUD_BUFFER)
+    {
+      pBuffer = pti_buffer_get(AUD_BUF_SIZE);
+      allocated = 1;
+    }
+
+#endif
+
+    if(pBuffer == NULL)
+    {
+      /* no buffer found so far
+         check whether a video buffer is already allocated */
+      //if(bufType != VID_BUFFER)
+      {
+	pBuffer = vSessions[vLoopSessions]->pBufferList;
+	while(pBuffer != NULL)
+	{
+	  if(pBuffer->bufSize == videoMem * 188)
+	  {
+	    break;
+	  }
+
+	  pBuffer = pBuffer->pNext;
+	}
+      }
+
+      if(pBuffer == NULL)
+      {
+        /* no video buffer in the list yet */
+	pBuffer = pti_buffer_get(videoMem * 188);
+	allocated = 1;
+      }
+
+    }
+
+    if(pBuffer == NULL)
+    {
+      return error;
+    }
+  
+    /* prepend the buffer to the list head */
+    if(allocated)
+    {
+      pBuffer->pNext = vSessions[vLoopSessions]->pBufferList;
+      vSessions[vLoopSessions]->pBufferList = pBuffer;
+    }
+
+    pBuffer->sessionHandle = session_handle;
+
+    if(bufType == VID_BUFFER)
+    {
+      /* increase the DMA threshold to reduce the interrupt rate caused by
+	 the video stream */
+      setDmaThreshold(pBuffer->dmaIndex, TC_DMA_THRESHOLD_HIGH);
+    }
+
+    pti_slot_link_to_buffer ( vSessions[vLoopSessions]->
+			      vSlots[vLoopSlots]->TCIndex,
+			      pBuffer->dmaIndex );
+
+    pBuffer->slotCount++;
+
+    vSessions[vLoopSessions]->vSlots[vLoopSlots]->pBuffer = pBuffer;
+
+    error = cHALNoError;
+  }
+
+  dprintk ( "%s (%d) <\n", __func__, error );
+
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+
+  return error;
+}
+
+int pti_hal_get_slot_handle ( int session_handle, int tc_slot_number )
+{
+  int slot_handle = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->TCIndex ==
+	       tc_slot_number )
+	     && vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	{
+	  slot_handle = vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle;
+	  break;
+	}
+      }
+    }
+  }
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return slot_handle;
+}
+
+struct dvb_demux *pti_hal_get_demux_from_slot ( int session_handle,
+						int slot_handle )
+{
+  struct dvb_demux *demux = NULL;
+  int vLoopSessions, vLoopSlots;
+
+  if ( vSessions == NULL )
+    return NULL;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	       slot_handle )
+	     && vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	{
+	  demux = vSessions[vLoopSessions]->vSlots[vLoopSlots]->demux;
+	  break;
+	}
+      }
+    }
+  }
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return demux;
+}
+
+int pti_hal_get_type_from_slot ( int session_handle, int slot_handle,
+				 int *ts_type, int *pes_type )
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	       slot_handle )
+	     && vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	{
+
+	  *ts_type = vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_type;
+	  *pes_type =
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_pes_type;
+	  error = cHALNoError;
+	  break;
+	}
+      }
+    }
+  }
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+
+struct StreamContext_s *pti_hal_get_stream_from_slot ( int session_handle,
+						       int slot_handle )
+{
+  struct StreamContext_s *stream = NULL;
+
+  int vLoopSessions, vLoopSlots;
+
+  if ( vSessions == NULL )
+    return NULL;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	       slot_handle )
+	     && vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	{
+
+	  stream = vSessions[vLoopSessions]->vSlots[vLoopSlots]->DemuxStream;
+	  break;
+	}
+      }
+    }
+  }
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return stream;
+}
+
+struct DeviceContext_s *pti_hal_get_context_from_slot ( int session_handle,
+							int slot_handle )
+{
+  struct DeviceContext_s *context = NULL;
+
+  int vLoopSessions, vLoopSlots;
+
+  if ( vSessions == NULL )
+    return NULL;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	       slot_handle )
+	     && vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	{
+
+	  context =
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->DeviceContext;
+	  break;
+	}
+      }
+    }
+  }
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return context;
+}
+
+void pti_hal_get_slots_for_pid ( int session_handle, u16 pid, int **slots,
+				 int *number_slots )
+{
+  int vLoopSessions, vLoopSlots;
+
+  if ( vSessions == NULL )
+    return;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  *slots = NULL;
+  *number_slots = 0;
+
+  //dprintk("%s >(session_handle %d, pid %d)\n", __func__,session_handle, pid);   
+
+  /*
+   * I think in the kernel is no realloc so I first count the slots ;-) 
+   */
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+//                      dprintk("test pid = %d\n", vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid); 
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 ) &&
+	     ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid == pid ) )
+	{
+	  *number_slots += 1;
+	}
+      }
+    }
+  }
+
+  if ( *number_slots != 0 )
+  {
+    int *vSlots;
+    int count = 0;
+
+    vSlots = kmalloc ( sizeof ( int ) * *number_slots, GFP_KERNEL );
+
+    for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	  vLoopSessions++ )
+    {
+      if ( vSessions[vLoopSessions]->Handle == session_handle )
+      {
+	for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	      vLoopSlots++ )
+	{
+	  if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 ) &&
+	       ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid == pid ) )
+	  {
+	    vSlots[count++] =
+	      vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle;
+	  }
+	}
+      }
+    }
+
+    if ( count != *number_slots )
+      printk ( "something went wrong\n" );
+
+    /*
+     * remeber to free outside 
+     */
+    *slots = vSlots;
+  }
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+}
+
+
+int pti_hal_slot_unlink_buffer ( int session_handle, int slot_handle)
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+  struct tBuffer *pBuffer = NULL;
+
+  dprintk ( "%s > %x, %x, %p\n", __func__, session_handle, slot_handle,
+	    pBuffer );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	       slot_handle )
+	     && vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	{
+	  /*
+	   * unlink buffer / dma from slot in hw 
+	   */
+	  pti_slot_unlink_buffer ( vSessions[vLoopSessions]->
+				   vSlots[vLoopSlots]->TCIndex );
+
+          pBuffer = vSessions[vLoopSessions]->vSlots[vLoopSlots]->pBuffer;
+          if(pBuffer != NULL)
+          {
+	    if( pBuffer->slotCount > 0)
+	      pBuffer->slotCount--;
+	    else
+	      printk("%s(): INVALID SLOT COUNT (%d)\n", __func__,
+                                   pBuffer->slotCount);
+
+	    if(pBuffer->slotCount == 0)
+	    {
+              /* invalidate references to the buffer */
+              if(vSessions[vLoopSessions]->pBufferList == pBuffer)
+              {
+                /* the buffer is the first on the list */
+                vSessions[vLoopSessions]->pBufferList =
+                               vSessions[vLoopSessions]->pBufferList->pNext;
+              }
+              else
+              {
+                struct tBuffer *pTmp = vSessions[vLoopSessions]->pBufferList;
+                int loop = 0;
+
+                while(pTmp != NULL)
+                {
+                  printk(" pTmp = %p\n", pTmp);
+                  if(pTmp->pNext == pBuffer)
+                  {
+                    /* remove the buffer from the list */
+                    pTmp->pNext = pBuffer->pNext;
+                    break;
+                  }
+                  if((pTmp == pBuffer->pNext) || (loop > 50))
+                  {
+                    printk("%s(): LIST ERROR %p, %p, %p\n", __func__, pTmp, pBuffer, pBuffer->pNext);
+                    pTmp->pNext = NULL;
+                    break;
+                  }
+                  pTmp = pTmp->pNext;
+                  loop++;
+                }
+
+                if(pTmp == NULL)
+                  printk("%s(): buffer not found in the list\n", __func__);
+              }
+
+	      /* no buffer references, release buffer */
+	      pti_buffer_free(pBuffer);
+	    }
+            else
+            {
+              if(vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_pes_type == DMX_TS_PES_VIDEO)
+              {
+		/* increase the DMA threshold to allow low-bitrate 
+		   interrupts to arrive on time */
+		setDmaThreshold(pBuffer->dmaIndex, TC_DMA_THRESHOLD_LOW);
+              }
+            }
+
+	    /*
+	     * we have no buffer linkage 
+	     */
+	    vSessions[vLoopSessions]->vSlots[vLoopSlots]->pBuffer = NULL;
+
+	    error = cHALNoError;
+          }
+          else
+          {
+            printk("%s(): no buffer attached\n", __func__);
+          }
+	  break;
+	}
+      }
+    }
+  }
+
+  dprintk ( "%s (%d) <\n", __func__, error );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+
+int pti_hal_slot_free ( int session_handle, int slot_handle )
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	       slot_handle )
+	     && vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	{
+	  /*
+	   * clear the pid in hw 
+	   */
+	  pti_slot_clear_pid ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+			       TCIndex,
+			       pti_hal_get_tc_dma_number ( session_handle,
+							   slot_handle ), 1 );
+
+	  /*
+	   * unlink from buffer if necessary 
+	   */
+	  if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->pBuffer !=
+	       NULL )
+	    pti_hal_slot_unlink_buffer ( session_handle, slot_handle);
+
+	  /*
+	   * free the slot in hw 
+	   */
+	  pti_slot_free ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+			  TCIndex );
+
+	  /*
+	   * init our handling 
+	   */
+	  vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse = 0;
+	  vSessions[vLoopSessions]->vSlots[vLoopSlots]->demux = NULL;
+          // DB: commented out to allow resetting the DMA threshold
+	  //vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_type = 0;
+	  //vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_pes_type = 0;
+	  vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid = 0;
+	  vSessions[vLoopSessions]->vSlots[vLoopSlots]->DescramblerHandle = 0;
+
+	  error = cHALNoError;
+
+	  break;
+	}
+      }
+    }
+  }
+
+  dprintk ( "%s (%d) <\n", __func__, slot_handle );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return slot_handle;
+}
+
+/* ************************************************************* 
+ * Helper Functions for DMAs
+ */
+
+int pti_hal_get_tc_dma_number ( int session_handle, int slot_handle )
+{
+  int tc_dma_number = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots;
+
+//      dprintk("%s >\n", __func__);
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	       slot_handle )
+	     && vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse == 1 )
+	{
+	  if( vSessions[vLoopSessions]->vSlots[vLoopSlots]->pBuffer  != NULL)
+          {
+	    tc_dma_number = vSessions[vLoopSessions]->vSlots[vLoopSlots]->pBuffer->dmaIndex;
+	    break;
+          }
+	}
+      }
+
+    }				/* if */
+  }				/* for sessions */
+
+//      dprintk("%s <\n", __func__);
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return tc_dma_number;
+}
+
+#if 0
+
+int pti_hal_buffer_enable ( int session_handle, struct tBuffer *pBuffer )
+{
+  int error = cHALNotInitialized;
+
+  return 0;
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopDMAs = 0; vLoopDMAs < numberOfAvailableDMAs; vLoopDMAs++ )
+      {
+	if ( ( vDMAs[vLoopDMAs]->Handle == buffer_handle ) &&
+	     ( vDMAs[vLoopDMAs]->inUse == 1 ) &&
+	     ( vDMAs[vLoopDMAs]->SlotUsage != 0 ) )
+	{
+	  vDMAs[vLoopDMAs]->EnableCount++;
+	  if ( vDMAs[vLoopDMAs]->EnableCount == vDMAs[vLoopDMAs]->SlotUsage )
+	  {
+	    /*
+	     * enable the signalling 
+	     */
+	    pti_buffer_enable_signalling ( vDMAs[vLoopDMAs]->TCIndex );
+
+	    dprintk ( "enable dma signalling now\n" );
+	  }
+	  else
+	  {
+	    dprintk ( "EnableCount = %d, SlotUsage = %d\n",
+		      vDMAs[vLoopDMAs]->EnableCount,
+		      vDMAs[vLoopDMAs]->SlotUsage );
+	  }
+
+	  error = cHALNoError;
+	  break;
+	}
+      }
+    }
+  }
+
+  dprintk ( "%s (%d) <\n", __func__, error );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+
+int pti_hal_buffer_disable ( int session_handle, int buffer_handle )
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopDMAs;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopDMAs = 0; vLoopDMAs < numberOfAvailableDMAs; vLoopDMAs++ )
+      {
+	if ( ( vDMAs[vLoopDMAs]->Handle == buffer_handle ) &&
+	     ( vDMAs[vLoopDMAs]->inUse == 1 ) &&
+	     ( vDMAs[vLoopDMAs]->SlotUsage != 0 ) )
+	{
+	  vDMAs[vLoopDMAs]->EnableCount--;
+
+	  if ( vDMAs[vLoopDMAs]->EnableCount != vDMAs[vLoopDMAs]->SlotUsage )
+	  {
+	    /*
+	     * disable the signalling 
+	     */
+	    pti_buffer_disable_signalling ( vDMAs[vLoopDMAs]->TCIndex );
+	  }
+
+	  error = cHALNoError;
+	  break;
+	}
+      }
+    }
+  }
+
+  dprintk ( "%s <\n", __func__ );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+#endif
+
+/* ***************************************************************
+ * Descrambler
+ */
+
+int pti_hal_get_new_descrambler ( int session_handle )
+{
+  int descrambler_handle = cHALNotInitialized;
+  int noFree = 0;
+  int vLoopSessions, vLoopDescrambler;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopDescrambler = 0;
+	    vLoopDescrambler < numberOfAvailableDescramblerKeys;
+	    vLoopDescrambler++ )
+      {
+	if ( vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+	     inUse == 0 )
+	{
+	  descrambler_handle =
+	    vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->Handle;
+	  pti_descrambler_allocate ( vSessions[vLoopSessions]->
+				     vDescrambler[vLoopDescrambler]->
+				     TCIndex );
+
+	  /*
+	   * this should never happen 
+	   */
+	  if ( vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+	       TCIndex == -1 )
+	  {
+	    descrambler_handle = cHALNoFreeDescrambler;
+	  }
+	  else
+	  {
+	    vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->inUse =
+	      1;
+	    noFree = 1;
+	    break;
+	  }			/* else */
+	}			/* if */
+      }				/* for descrambler */
+
+      if ( noFree == 0 )
+	descrambler_handle = cHALNoFreeDescrambler;
+    }				/* if */
+  }				/* for sessions */
+
+  dprintk ( "%s (%d) >\n", __func__, descrambler_handle );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return descrambler_handle;
+
+}
+
+int pti_hal_descrambler_link ( int session_handle, int descrambler_handle,
+			       int slot_handle )
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots, vLoopDescrambler;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+	if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+	     slot_handle )
+	{
+	  if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+	       DescramblerHandle != 0 )
+	  {
+	    /*quack: do not retun an error instead unlink the
+		  current descrambler and link the new one*/
+		/*error = cHALSlotAlreadyInUse;*/
+	    for ( vLoopDescrambler = 0;
+		  vLoopDescrambler < numberOfAvailableDescramblerKeys;
+		  vLoopDescrambler++ )
+	    {
+	      if ( ( vSessions[vLoopSessions]->
+		     vDescrambler[vLoopDescrambler]->Handle ==
+		     vSessions[vLoopSessions]->vSlots[vLoopSlots]->DescramblerHandle )
+		   && ( vSessions[vLoopSessions]->
+			vDescrambler[vLoopDescrambler]->inUse == 1 ))
+	    			pti_descrambler_disassociate_from_slot ( vSessions[vLoopSessions]->
+						   vDescrambler
+						   [vLoopDescrambler]->
+						   TCIndex,
+						   vSessions[vLoopSessions]->
+						   vSlots[vLoopSlots]->
+						   TCIndex );
+	    }
+          }
+	  /*else*/
+	  {
+	    /*
+	     * descrambler suchen 
+	     */
+	    for ( vLoopDescrambler = 0;
+		  vLoopDescrambler < numberOfAvailableDescramblerKeys;
+		  vLoopDescrambler++ )
+	    {
+	      if ( ( vSessions[vLoopSessions]->
+		     vDescrambler[vLoopDescrambler]->Handle ==
+		     descrambler_handle )
+		   && ( vSessions[vLoopSessions]->
+			vDescrambler[vLoopDescrambler]->inUse == 1 )
+		   /*
+		    * &&
+		    * descrambler knnen mit mehreren slots verlinkt werden,
+		    * * muss ich also irgendwie anders mache
+		    * (vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->SlotHandle == 0)  dont link twice 
+		    */  )
+
+	      {
+		pti_descrambler_associate_with_slot ( vSessions
+						      [vLoopSessions]->
+						      vDescrambler
+						      [vLoopDescrambler]->
+						      TCIndex,
+						      vSessions
+						      [vLoopSessions]->
+						      vSlots[vLoopSlots]->
+						      TCIndex );
+
+		/*
+		 * internal link 
+		 */
+		vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+		  SlotHandle = slot_handle;
+		vSessions[vLoopSessions]->vSlots[vLoopSlots]->
+		  DescramblerHandle = descrambler_handle;
+
+		error = cHALNoError;
+		break;
+	      }			/* if */
+	    }			/* for descrambler */
+	  }			/* else */
+	}			/* if */
+      }				/* for slots */
+    }				/* if */
+  }				/* for sessions */
+
+  dprintk ( "%s (%d)<\n", __func__, error );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+
+int pti_hal_descrambler_unlink ( int session_handle, int descrambler_handle )
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopSlots, vLoopDescrambler;
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      /*
+       * descrambler suchen 
+       */
+      for ( vLoopDescrambler = 0;
+	    vLoopDescrambler < numberOfAvailableDescramblerKeys;
+	    vLoopDescrambler++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+	       Handle == descrambler_handle )
+	     && ( vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+		  SlotHandle != 0 )
+	     && ( vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+		  inUse == 1 ) )
+	{
+	  /*
+	   * get slot index 
+	   */
+	  for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+		vLoopSlots++ )
+	  {
+	    if ( vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle ==
+		 vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+		 SlotHandle )
+	      break;
+	  }
+
+	  /*
+	   * hw unlink 
+	   */
+	  pti_descrambler_disassociate_from_slot ( vSessions[vLoopSessions]->
+						   vDescrambler
+						   [vLoopDescrambler]->
+						   TCIndex,
+						   vSessions[vLoopSessions]->
+						   vSlots[vLoopSlots]->
+						   TCIndex );
+
+	  /*
+	   * internal unlink 
+	   */
+	  vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+	    SlotHandle = 0;
+	  vSessions[vLoopSessions]->vSlots[vLoopSlots]->DescramblerHandle = 0;
+
+	  error = cHALNoError;
+	  break;
+
+	}			/* if */
+      }				/* for descrambler */
+    }				/* if */
+  }				/* for sessions */
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+
+int pti_hal_descrambler_set ( int session_handle, int descrambler_handle,
+			      u8 * Data, int parity )
+{
+  int error = cHALNotInitialized;
+  int vLoopSessions, vLoopDescrambler;
+
+  if ( vSessions == NULL )
+    return cHALNotInitialized;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+  dprintk ( "%s session=%d  descrambler=%d\n", __func__, session_handle,descrambler_handle);
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+    if ( vSessions[vLoopSessions]->Handle == session_handle )
+    {
+      /*
+       * descrambler suchen 
+       */
+      for ( vLoopDescrambler = 0;
+	    vLoopDescrambler < numberOfAvailableDescramblerKeys;
+	    vLoopDescrambler++ )
+      {
+	if ( ( vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+	       Handle == descrambler_handle )
+	     && ( vSessions[vLoopSessions]->vDescrambler[vLoopDescrambler]->
+		  inUse == 1 ) )
+	{
+	  pti_descrambler_set ( vSessions[vLoopSessions]->
+				vDescrambler[vLoopDescrambler]->TCIndex,
+				parity, Data );
+
+	  error = cHALNoError;
+	  break;
+
+	}			/* if */
+      }				/* for descrambler */
+    }				/* if */
+  }				/* for sessions */
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return error;
+}
+
+int pti_hal_descrambler_clear ( void )
+{
+  return -1;
+}
+
+int pti_hal_descrambler_free ( void )
+{
+  return -1;
+}
+
+/* return:
+ * check if a audio / video pid has changed and
+ * if the status of the slot is scrambled or not.
+ * needed for ufs910 to modify the stream routing ad hoc. 
+ *
+ * -1 if nothing happens
+ * 0  not scrampbled but status changed
+ * 1  scrambled and status chaned
+ *
+ */
+int pti_hal_get_scrambled(void)
+{
+  int vLoopSessions, vLoopSlots;
+  int state;
+  static u16 lastAudioPid = -1;
+  static u16 lastVideoPid = -1;
+  static int lastAudioState = -1;
+  static int lastVideoState = -1;
+  int result = -1;
+  
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+         if (!vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse)
+	    continue;
+         
+	 if (vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_type != DMX_TYPE_TS)
+	    continue;
+	    
+	 if (vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_pes_type == DMX_TS_PES_VIDEO)
+	 {
+	     if (vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid == lastVideoPid)
+	        continue;
+		
+             lastVideoPid = vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid;
+	     
+	     state = pti_slot_get_state(vSessions[vLoopSessions]->vSlots[vLoopSlots]->TCIndex);
+	     
+	     if (state & (TC_MAIN_INFO_SLOT_STATE_SCRAMBLED | 
+	                  TC_MAIN_INFO_SLOT_STATE_TRANSPORT_SCRAMBLED))
+             {
+
+                 if (lastVideoState == 1)
+		    continue;
+		 
+		 lastVideoState = 1;
+		 return 1;	     
+	     } else
+             {
+                 if (lastVideoState == 0)
+		    continue;
+		 
+		 lastVideoState = 0;
+		 return 0;	     
+	     }
+	 } else
+	 if (vSessions[vLoopSessions]->vSlots[vLoopSlots]->dvb_pes_type == DMX_TS_PES_AUDIO)
+	 {
+	     if (vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid == lastAudioPid)
+	        continue;
+		
+             lastAudioPid = vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid;
+	     
+	     state = pti_slot_get_state(vSessions[vLoopSessions]->vSlots[vLoopSlots]->TCIndex);
+	     
+	     if (state & (TC_MAIN_INFO_SLOT_STATE_SCRAMBLED | 
+	                  TC_MAIN_INFO_SLOT_STATE_TRANSPORT_SCRAMBLED))
+             {
+                 if (lastAudioState == 1)
+		    continue;
+		 
+		 lastAudioState = 1;
+		 return 1;	     
+	     } else
+             {
+                 if (lastAudioState == 0)
+		    continue;
+		 
+		 lastAudioState = 0;
+		 return 0;	     
+	     }
+	 }
+      }				/* for slots */
+   }				/* for sessions */
+   return result;
+}
+
+void pti_hal_output_slot_state(void)
+{
+  int vLoopSessions, vLoopSlots;
+
+  dprintk ( "%s >\n", __func__ );
+
+  if ( vSessions == NULL )
+    return;
+
+#ifdef use_hal_mutex
+  mutex_lock ( &( HALLock ) );
+#endif
+
+  for ( vLoopSessions = 0; vLoopSessions < numberOfAvailableSessions;
+	vLoopSessions++ )
+  {
+      for ( vLoopSlots = 0; vLoopSlots < numberOfAvailableSlots;
+	    vLoopSlots++ )
+      {
+         if (!vSessions[vLoopSessions]->vSlots[vLoopSlots]->inUse)
+	    continue;
+          printk("session %d, slot %d, pid %d, state = %d\n", 
+	   vSessions[vLoopSessions]->Handle,
+	   vSessions[vLoopSessions]->vSlots[vLoopSlots]->Handle,
+	   vSessions[vLoopSessions]->vSlots[vLoopSlots]->pid,
+	   pti_slot_get_state(vSessions[vLoopSessions]->vSlots[vLoopSlots]->TCIndex)
+	   );
+      }				/* for slots */
+  }				/* for sessions */
+
+  dprintk ( "%s <\n", __func__ );
+
+#ifdef use_hal_mutex
+  mutex_unlock ( &( HALLock ) );
+#endif
+  return;
+}
+
+EXPORT_SYMBOL(pti_hal_descrambler_set);
+EXPORT_SYMBOL(pti_hal_descrambler_unlink);
+EXPORT_SYMBOL(pti_hal_descrambler_link);
+EXPORT_SYMBOL(pti_hal_get_new_descrambler);
+EXPORT_SYMBOL(pti_hal_slot_free);
+EXPORT_SYMBOL(pti_hal_slot_unlink_buffer);
+EXPORT_SYMBOL(pti_hal_slot_link_buffer);
+EXPORT_SYMBOL(pti_hal_slot_clear_pid);
+EXPORT_SYMBOL(pti_hal_slot_set_pid);
+EXPORT_SYMBOL(pti_hal_get_new_slot_handle);
+EXPORT_SYMBOL(pti_hal_set_source);
+EXPORT_SYMBOL(pti_hal_get_session_handle);
+EXPORT_SYMBOL(pti_hal_get_new_session_handle);
+EXPORT_SYMBOL(pti_hal_init);
diff --git a/tdt/cvs/driver/pti/pti_hal.h b/tdt/cvs/driver/pti/pti_hal.h
index 7943ae4..fbf547e 100644
--- a/tdt/cvs/driver/pti/pti_hal.h
+++ b/tdt/cvs/driver/pti/pti_hal.h
@@ -1,25 +1,56 @@
-#ifndef _PTI_HAL_H_
-#define _PTI_HAL_H_
-
-#include <linux/module.h>
-#include <linux/init.h>
-
-extern int pti_hal_descrambler_set(int session_handle, int descrambler_handle,u8 * Data, int parity);
-extern int pti_hal_descrambler_link(int session_handle, int descrambler_handle, int slot_handle);
-extern int pti_hal_get_new_slot_handle(int session_handle, int dvb_type,
-				  int dvb_pes_type, struct dvb_demux *demux,
-				  struct StreamContext_s *DemuxStream,
-				  struct DeviceContext_s *DeviceContext);
-extern int pti_hal_slot_link_buffer(int session_handle, int slot_handle,
-			       int bufType);
-extern int pti_hal_slot_free(int session_handle, int slot_handle);
-extern int pti_hal_slot_set_pid(int session_handle, int slot_handle, u16 pid);
-extern int pti_hal_slot_unlink_buffer(int session_handle, int slot_handle);
-extern int pti_hal_slot_clear_pid(int session_handle, int slot_handle);
-extern void pti_hal_init ( struct stpti *pti , struct dvb_demux* demux, void (*_demultiplex_dvb_packets)(struct dvb_demux* demux, const u8 *buf, int count),int num);
-extern int pti_hal_get_new_session_handle(int source, struct dvb_demux * demux);
-extern int pti_hal_get_new_descrambler(int session_handle);
-extern int pti_hal_set_source(int session_handle, const int source);
-extern void paceSwtsByPti(void);
-
-#endif //_PTI_HAL_H_
+#ifndef pti_hal_123
+#define pti_hal_123
+
+#include <dvb_demux.h>
+#include "pti.h"
+
+/* fixme: this one is still sucking */
+#include "../player2/linux/drivers/media/dvb/stm/dvb/dvb_module.h"
+
+#define cHALNoError		0
+#define cHALAlreadyInUse	-1
+#define cHALNotInitialized	-2
+#define cHALNoFreeSession	-3
+#define cHALNoFreeSlot		-5
+#define cHALSlotAlreadyInUse	-6
+#define cHALNoFreeBuffer	-7
+#define cHALNoFreeDescrambler	-8
+#define cHALNotPossible		-9
+
+int pti_hal_get_new_session_handle(tInputSource source,struct dvb_demux *demux);
+int pti_hal_set_source(int session_handle, const tInputSource source);
+int pti_hal_free_session(int session_handle);
+int pti_hal_get_new_slot_handle(int session_handle, int dvb_type, int dvb_pes_type, 
+				struct dvb_demux* demux, struct  StreamContext_s* DemuxStream,
+		  		struct DeviceContext_s* DeviceContext);
+int pti_hal_slot_set_pid(int session_handle, int slot_handle, u16 pid);
+int pti_hal_slot_clear_pid(int session_handle, int slot_handle);
+int pti_hal_slot_link_buffer(int session_handle, int slot_handle, BUFFER_TYPE bufType);
+int pti_hal_slot_unlink_buffer(int session_handle, int slot_handle);
+int pti_hal_slot_free(int session_handle, int slot_handle);
+
+int pti_hal_get_session_handle(int tc_session_number);
+int pti_hal_get_session_number_from_tc_slot_number(int tc_slot_number);
+int pti_hal_get_slot_handle(int session_handle, int tc_slot_number);
+int pti_hal_get_tc_dma_number(int session_handle, int slot_handle);
+struct dvb_demux* pti_hal_get_demux_from_slot(int session_handle, int slot_handle);
+struct dvb_demux * pti_hal_get_demux_from_dma_index ( int dmaIndex );
+
+int pti_hal_get_new_descrambler(int session_handle);
+int pti_hal_descrambler_link(int session_handle, int descrambler_handle, int slot_handle);
+int pti_hal_descrambler_unlink(int session_handle, int descrambler_handle);
+int pti_hal_descrambler_set(int session_handle, int descrambler_handle, u8* Data, int parity);
+
+//int pti_hal_buffer_enable(int session_handle, int buffer_handle);
+//int pti_hal_buffer_disable(int session_handle, int buffer_handle);
+
+int pti_hal_get_type_from_slot(int session_handle, int slot_handle, int* ts_type, int* pes_type);
+struct  StreamContext_s* pti_hal_get_stream_from_slot(int session_handle, int slot_handle);
+struct  DeviceContext_s* pti_hal_get_context_from_slot(int session_handle, int slot_handle);
+void pti_hal_get_slots_for_pid(int session_handle, u16 pid, int** slots, int* number_slots);
+#if defined (CONFIG_KERNELVERSION) /* STLinux 2.3 */
+void pti_hal_init ( struct stpti *pti , struct dvb_demux* demux, void (*_demultiplexDvbPackets)(struct dvb_demux* demux, const u8 *buf, int count), int numVideoBuffers);
+void paceSwtsByPti(void);
+int pti_hal_get_scrambled(void);
+#endif
+#endif
diff --git a/tdt/cvs/driver/pti/pti_main.c b/tdt/cvs/driver/pti/pti_main.c
index ca70d35..f017ca9 100644
--- a/tdt/cvs/driver/pti/pti_main.c
+++ b/tdt/cvs/driver/pti/pti_main.c
@@ -1,18 +1,3 @@
-
-/*
- * ST-PTI DVB driver
- *
- * Copyright (c) STMicroelectronics 2005
- *
- *   Author:Peter Bennett <peter.bennett@st.com>
- * __TDT__: mod by teamducktales
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License as
- *	published by the Free Software Foundation; either version 2 of
- *	the License, or (at your option) any later version.
- */
-#include <linux/version.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/wait.h>
@@ -21,1107 +6,691 @@
 #include <linux/delay.h>
 #include <linux/time.h>
 #include <linux/errno.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
-#include <asm/semaphore.h>
-#else
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
 #include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
 #endif
 #include <linux/platform_device.h>
 #include <linux/mutex.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/io.h>
 
+#if defined (CONFIG_KERNELVERSION) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
 #include <linux/bpa2.h>
-
-struct DeviceContext_s;
-struct StreamContext_s;
-
-#include "dvb_frontend.h"
-#include "dmxdev.h"
-#include "dvb_demux.h"
-#include "dvb_net.h"
-#include <linux/dvb/dmx.h>
-
-#include <linux/dvb/frontend.h>
-#include <linux/dvb/dmx.h>
-
-#include "pti.h"
-
-#if defined(PLAYER_179) || defined(PLAYER_191)
-#if (defined(HL101) || defined(VIP1_V2) || defined(VIP2_V1) || defined(SPARK) || defined(SPARK7162))
-static int waitMS=20;
-static int videoMem=4096;
-#endif
-#elif defined(PLAYER_131)
 #else
+#include <linux/bigphysarea.h>
 #endif
 
-int debug ;
-#define dprintk(x...) do { if (debug) printk(KERN_WARNING x); } while (0)
-
-#ifdef __TDT__
-unsigned int dma_0_buffer_base;
-unsigned int dma_0_buffer_top;
-unsigned int dma_0_buffer_rp;
-#define TAG_COUNT 4
-#define AUX_COUNT 20
-#else
-#define TAG_COUNT 3
-#define AUX_COUNT 20
-#endif
-
-struct tSlot
-{
-  int Handle;			/* Our Handle */
-  int inUse;
-  int tcIndex;
-  u16 pid;			/* Current set pid */
-};
-
-struct pti_internal {
-  struct  dvb_demux* demux[TAG_COUNT];
-  #if defined(SPARK7162)
-  int		demux_tag[TAG_COUNT];
-  #endif
-  int	  err_count;
-
-  wait_queue_head_t queue;
-
-  char *back_buffer;
-  unsigned int pti_io;
-
-  short int *pidtable;
-  short int *num_pids;
-  short int *pidsearch;
-  volatile unsigned short int *psize;
-  volatile unsigned short int *pread;
-  volatile unsigned short int *thrown_away;
-  volatile unsigned short int *packet_size;
-  volatile unsigned short int *header_size;
-  volatile unsigned short int *pwrite;
-  volatile unsigned short int *discard;
-
-  unsigned int loop_count;
-  unsigned int loop_count2;
-  unsigned int packet_count;
-
-  struct tSlot **vSlots;
-};
-
-
-static struct stpti *external = NULL;
-static struct pti_internal *internal = NULL;
-static void (*demultiplex_dvb_packets)(struct dvb_demux* demux, const u8 *buf, int count) = NULL;
-
-#ifdef __TDT__
-#define DMA_POLLING_INTERVAL (1)
-#else
-#define DMA_POLLING_INTERVAL msecs_to_jiffies(2)
-#endif
-#define HEADER_SIZE (6)
-#define PACKET_SIZE (188+HEADER_SIZE)
+#include "tc_code.h"
+#include "pti.h"
+#include <pti_public.h>
 
-#ifdef __TDT__
-#define PACKET_SIZE_WO_HEADER (188)
+#ifdef WITH_CAMROUTING
+int camRouting = 0;
 #endif
 
-#define PTI_BUFFER_SIZE (PACKET_SIZE * 4096) /*(188*1024)*/
-
-static struct timer_list ptiTimer;
+int debug = 0;
 
-#define SLOT_HANDLE_OFFSET		20000
-#define QUEUE_SIZE 400
+/* video memory in dvb packets */
+int videoMem = 2048;
 
-/* The work queue is a communication means between the process
-   polling the DMA and the process injecting the TS data into the
-   demultiplexer. It is assumed that the injector process is fast
-   enough to process the entries in the work queue. */
-static struct
-{
-  int offset;
-  int count;
-} workQueue[QUEUE_SIZE];
+/* waiting time in ms for wait queue in pti_prcoess.c */
+int waitMS = 20;
 
-static struct semaphore workSem;
-
-static int readIndex;
-static int writeIndex;
-
-/* PTI write ignores byte enables */
-static void PtiWrite(volatile unsigned short int *addr,unsigned short int value)
-{
-  unsigned int *addr2 = (unsigned int*)(((unsigned int)addr) & ~3);
-  unsigned int old_value  = *addr2;
-
-  if (((unsigned)addr & 2)) old_value = (old_value & 0x0000ffff) | value << 16;
-  else old_value = (old_value & 0xffff0000) | value;
+#ifdef CONFIG_PRINTK
+/* enable statistic output on pti */
+int enableStatistic = 0;
+#else
+int enableSysStatistic = 1;
 
-  *addr2 = old_value;
-}
+unsigned long pti_last_time = 0; 
+unsigned long pti_count = 0;
+#endif
 
-/***********************************************************************************/
+static void *stpti_MemoryAlign(void* Memory_p, u32 Alignment) 
+{ 
+    return (void *) ((u32)((u32)Memory_p+Alignment-1) & ~(Alignment-1) ); 
+} 
+ 
+ 
+static size_t stpti_BufferSizeAdjust( size_t Size ) 
+{ 
+    return( (size_t)stpti_MemoryAlign((void *)Size, STPTI_BUFFER_SIZE_MULTIPLE) ); 
+} 
+ 
+static void *stpti_BufferBaseAdjust( void *Base_p ) 
+{ 
+    return( stpti_MemoryAlign(Base_p, STPTI_BUFFER_ALIGN_MULTIPLE) ); 
+} 
+
+/* *****************************
+ * Global vars
+ */
+TCDevice_t* myTC = NULL;
+STPTI_TCParameters_t tc_params;
 
-#define TCASM_LM_SUPPORT
-#include "tc_code.h"
+#define STSYS_WriteRegDev32LE(a, b) writel(b,a)
+#define STSYS_ReadRegDev32LE(x) readl(x)
 
-static void loadtc(struct pti_internal *pti)
+static void stopTc(TCDevice_t *TC_Device)
 {
-  int n;
-
-  printk("%s: >\n",__FUNCTION__);
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->IIFFIFOEnable, 0x00 );/* Stop the IIF */
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->TCMode, 0x00 );       /* Stop the TC  */
 
-  for (n=0;n<=TCASM_LableMap[0].Value;n+=4)
-    writel(transport_controller_code[n/4], pti->pti_io + PTI_IRAM_BASE + n );
+    /* --- Perform a software reset --- */
 
-  for (n=0;n<(sizeof(transport_controller_data) * 2);n+=4)
-    writel(transport_controller_data[n/4], pti->pti_io + PTI_DRAM_BASE + n);
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->DMAPTI3Prog, 0x01 );  /* PTI3 Mode   */
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->DMAFlush, 0x01 );     /* Flush DMA 0 */
 
-  printk("%s: <\n",__FUNCTION__);
-}
-
-static void *getsymbol(struct pti_internal *pti, const char *symbol)
-{
-  char temp[128];
-  void *result = NULL;
-  int n;
+    /* For PTI4SL, if we do not enable the DMA here, the flush never occurs... */
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->DMAEnable, 0x01 );    /* Enable the DMA */
 
-  temp[120] = 0;
-  sprintf(temp,"::_%s",symbol);
+    while (STSYS_ReadRegDev32LE( (void*)&TC_Device->DMAFlush)&0X01)
 
-  for (n=0;n<TRANSPORT_CONTROLLER_LABLE_MAP_SIZE;n++)
-  	if (!strcmp(temp,TCASM_LableMap[n].Name))
-  	result = (void*)(pti->pti_io + TCASM_LableMap[n].Value);
+    udelay(100*64); /* 6400us */
 
-  return result;
-
-}
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->TCMode, 0x08 );       /* Full Reset the TC  */
 
-/***************************************************************************************/
+    udelay(200*64); /* 12800us */               /* Wait */
 
-static void stpti_setup_dma(struct pti_internal *pti)
-{
-  /* Setup DMA0 to transfer the data to the buffer */
-  writel( virt_to_phys(pti->back_buffer), pti->pti_io + PTI_DMA_0_BASE );
-  writel( virt_to_phys(pti->back_buffer), pti->pti_io + PTI_DMA_0_WRITE);
-  writel( virt_to_phys(pti->back_buffer), pti->pti_io + PTI_DMA_0_READ );
-  writel( virt_to_phys(pti->back_buffer + PTI_BUFFER_SIZE - 1), pti->pti_io + PTI_DMA_0_TOP );
-#ifdef __TDT__
-	dma_0_buffer_base = virt_to_phys(pti->back_buffer);
-	dma_0_buffer_top = virt_to_phys(pti->back_buffer) + PTI_BUFFER_SIZE;
-	dma_0_buffer_rp = dma_0_buffer_base;
-#endif
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->TCMode, 0x00 );       /* Finish Full Reset the TC  */
 
-  writel( 0x8, pti->pti_io + PTI_DMA_0_SETUP ); /* 8 word burst */
+    udelay(10*64); /* 640us */
 }
 
-static void stpti_start_dma(struct pti_internal *pti)
+/* ************************************
+ * From InitializeDevice in basic.c
+ * the TC is only for pti4 otherwise
+ * another loader should be used
+ */
+void pti_main_loadtc(struct stpti* pti)
 {
-  /* Enable the DMA */
-  writel( readl(pti->pti_io + PTI_DMA_ENABLE) | 0x1, pti->pti_io + PTI_DMA_ENABLE);
-
-  /* Tell PTI we have lots of room in buffer */
-  PtiWrite(pti->pread, 0);
-  PtiWrite(pti->pwrite,0);
-  PtiWrite(pti->discard, 0);
-
-  /* Reset all the counts */
-  pti->loop_count = 0;
-  pti->loop_count2 = 0;
-  pti->packet_count=0;
-}
+    STPTI_DevicePtr_t CodeStart;
+    TCDevice_t        *TC_Device;
+    u16               IIFSyncPeriod;
+    u16               TagBytes;
+    u32               PTI4_Base, i;
+    TCGlobalInfo_t    *TCGlobalInfo;
+    static u8         DmaFifoFlushingTarget[188 + DMAScratchAreaSize];
+    int               session;  /* Initialize session info structures */
+    u8                *base_p;
+    u8                *top_p;
+    size_t            DMABufferSize = 0;
+    int               block, index;
+    TCSectionFilterArrays_t *TC_SectionFilterArrays_p;
+    STPTI_TCParameters_t    *TC_Params_p;
+    TCInterruptDMAConfig_t  *TCInterruptDMAConfig_p;
+    
+    myTC = (TCDevice_t*) pti->pti_io;
+    CodeStart = &myTC->TC_Code[0];
+    
+    PTI4_Base = (u32)((u32)CodeStart - 0XC000); 
+    TC_Params_p = &tc_params;
+    
+    ioremap_nocache((unsigned long)&myTC, sizeof(TCDevice_t));
+
+// normally before start loading tc we should stop tc but in our
+// case I hope there isnt running later on we should do this
+// ->see stptiHelper_TCInit_Stop
+    //stopTc(myTC);
+
+    // *********************************
+    //Load TC
+    printk("Load real TC Code\n");
+    printk("TC_Data = %p, TC_Code = %p\n", myTC->TC_Data, myTC->TC_Code);
+
+    TC_Params_p->TC_CodeStart                  = (STPTI_DevicePtr_t)VERSION;
+    TC_Params_p->TC_CodeStart                  = CodeStart;
+    TC_Params_p->TC_CodeSize                   = TRANSPORT_CONTROLLER_CODE_SIZE * sizeof(u32);
+    TC_Params_p->TC_DataStart                  = (u32*)(((u32)PTI4_Base) + 0X8000);
+
+#if (defined(UFS912) || defined(ATEVIO7500)) && defined(SECURE_LITE2) && defined(A18)
+    TC_Params_p->TC_LookupTableStart           = (u32*)(((u32)PTI4_Base) + 0X8000);
+    TC_Params_p->TC_SystemKeyStart             = (u32*)(((u32)PTI4_Base) + 0X80C0);
+    TC_Params_p->TC_GlobalDataStart            = (u32*)(((u32)PTI4_Base) + 0X850C);
+    TC_Params_p->TC_StatusBlockStart           = (u32*)(((u32)PTI4_Base) + 0X8560);
+    TC_Params_p->TC_MainInfoStart              = (u32*)(((u32)PTI4_Base) + 0X8598);
+    TC_Params_p->TC_DMAConfigStart             = (u32*)(((u32)PTI4_Base) + 0X8E98);
+    TC_Params_p->TC_DescramblerKeysStart       = (u32*)(((u32)PTI4_Base) + 0X9578);
+    TC_Params_p->TC_TransportFilterStart       = (u32*)(((u32)PTI4_Base) + 0X9C1C);
+    TC_Params_p->TC_SCDFilterTableStart        = (u32*)(((u32)PTI4_Base) + 0X9C1C);
+    TC_Params_p->TC_PESFilterStart             = (u32*)(((u32)PTI4_Base) + 0X9CDC);
+    TC_Params_p->TC_SubstituteDataStart        = (u32*)(((u32)PTI4_Base) + 0X81C8);
+    TC_Params_p->TC_SFStatusStart              = (u32*)(((u32)PTI4_Base) + 0X9CDC);
+    TC_Params_p->TC_InterruptDMAConfigStart    = (u32*)(((u32)PTI4_Base) + 0XB0DC);
+    TC_Params_p->TC_SessionDataStart           = (u32*)(((u32)PTI4_Base) + 0XB0EC);
+    TC_Params_p->TC_EMMStart                   = (u32*)(((u32)PTI4_Base) + 0XB2A4);
+    TC_Params_p->TC_ECMStart                   = (u32*)(((u32)PTI4_Base) + 0XB2A4);
+    TC_Params_p->TC_VersionID                  = (u32*)(((u32)PTI4_Base) + 0XB2E4);
+
+    TC_Params_p->TC_NumberCarousels            = 0X0001;
+    TC_Params_p->TC_NumberSystemKeys           = 0X0001;
+    TC_Params_p->TC_NumberDMAs                 = 0X0037;
+    TC_Params_p->TC_NumberDescramblerKeys      = 0X0019;
+    TC_Params_p->TC_SizeOfDescramblerKeys      = 0X0044;
+    TC_Params_p->TC_NumberPesFilters           = 0X0000;
+    TC_Params_p->TC_NumberSectionFilters       = 0X0080;
+    TC_Params_p->TC_NumberSlots                = 0X0060;
+    TC_Params_p->TC_NumberOfSessions           = 0X0005;
+    TC_Params_p->TC_NumberIndexs               = 0X0060;
+    TC_Params_p->TC_NumberTransportFilters     = 0X0000;
+    TC_Params_p->TC_NumberSCDFilters           = 0X0018;
+
+    TC_Params_p->TC_SignalEveryTransportPacket = 0X0001;
+    TC_Params_p->TC_NumberEMMFilters           = 0X0000;
+    TC_Params_p->TC_SizeOfEMMFilter            = 0X001C;
+    TC_Params_p->TC_NumberECMFilters           = 0X0060;
+    TC_Params_p->TC_AutomaticSectionFiltering  = FALSE;
+    {
+        STPTI_DevicePtr_t DataStart = (u32*)(((u32)CodeStart&0xffff0000) | 0X8000);
 
-static void stpti_stop_dma(struct pti_internal *pti)
-{
-int loop_count = 0;
+        for(i = 0; i < (0X3800/4); ++i)
+        {
+            writel(0x00 , (u32)&DataStart[i]);
+        }
 
-  /* Stop DMAing data */
-  PtiWrite(pti->pread, 0);
+        for(i = 0; i < 0X1000; ++i)
+        {
+            writel(0x00 , (u32)&CodeStart[i]);
+        }
 
-  while (*pti->pwrite != *pti->psize +2)
-  {
-    PtiWrite(pti->pwrite, *pti->psize + 2);
-    PtiWrite(pti->pwrite, *pti->psize + 2);
-    dprintk("%s: Pwrite = %u Psize = %u\n",__FUNCTION__,*pti->pwrite,*pti->psize);
-  };
+        for(i = 0; i < TRANSPORT_CONTROLLER_CODE_SIZE; ++i)
+        {
+            writel(transport_controller_code[i], (u32)&CodeStart[i] );
+        }
 
-  udelay(100);
+        writel( 0X5354 | (0X5054<<16), (u32)&(TC_Params_p->TC_VersionID[0]));
+        writel( 0X4934 | (0X001F<<16), (u32)&(TC_Params_p->TC_VersionID[1]));
+        writel( 0X0803 | (0X0000<<16), (u32)&(TC_Params_p->TC_VersionID[2]));
+
+	printk("Readback TC ... ");
+        for(i = 0; i < TRANSPORT_CONTROLLER_CODE_SIZE; ++i)
+        {
+            unsigned long res = readl((u32)&CodeStart[i] );
+            if (res != transport_controller_code[i])
+            {
+            	printk("failed !!!!\n");	
+            	break;
+            }
+        }
+        if (i == TRANSPORT_CONTROLLER_CODE_SIZE)
+        {
+        	printk("successfull\n");	
+        }
+    }
+#elif defined(A18)
+    TC_Params_p->TC_LookupTableStart           = (u32*)(((u32)PTI4_Base) + 0X8000);
+    TC_Params_p->TC_SystemKeyStart             = (u32*)(((u32)PTI4_Base) + 0X80C0);
+    TC_Params_p->TC_GlobalDataStart            = (u32*)(((u32)PTI4_Base) + 0X8270);
+    TC_Params_p->TC_StatusBlockStart           = (u32*)(((u32)PTI4_Base) + 0X82B8);
+    TC_Params_p->TC_MainInfoStart              = (u32*)(((u32)PTI4_Base) + 0X82E0);
+    TC_Params_p->TC_DMAConfigStart             = (u32*)(((u32)PTI4_Base) + 0X8A60);
+    TC_Params_p->TC_DescramblerKeysStart       = (u32*)(((u32)PTI4_Base) + 0X902C);
+    TC_Params_p->TC_TransportFilterStart       = (u32*)(((u32)PTI4_Base) + 0X9194);
+    TC_Params_p->TC_SCDFilterTableStart        = (u32*)(((u32)PTI4_Base) + 0X9194);
+    TC_Params_p->TC_PESFilterStart             = (u32*)(((u32)PTI4_Base) + 0X9194);
+    TC_Params_p->TC_SubstituteDataStart        = (u32*)(((u32)PTI4_Base) + 0X81A8);
+    TC_Params_p->TC_SFStatusStart              = (u32*)(((u32)PTI4_Base) + 0X9194);
+    TC_Params_p->TC_InterruptDMAConfigStart    = (u32*)(((u32)PTI4_Base) + 0X9894);
+    TC_Params_p->TC_SessionDataStart           = (u32*)(((u32)PTI4_Base) + 0X98A4);
+    TC_Params_p->TC_EMMStart                   = (u32*)(((u32)PTI4_Base) + 0X9970);
+    TC_Params_p->TC_ECMStart                   = (u32*)(((u32)PTI4_Base) + 0X9970);
+    TC_Params_p->TC_VersionID                  = (u32*)(((u32)PTI4_Base) + 0X9970);
+
+    TC_Params_p->TC_NumberCarousels            = 0X0001;
+    TC_Params_p->TC_NumberSystemKeys           = 0X0000;
+    TC_Params_p->TC_NumberDMAs                 = 0X0035;
+    TC_Params_p->TC_NumberDescramblerKeys      = 0X0012;
+    TC_Params_p->TC_SizeOfDescramblerKeys      = 0X0014;
+    TC_Params_p->TC_NumberPesFilters           = 0X0000;
+    TC_Params_p->TC_NumberSectionFilters       = 0X0040;
+    TC_Params_p->TC_NumberSlots                = 0X0060;
+    TC_Params_p->TC_NumberOfSessions           = 0X0003;
+    TC_Params_p->TC_NumberIndexs               = 0X0060;
+    TC_Params_p->TC_NumberTransportFilters     = 0X0000;
+    TC_Params_p->TC_NumberSCDFilters           = 0X0000;
+
+    TC_Params_p->TC_SignalEveryTransportPacket = 0X0001;
+    TC_Params_p->TC_NumberEMMFilters           = 0X0000;
+    TC_Params_p->TC_SizeOfEMMFilter            = 0X001C;
+    TC_Params_p->TC_NumberECMFilters           = 0X0060;
+    TC_Params_p->TC_AutomaticSectionFiltering  = FALSE;
+    {
+        STPTI_DevicePtr_t DataStart = (u32*)(((u32)CodeStart&0xffff0000) | 0X8000);
 
-  /* Ensure DMA is enabled */
-  writel( readl(pti->pti_io + PTI_DMA_ENABLE) | 0x1, pti->pti_io + PTI_DMA_ENABLE );
+        for(i = 0; i < (0X1A00/4); ++i)
+        {
+            writel(0x00 , (u32)&DataStart[i]);
+        }
 
-  /* Do DMA Done to ensure all data has been transfered */
-  writel( PTI_DMA_DONE , pti->pti_io + PTI_DMA_0_STATUS );
+        for(i = 0; i < 0X0780; ++i)
+        {
+            writel(0x00 , (u32)&CodeStart[i]);
+        }
 
-  while( (readl(pti->pti_io + PTI_DMA_0_STATUS) & PTI_DMA_DONE) &&
-	 (loop_count<100))
-    { udelay(1000); loop_count++; };
+        for(i = 0; i < TRANSPORT_CONTROLLER_CODE_SIZE; ++i)
+        {
+            writel(transport_controller_code[i], (u32)&CodeStart[i] );
+        }
 
-  /* Disable the DMA */
-  writel(readl(pti->pti_io + PTI_DMA_ENABLE) & ~0x1, pti->pti_io + PTI_DMA_ENABLE);
-}
+        writel( 0X5354 | (0X5054<<16), (u32)&(TC_Params_p->TC_VersionID[0]));
+        writel( 0X4934 | (0X0000<<16), (u32)&(TC_Params_p->TC_VersionID[1]));
+        writel( 0X0803 | (0X0000<<16), (u32)&(TC_Params_p->TC_VersionID[2]));
+
+	printk("Readback TC ... ");
+        for(i = 0; i < TRANSPORT_CONTROLLER_CODE_SIZE; ++i)
+        {
+            unsigned long res = readl((u32)&CodeStart[i] );
+            if (res != transport_controller_code[i])
+            {
+            	printk("failed !!!!\n");	
+            	break;
+            }
+        }
+        if (i == TRANSPORT_CONTROLLER_CODE_SIZE)
+        {
+        	printk("successfull\n");	
+        }
+    }
+#else
+    TC_Params_p->TC_LookupTableStart           = (u32*)(((u32)PTI4_Base) + 0X8000);
+    TC_Params_p->TC_SystemKeyStart             = (u32*)(((u32)PTI4_Base) + 0X80C0);
+    TC_Params_p->TC_GlobalDataStart            = (u32*)(((u32)PTI4_Base) + 0X826C);
+    TC_Params_p->TC_StatusBlockStart           = (u32*)(((u32)PTI4_Base) + 0X82B4);
+    TC_Params_p->TC_MainInfoStart              = (u32*)(((u32)PTI4_Base) + 0X82D8);
+    TC_Params_p->TC_DMAConfigStart             = (u32*)(((u32)PTI4_Base) + 0X8A58);
+    TC_Params_p->TC_DescramblerKeysStart       = (u32*)(((u32)PTI4_Base) + 0X905C);
+    TC_Params_p->TC_TransportFilterStart       = (u32*)(((u32)PTI4_Base) + 0X91C4);
+    TC_Params_p->TC_SCDFilterTableStart        = (u32*)(((u32)PTI4_Base) + 0X91C4);
+    TC_Params_p->TC_PESFilterStart             = (u32*)(((u32)PTI4_Base) + 0X91C4);
+    TC_Params_p->TC_SubstituteDataStart        = (u32*)(((u32)PTI4_Base) + 0X81A8);
+    TC_Params_p->TC_SFStatusStart              = (u32*)(((u32)PTI4_Base) + 0X91C4);
+    TC_Params_p->TC_InterruptDMAConfigStart    = (u32*)(((u32)PTI4_Base) + 0X98C4);
+    TC_Params_p->TC_SessionDataStart           = (u32*)(((u32)PTI4_Base) + 0X98D4);
+    TC_Params_p->TC_EMMStart                   = (u32*)(((u32)PTI4_Base) + 0X9994);
+    TC_Params_p->TC_ECMStart                   = (u32*)(((u32)PTI4_Base) + 0X9994);
+    TC_Params_p->TC_VersionID                  = (u32*)(((u32)PTI4_Base) + 0X99B4);
+
+    TC_Params_p->TC_NumberCarousels            = 0X0001;
+    TC_Params_p->TC_NumberSystemKeys           = 0X0000;
+    TC_Params_p->TC_NumberDMAs                 = 0X0037;
+    TC_Params_p->TC_NumberDescramblerKeys      = 0X0012;
+    TC_Params_p->TC_SizeOfDescramblerKeys      = 0X0014;
+    TC_Params_p->TC_NumberPesFilters           = 0X0000;
+    TC_Params_p->TC_NumberSectionFilters       = 0X0040;
+    TC_Params_p->TC_NumberSlots                = 0X0060;
+    TC_Params_p->TC_NumberOfSessions           = 0X0003;
+    TC_Params_p->TC_NumberIndexs               = 0X0060;
+    TC_Params_p->TC_NumberTransportFilters     = 0X0000;
+    TC_Params_p->TC_NumberSCDFilters           = 0X0000;
+
+    TC_Params_p->TC_SignalEveryTransportPacket = 0X0001;
+    TC_Params_p->TC_NumberEMMFilters           = 0X0000;
+    TC_Params_p->TC_NumberECMFilters           = 0X0060;
+    TC_Params_p->TC_AutomaticSectionFiltering  = FALSE;
+    {
+        STPTI_DevicePtr_t DataStart = (u32*)(((u32)CodeStart&0xffff0000) | 0X8000);
 
-static void stpti_reset_dma(struct pti_internal *pti)
-{
-  /* Stop the DMA */
-  stpti_stop_dma(pti);
+        for(i = 0; i < (0X1A00/4); ++i)
+        {
+            writel(0x00 , (u32)&DataStart[i]);
+        }
 
-  /* Reset dma pointers */
-  stpti_setup_dma(pti);
-}
+        for(i = 0; i < 0X0900; ++i)
+        {
+            writel(0x00 , (u32)&CodeStart[i]);
+        }
 
+        for(i = 0; i < TRANSPORT_CONTROLLER_CODE_SIZE; ++i)
+        {
+            writel(transport_controller_code[i], (u32)&CodeStart[i] );
+        }
 
-/*
-
-0x10   ----------------- <--- PTI_DMA_x_BASE
-       |               |   |
-       |               |  \|/
-       |               | <--- PTI_DMA_x_READ  (Last address sent to ADSC)
-       |               |
-       |               |
-       |               | <--- PTI_DMA_x_WRITE (Last address written by PTI)
-       |               |   ^
-       |               |   |  (free space)
-       |               |   |
-0x1000 ----------------- <--- PTI_DMA_x_TOP
-
-0x10   ----------------- <--- PTI_DMA_x_BASE
-       |               |
-       |               |
-       |               | <--- PTI_DMA_x_WRITE (Last address written by PTI)
-       |               |   |
-       |               |   | (free space)
-       |               | <--- PTI_DMA_x_READ  (Last address sent to ADSC)
-       |               |
-       |               |
-       |               |
-0x1000 ----------------- <--- PTI_DMA_x_TOP
-
-*/
-
-static int stream_injector(void *user_data)
-{
-  int offset, count;
-  int overflow = 0;
-
-//aktivate STREAMCHECK for debug
-//#define STREAMCHECK
-#ifdef STREAMCHECK
-	u8 vpidhigh=0; //high byte of the video stream to check
-	u8 vpidlow=0x65; //low byte of the video stream to check
-	u8 apidhigh=0; //high byte of the audio stream to check
-	u8 apidlow=0x66; //low byte of the audio stream to check
-	int vc=99; //video count
-	int ac=99; //audio count
-	u8 tc; //temp count
-	unsigned long prv=30000; //print video output after xxxx counts
-	unsigned long pra=30000; //print audio autput after xxxx counts
+        writel( 0X5354 | (0X5054<<16), (u32)&(TC_Params_p->TC_VersionID[0]));
+        writel( 0X4934 | (0X0000<<16), (u32)&(TC_Params_p->TC_VersionID[1]));
+        writel( 0X84D0 | (0X0000<<16), (u32)&(TC_Params_p->TC_VersionID[2]));
+
+	printk("Readback TC ... ");
+        for(i = 0; i < TRANSPORT_CONTROLLER_CODE_SIZE; ++i)
+        {
+            unsigned long res = readl((u32)&CodeStart[i] );
+            if (res != transport_controller_code[i])
+            {
+            	printk("failed !!!!\n");	
+            	break;
+            }
+        }
+        if (i == TRANSPORT_CONTROLLER_CODE_SIZE)
+        {
+        	printk("successfull\n");	
+        }
+    }
 #endif
+    
+    //stopTc(myTC);
+
+    //Load TC
+    // *********************************
+
+    // *********************************
+    //Init Hardware (stptiHelper_TCInit_Hardware)
+    
+    TC_Device     = myTC;
+    IIFSyncPeriod =  188 /* DVB_TS_PACKET_LENGTH*/;    /* default is 188 for DVB */
+    TagBytes = 0;        /* default is TSMERGER in bypass mode (or no TSMERGER) */
+
+    /* --- Initialize TC registers --- */
+
+    writel( 0 ,(void*)&TC_Device->TCMode);
+    writel( 0xffff, (void*)&TC_Device->PTIIntAck0 );
+    writel( 0xffff, (void*)&TC_Device->PTIIntAck1 );
+    writel( 0xffff, (void*)&TC_Device->PTIIntAck2 );
+    writel( 0xffff, (void*)&TC_Device->PTIIntAck3 );
+
+    /* disable all interrupts */
+
+    writel( 0 , (void*)&TC_Device->PTIIntEnable0 );
+    writel( 0 , (void*)&TC_Device->PTIIntEnable1);
+    writel( 0 , (void*)&TC_Device->PTIIntEnable2);
+    writel( 0 , (void*)&TC_Device->PTIIntEnable3 );
+
+    /* Initialise various registers */
+
+    writel( 0 , (void*)&TC_Device->STCTimer0 );
+    writel( 0 , (void*)&TC_Device->STCTimer1);
+
+    /* Initialise DMA Registers */
+
+    writel( 0 , (void*)&TC_Device->DMAEnable);             /* Disable DMAs */
+    writel( 1 , (void*)&TC_Device->DMAPTI3Prog);           /* PTI3 Mode */
+
+    writel( 0 , (void*)&TC_Device->DMA0Base );
+    writel( 0 , (void*)&TC_Device->DMA0Top);
+    writel( 0 , (void*)&TC_Device->DMA0Write);
+    writel( 0 , (void*)&TC_Device->DMA0Read);
+    writel( 0 , (void*)&TC_Device->DMA0Setup);
+    writel( (1 | (1 << 16)), (void*)&TC_Device->DMA0Holdoff );
+    writel( 0 , (void*)&TC_Device->DMA0Status);
+
+    writel( 0 , (void*)&TC_Device->DMA1Base);
+    writel( 0 , (void*)&TC_Device->DMA1Top);
+    writel( 0 , (void*)&TC_Device->DMA1Write);
+    writel( 0 , (void*)&TC_Device->DMA1Read);
+    writel( 0 , (void*)&TC_Device->DMA1Setup);
+    writel( (1 | (1 << 16)) , (void*)&TC_Device->DMA1Holdoff);
+    writel( 0 , (void*)&TC_Device->DMA1CDAddr);
+    writel( 0 , (void*)&TC_Device->DMASecStart);
+
+    writel( 0 , (void*)&TC_Device->DMA2Base);
+    writel( 0 , (void*)&TC_Device->DMA2Top);
+    writel( 0 , (void*)&TC_Device->DMA2Write);
+    writel( 0 , (void*)&TC_Device->DMA2Read);
+    writel( 0 , (void*)&TC_Device->DMA2Setup);
+    writel( (1 | (1 << 16)), (void*)&TC_Device->DMA2Holdoff );
+    writel( 0 , (void*)&TC_Device->DMA2CDAddr);
+    writel( 0 , (void*)&TC_Device->DMAFlush);
+
+    writel( 0 , (void*)&TC_Device->DMA3Base);
+    writel( 0 , (void*)&TC_Device->DMA3Top);
+    writel( 0 , (void*)&TC_Device->DMA3Write);
+    writel( 0 , (void*)&TC_Device->DMA3Read);
+    writel( 0 , (void*)&TC_Device->DMA3Setup);
+    writel( (1 | (1 << 16)), (void*)&TC_Device->DMA3Holdoff );
+    writel( 0 , (void*)&TC_Device->DMA3CDAddr);
+
+    writel( 0xf , (void*)&TC_Device->DMAEnable );             /* Enable DMAs */
+
+    /* Initialise IIF Registers */
+
+    writel( 0 , (void*)&TC_Device->IIFFIFOEnable );
+
+    writel( 1/*Device_p->AlternateOutputLatency*/ , (void*)&TC_Device->IIFAltLatency);
+    writel( 0/*Device_p->SyncLock*/, (void*)&TC_Device->IIFSyncLock );
+    writel( 0/*Device_p->SyncDrop*/, (void*)&TC_Device->IIFSyncDrop );
+
+    writel( IIF_SYNC_CONFIG_USE_SOP , (void*)&TC_Device->IIFSyncConfig);
+    TagBytes = 6;
+
+    writel( IIFSyncPeriod + TagBytes , (void*)&TC_Device->IIFSyncPeriod);
+    writel( 1 , (void*)&TC_Device->IIFCAMode);
+    
+    //Init Hardware
+    // *********************************
+
+    // *********************************************************
+    //Init PidSearchEngine (stptiHelper_TCInit_PidSearchEngine)
+
+    for (i = 0; i < TC_Params_p->TC_NumberSlots; i++)
+    {
+        volatile u16 *Addr_p = (volatile u16 *) TC_Params_p->TC_LookupTableStart;
+        PutTCData(&Addr_p[i], TC_INVALID_PID);
+    }
+    
+    //Init PidSearchEngine (stptiHelper_TCInit_PidSearchEngine)
+    // *********************************************************
 
-  daemonize ("ts-injector");
+    // *****************************************
+    //Init GlobalInfo (stptiHelper_TCInit_GlobalInfo)
+    TCGlobalInfo = (TCGlobalInfo_t *)TC_Params_p->TC_GlobalDataStart;
 
-  allow_signal(SIGKILL);
-  allow_signal(SIGTERM);
+    /* Set the scratch area so TC can dump DMA0 data (in cdfifo-ish mode). Be paranoid
+     and set the buffer to a DVB packet plus alignment/guard bytes */
+    writel( (((u32)(DmaFifoFlushingTarget))+15)&(~0x0f) , (void*)&TCGlobalInfo->GlobalScratch);
+    STSYS_WriteTCReg16LE( (void*)&TCGlobalInfo->GlobalSFTimeout, 1429 );            /* default is 1429 iterations * 7 tc cycles = 10003 tc cycles */
 
-#ifdef __TDT__
-  //set high thread priority
-  set_user_nice(current, -20);
-#endif
+    //Init GlobalInfo (stptiHelper_TCInit_GlobalInfo)
+    // *****************************************
 
-  while(1)
-  {
-	/* the polling process increments the semaphore whenever it writes
-           an entry into the queue */
-	if(down_interruptible(&workSem))
-	  break;
-
-	if(writeIndex == readIndex)
-	{
-		if(!overflow)
-		{
-			printk("PTI: queue overflow\n");
-			overflow = 1;
-		}
-		/* discard the buffer because the injector is too slow */
-		continue;
-	}
-	overflow = 0;
-
-	/* copy the start offset and the packet count to local variables */
-	offset = workQueue[readIndex].offset;
-	count = workQueue[readIndex].count;
-
-	//printk(".");
-
-	/* invalidate the cache */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
-	dma_cache_inv((void*)&internal->back_buffer[offset],
-			count * PACKET_SIZE);
-#else
-	invalidate_ioremap_region(0, internal->back_buffer,
-			offset, count * PACKET_SIZE);
-#endif
+    // ******************************************
+    //Init MainInfo (stptiHelper_TCInit_MainInfo)
+    for (i = 0; i < TC_Params_p->TC_NumberSlots; i++)
+    {
+        TCMainInfo_t *MainInfo = &((TCMainInfo_t *) TC_Params_p->TC_MainInfoStart)[i];
+        STSYS_WriteTCReg16LE((void*)&MainInfo->SlotState, 0);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->SlotMode, 0);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->DescramblerKeys_p, TC_INVALID_LINK);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->DMACtrl_indices,    0xFFFF);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->StartCodeIndexing_p, 0);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->SectionPesFilter_p, TC_INVALID_LINK);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->RemainingPESLength, 0);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->PacketCount, 0);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->SlotState, 0);
+        STSYS_WriteTCReg16LE((void*)&MainInfo->SlotMode, 0);
 
-#ifdef STREAMCHECK
-	/* The first bytes of the packet after the header should
-	   always be a 0x47 if not we got problems */
-	if (internal->back_buffer[offset + HEADER_SIZE] != 0x47)
-		printk("\n!0x47\n");
-#endif
+    }
 
-	/* Now go through each packet, check it's tag and
-           place it in the correct demux buffer */
-	if(demultiplex_dvb_packets != NULL)
-	{
-	  u8 *pFrom = &internal->back_buffer[offset];
-#ifdef __TDT__
-	  static u8 auxbuf[TAG_COUNT][PACKET_SIZE_WO_HEADER * AUX_COUNT];
-	  u8 *pTo[TAG_COUNT] = {auxbuf[0],auxbuf[1],auxbuf[2],auxbuf[3]};
-	  int count1[TAG_COUNT] = {0, 0, 0, 0};
-#else
-		static u8 auxbuf[TAG_COUNT][(PACKET_SIZE - HEADER_SIZE) * AUX_COUNT];
-		u8 *pTo[TAG_COUNT] = {auxbuf[0],auxbuf[1],auxbuf[2]};
-	  int count1[TAG_COUNT] = {0, 0, 0};
-#endif
-	  int n;
-
-	  /* sort the packets according to the tag,
-	     remove the TS merger tags and squeeze the
-	     packets to improve the performance */
-	  for (n = 0; n < count; n++)
-	  {
-	    /* Only the tag IDs of TS inputs are taken into account.
-	       The lower two bits of the tag ID are as follows:
-	       00 - TS0
-	       01 - TS1
-	       10 - TS2
-				 11 - SWTS0 */
-	    int tag = (pFrom[0] >> 2) & 0xf;
-	    /* only copy if the demux exists */
-	#if defined(SPARK7162)
-	    if((tag < TAG_COUNT) &&
-	       (internal->demux[internal->demux_tag[tag]] != NULL))
-	#else
-	    if((tag < TAG_COUNT) &&
-	       (internal->demux[tag] != NULL))
-	#endif
-	    {
-
-#ifdef STREAMCHECK
-				//check for startbyte of all paket
-				if (pFrom[6] != 0x47)
-					printk("[STREAMCHECK] first byte of packet not 0x47\n");
-
-				//check count of the choised videostream
-				if((pFrom[7]&0x1f)==vpidhigh && pFrom[8]==vpidlow) {
-					prv++;
-					if(prv>20000) {
-						printk("[STREAMCHECK] 20000 video PIDs found 0x%x%x\n",(pFrom[7]&0x1f),pFrom[8]);
-  					prv=0;
-					}
-					tc=pFrom[9];
-					tc=(tc<<4);
-					tc=(tc>>4);
-					if(vc==99)
-						vc=tc;
-					else {
-						vc++;
-						if(vc>15) vc=0;
-						if(vc!=tc) {
-							printk("[STREAMCHECK] invalide video count - count=%d, packetcount=%d, pid=0x%x%x\n",vc,tc,(pFrom[7]&0x1f),pFrom[8]);
-							vc=tc;
-						}
-					}
-				}
-
-				//check count of the choised audiostream
-				if((pFrom[7]&0x1f)==apidhigh && pFrom[8]==apidlow) {
-					pra++;
-					if(pra>20000) {
-						printk("[STREAMCHECK] 20000 audio PID found 0x%x%x\n",(pFrom[7]&0x1f),pFrom[8]);
-						pra=0;
-					}
-					tc=pFrom[9];
-					tc=(tc<<4);
-					tc=(tc>>4);
-					if(ac==99)
-  					ac=tc;
-					else {
-						ac++;
-						if(ac>15) ac=0;
-						if(ac!=tc) {
-							printk("[STREAMCHECK] invalide audio count - count=%d, packetcount=%d, pid=0x%x%x\n",ac,tc,(pFrom[7]&0x1f),pFrom[8]);
-							ac=tc;
-						}
-					}
-				}
-#endif
-#ifdef __TDT__
-	      memmove(pTo[tag], pFrom + HEADER_SIZE, PACKET_SIZE_WO_HEADER);
-	      pTo[tag] += PACKET_SIZE_WO_HEADER;
-#else
-				memmove(pTo[tag], pFrom + HEADER_SIZE,
-		      PACKET_SIZE - HEADER_SIZE);
-	      pTo[tag] += PACKET_SIZE - HEADER_SIZE;
-#endif
-	      count1[tag]++;
-	      if(count1[tag] >= AUX_COUNT)
-	      {
-		//printk("%d", tag);
-		/* inject the packets */
-	#if defined(SPARK7162)
-			demultiplex_dvb_packets(internal->demux[internal->demux_tag[tag]],
-						auxbuf[tag], count1[tag]);
-	#else
-			demultiplex_dvb_packets(internal->demux[tag],
-						auxbuf[tag], count1[tag]);
-	#endif
-		pTo[tag] = auxbuf[tag];
-		count1[tag] = 0;
-	      }
-	    }
-	    pFrom += PACKET_SIZE;
-	  }
-	  for(n = 0; n < TAG_COUNT; n++)
-	  {
-	    /* inject remainders if any */
-	#if defined(SPARK7162)
-	    if((count1[n] > 0) && (internal->demux[internal->demux_tag[n]] != NULL))
-	      demultiplex_dvb_packets(internal->demux[internal->demux_tag[n]], auxbuf[n], count1[n]);
-	#else
-	    if((count1[n] > 0) && (internal->demux[n] != NULL))
-	      demultiplex_dvb_packets(internal->demux[n], auxbuf[n], count1[n]);
-	#endif
-	  }
-	}
-
-	/* increment the readIndex */
-	readIndex = (readIndex + 1) % QUEUE_SIZE;
-  }
-
-  return 0;
-}
+    //Init MainInfo (stptiHelper_TCInit_MainInfo)
+    // ******************************************
 
-/* This function is called periodically to poll the TC DMA structures.
-   The original version used interrupts which caused high CPU load.
-   In order to have a higher priority than the injector thread this function
-   is called by a timer as opposed to execution in a thread.
-   The published TC DMA code is not robust enough when the buffer contains
-   lots of packets (presumably > 500) even if the buffer is not full.
-   Therefore, it is important that the polling process always does its work
-   on time. */
-#ifdef __TDT__
-static void process_pti_dma(unsigned long data)
-{
-  unsigned int pti_wp, num_packets, pti_status;
-  bool buffer_round=0;
-
-	/* Load the write pointers, so we know where we are in the buffers */
-	pti_wp = readl(internal->pti_io + PTI_DMA_0_WRITE);
-
-	//align dma write pointer to packet size
-	pti_wp = pti_wp - ((pti_wp - dma_0_buffer_base) % PACKET_SIZE);
-
-	/* Read status registers */
-	pti_status = readl(internal->pti_io + PTI_IIF_FIFO_COUNT);
-
-	/* Error if we overflow */
-	if (pti_status & PTI_IIF_FIFO_FULL)
-	{
-		internal->err_count++;
-		printk(KERN_WARNING "%s: IIF Overflow\n",__FUNCTION__);
-	}
-
-	/* If the PTI had to drop packets because we couldn't process in time error */
-	if (*internal->discard)
-	{
-		printk(KERN_WARNING "%s: PTI had to discard %u packets %u %u\n",__func__,
-			*internal->discard,*internal->pread,*internal->pwrite);
-
-		internal->err_count++;
-		stpti_reset_dma(internal);
-		//writeIndex = 0;
-		//readIndex = 0;
-		//the semaphore must by also resetet to 0, fix later
-		stpti_start_dma(internal);
-	} else
-	{
-		/* If we get to the bottom of the buffer wrap the pointer back to the top */
-		if ((dma_0_buffer_rp & ~0xf) == (dma_0_buffer_top & ~0xf)) dma_0_buffer_rp = dma_0_buffer_base;
-
-		/* Calculate the amount of bytes used in the buffer */
-		if (dma_0_buffer_rp <= pti_wp) num_packets = (pti_wp - dma_0_buffer_rp) / PACKET_SIZE;
-		else
-		{
-			num_packets = ((dma_0_buffer_top - dma_0_buffer_rp) + (pti_wp - dma_0_buffer_base)) / PACKET_SIZE;
-			internal->loop_count2++;
-			internal->packet_count = 0;
-			buffer_round=1;
-		}
-
-		/* If we have some packets */
-		if (num_packets)
-		{
-			/* And the PTI has acknowledged the updated the packets */
-			if (!*internal->pread)
-			{
-				/* Increment the loop counter */
-				internal->loop_count++;
-
-				/* Increment the packet_count, by the number of packets we have processed */
-				internal->packet_count+=num_packets;
-
-				/* Now update the read pointer in the DMA engine */
-				writel(pti_wp, internal->pti_io + PTI_DMA_0_READ );
-
-				/* Now tell the firmware how many packets we have read */
-				PtiWrite(internal->pread, num_packets);
-
-				/* notify the injector thread */
-				if(buffer_round) {
-					unsigned int num_packets1 = (dma_0_buffer_top - dma_0_buffer_rp) / PACKET_SIZE;
-					workQueue[writeIndex].offset = dma_0_buffer_rp - dma_0_buffer_base;
-					workQueue[writeIndex].count = num_packets1;
-					writeIndex = (writeIndex + 1) % QUEUE_SIZE;
-					up(&workSem);
-
-					workQueue[writeIndex].offset = 0;
-					workQueue[writeIndex].count = num_packets-num_packets1;
-					writeIndex = (writeIndex + 1) % QUEUE_SIZE;
-					up(&workSem);
-				}
-				else {
-					workQueue[writeIndex].offset = dma_0_buffer_rp - dma_0_buffer_base;
-					workQueue[writeIndex].count = num_packets;
-					writeIndex = (writeIndex + 1) % QUEUE_SIZE;
-					up(&workSem);
-				}
-				dma_0_buffer_rp = pti_wp;
-			} // not read
-		} // num_packet
-	} // discard
-
-	/* reschedule the timer */
-	ptiTimer.expires = jiffies + DMA_POLLING_INTERVAL;
-	add_timer(&ptiTimer);
-}
+    // ******************************************
+    //Init SessionInfo (stptiHelper_TCInit_SessionInfo)	
 
-#else
+    for (session = 0; session < TC_Params_p->TC_NumberOfSessions; session++)
+    {
+        TCSessionInfo_t *SessionInfo_p = &((TCSessionInfo_t *) TC_Params_p->TC_SessionDataStart)[session];
 
-static void process_pti_dma(unsigned long data)
-{
-    unsigned int pti_rp, pti_wp, pti_base, pti_top, size_first, num_packets,
-		new_rp, pti_status, dma_status;
-    static unsigned int pti_status_old=0;
-    static unsigned int dma_status_old=0;
-
-	  /* Load the read and write pointers, so we know where we are in the buffers */
-	  pti_rp   = readl(internal->pti_io + PTI_DMA_0_READ);
-	  pti_wp   = readl(internal->pti_io + PTI_DMA_0_WRITE);
-	  pti_base = readl(internal->pti_io + PTI_DMA_0_BASE);
-	  pti_top  = pti_base + PTI_BUFFER_SIZE;
-
-	  /* Read status registers */
-	  pti_status = readl(internal->pti_io + PTI_IIF_FIFO_COUNT);
-	  dma_status = readl(internal->pti_io + PTI_DMA_0_STATUS);
-
-	  /* Error if we overflow */
-	  if (pti_status & PTI_IIF_FIFO_FULL)
-	  {
-	     internal->err_count++;
-	     printk(KERN_WARNING "%s: IIF Overflow\n",__FUNCTION__);
-	  }
-
-	  if (dma_status != dma_status_old)
-	  	dprintk("%s: DMA Status %x %x\n",__FUNCTION__,dma_status,internal->loop_count);
-
-	  /* If the PTI had to drop packets because we couldn't process in time error */
-	  if (*internal->discard)
-	  {
-	    printk(KERN_WARNING "%s: PTI had to discard %u packets %u %u\n",__func__,
-			*internal->discard,*internal->pread,*internal->pwrite);
-	    printk(KERN_WARNING "%s: Reseting DMA\n",__FUNCTION__);
-
-		internal->err_count++;
-	        stpti_reset_dma(internal);
-	        stpti_start_dma(internal);
-	  } else
-	  {
-
-	     pti_status_old = pti_status;
-	     dma_status_old = dma_status;
-
-	     /* If we get to the bottom of the buffer wrap the pointer back to the top */
-	     if ((pti_rp & ~0xf) == (pti_top & ~0xf)) pti_rp = pti_base;
-
-	  /* Calculate the amount of bytes used in the buffer */
-	  if (pti_rp <= pti_wp) size_first = pti_wp - pti_rp;
-	  else size_first = pti_top - pti_rp;
-
-	  /* Calculate the number of packets in the buffer */
-	  num_packets = size_first / PACKET_SIZE;
-
-	  /* If we have some packets */
-	  if (num_packets)
-	  {
-	    /* And the PTI has acknowledged the updated the packets */
-	    if (!*internal->pread)
-	    {
-	      int start_offset = pti_rp - pti_base;
-
-	      /* Increment the loop counter */
-	      internal->loop_count++;
-
-	      /* The read pointer should always be a multiple of the packet size */
-	      if ((pti_rp - pti_base) % PACKET_SIZE)
-		printk(KERN_WARNING "%s: 0x%x not multiple of %d\n",__FUNCTION__,(pti_rp - pti_base),PACKET_SIZE);
-
-		/* Update the read pointer based on the number of packets we have processed */
-		new_rp = pti_rp + num_packets * PACKET_SIZE;
-
-		/* Increment the packet_count, by the number of packets we have processed */
-		internal->packet_count+=num_packets;
-		if (new_rp > pti_top) dprintk("You b@*tard you killed kenny\n");
-
-		/* If we have gone round the buffer */
-		if (new_rp >= pti_top)
-		{
-		  //printk("+");
-		  /* Update the read pointer so it now points back to the top */
-		  new_rp = pti_base + (new_rp - pti_top); internal->loop_count2++;
-
-		  /* Print out some useful debug information when debugging is on */
-		  dprintk("%s: round the buffer %u times %u=pwrite %u=packet_count %u=num_packets %lu=jiffies %u %u\n",__FUNCTION__,
-			  internal->loop_count2,*internal->pwrite,internal->packet_count,num_packets,jiffies,pti_rp,pti_wp);
-
-		  /* Update the packet count */
-		  internal->packet_count = 0;
-		}
-
-		/* Now update the read pointer in the DMA engine */
-		writel(new_rp, internal->pti_io + PTI_DMA_0_READ );
-
-		/* Now tell the firmware how many packets we have read */
-		PtiWrite(internal->pread,num_packets);
-
-		//printk("*");
-
-		/* notify the injector thread */
-		workQueue[writeIndex].offset = start_offset;
-		workQueue[writeIndex].count = num_packets;
-		writeIndex = (writeIndex + 1) % QUEUE_SIZE;
-		up(&workSem);
-	    } // not read
-  	  } // num_packet
-        } // discard
-
-	/* reschedule the timer */
-	ptiTimer.expires = jiffies + DMA_POLLING_INTERVAL;
-	add_timer(&ptiTimer);
-}
+        STSYS_WriteTCReg16LE((void*)&SessionInfo_p->SessionTSmergerTag, SESSION_NOT_ALLOCATED);
+#if defined(A18)
+        STSYS_WriteTCReg16LE((void*)&SessionInfo_p->SessionEMMFilterOffset, session* TC_Params_p->TC_SizeOfEMMFilter);
 #endif
+        /* Set SlotInterrupt in the Interrupt Mask */
+        STSYS_SetTCMask16LE((void*)&SessionInfo_p->SessionInterruptMask0,STATUS_FLAGS_PACKET_SIGNAL);
+        STSYS_SetTCMask16LE((void*)&SessionInfo_p->SessionInterruptMask0,STATUS_FLAGS_PACKET_SIGNAL_RECORD_BUFFER);
+               
 
-/********************************************************/
+    }
 
-void pti_hal_init ( struct stpti *pti , struct dvb_demux* demux, void (*_demultiplex_dvb_packets)(struct dvb_demux* demux, const u8 *buf, int count))
-{
-  unsigned long start;
-  int vLoopSlots;
+    //Init SessionInfo (stptiHelper_TCInit_SessionInfo)	
+    // ******************************************
 
-  if(_demultiplex_dvb_packets == NULL)
-  {
-    printk("%s: no demultiplex function provided\n", __func__);
-    return;
-  }
+    // ******************************************
+    //Init SlotList (stptiHelper_SlotList_Init)
 
-  demultiplex_dvb_packets = _demultiplex_dvb_packets;
-  external = pti;
+    //fixme: weggelassen, hier holen sie sich speicher fuer die Slots der Sessions; etc
+    //->PrivateData
+	
+    //Init SlotList (stptiHelper_SlotList_Init)
+    // ******************************************
 
-  internal = kmalloc(sizeof(struct pti_internal), GFP_KERNEL);
+    // ******************************************
+    //Init Interrupt DMA (stptiHelper_TCInit_InterruptDMA)
+    TCInterruptDMAConfig_p = (TCInterruptDMAConfig_t *)  TC_Params_p->TC_InterruptDMAConfigStart;
 
-  memset(internal, 0, sizeof(struct pti_internal));
+    /* Adjust the buffer size to make sure it is valid */
+    DMABufferSize = stpti_BufferSizeAdjust(sizeof(TCStatus_t) * NO_OF_STATUS_BLOCKS);
 
-  /* Allocate the back buffer */
-  internal->back_buffer = (char*)bigphysarea_alloc_pages((PTI_BUFFER_SIZE+PAGE_SIZE-1) / PAGE_SIZE,0,GFP_KERNEL);
+    pti->InterruptDMABufferSize = DMABufferSize + DMAScratchAreaSize;
+    base_p = (u8 *)dma_alloc_coherent(NULL,
+                                          pti->InterruptDMABufferSize,
+                                          (dma_addr_t *)&(pti->InterruptDMABufferInfo),
+                                          GFP_KERNEL);
 
-  if (internal->back_buffer == NULL)
-     printk("error allocating back buffer !!!!!!!!!!!!!!!!!!!!!!!!\n");
+    if (base_p == NULL)
+    {
+        printk("!!!!!!!!!! NO MEMORY !!!!!!!!!!!!!!!\n");
+        pti->InterruptBufferStart_p = NULL;
+        return;
+    }
 
-  /* ioremap the pti address space */
-#if defined(UFS912) || defined(SPARK) || defined(SPARK7162) || defined(HS7810A)
-  start = 0xfe230000;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+    __flush_purge_region((void *) base_p, DMABufferSize + DMAScratchAreaSize);
 #else
-  start = 0x19230000;
+    dma_cache_wback_inv((void *) base_p, DMABufferSize + DMAScratchAreaSize);
 #endif
 
-  internal->pti_io = (unsigned long)ioremap((unsigned long) start, 0xFFFF);
-
-  printk("pti ioremap 0x%.8lx -> 0x%.8x\n", start, internal->pti_io);
-
-  /* Resolve pointers we need for later */
-  internal->pidtable    = getsymbol(internal, "pidtable");
-  internal->num_pids    = getsymbol(internal, "num_pids");
-  internal->pidsearch   = getsymbol(internal, "pidsearch");
-
-  internal->psize       = getsymbol(internal, "psize");
-  internal->pread       = getsymbol(internal, "pread");
-  internal->pwrite      = getsymbol(internal, "pwrite");
-  internal->packet_size = getsymbol(internal, "packet_size");
-
-  internal->discard     = getsymbol(internal, "discard");
-  internal->header_size = getsymbol(internal, "header_size");
-  internal->thrown_away = getsymbol(internal, "thrown_away");
-
-  /* Setup PTI */
-  writel(0x1, internal->pti_io + PTI_DMA_PTI3_PROG);
-
-  printk("Load TC ...\n");
-
-  /* Write instructions and data */
-  loadtc(internal);
-
-  printk("Load TC done\n");
-
-  PtiWrite(internal->packet_size,PACKET_SIZE);
-  PtiWrite(internal->header_size,HEADER_SIZE);
-
-  /* Enable IIF */
-  writel(0x0,         internal->pti_io + PTI_IIF_SYNC_LOCK);
-  writel(0x0,         internal->pti_io + PTI_IIF_SYNC_DROP);
-  writel(PACKET_SIZE, internal->pti_io + PTI_IIF_SYNC_PERIOD);
-  writel(0x0,         internal->pti_io + PTI_IIF_SYNC_CONFIG);
-  writel(0x1,         internal->pti_io + PTI_IIF_FIFO_ENABLE);
+    base_p = stpti_BufferBaseAdjust(base_p);
 
-  /* Start the TC */
-  writel(PTI_MODE_ENABLE, internal->pti_io + PTI_MODE );
+    pti->InterruptBufferStart_p = base_p;
 
-  /* Setup packet count */
-  PtiWrite(internal->psize, (PTI_BUFFER_SIZE / (PACKET_SIZE)) - 2);
-  PtiWrite(internal->num_pids,0);
-
-  /* Reset the DMA */
-  stpti_setup_dma(internal);
-  stpti_reset_dma(internal);
-
-  /* Enable the DMA of data */
-#ifdef __TDT__
-	stpti_start_dma(internal);
+#if defined (CONFIG_KERNELVERSION) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+    /* Convert to a physical address for TC. */
+    base_p = (u8 *)virt_to_phys( base_p );
 #else
-  writel( readl(internal->pti_io + PTI_DMA_ENABLE) | 0x1, internal->pti_io + PTI_DMA_ENABLE );
+    /* Convert to a physical address for TC. */
+    base_p = (u8 *)virt_to_bus( base_p );
 #endif
 
-  internal->vSlots =
-      kmalloc ( sizeof ( struct tSlot * ) * 32,	GFP_KERNEL );
-
-  for ( vLoopSlots = 0; vLoopSlots < 32; vLoopSlots++ )
-  {
-      internal->vSlots[vLoopSlots] =
-	kmalloc ( sizeof ( struct tSlot ), GFP_KERNEL );
+    /* Sort out base and top alignment */
 
-      memset ( internal->vSlots[vLoopSlots], 0, sizeof ( struct tSlot ) );
+    top_p = base_p + DMABufferSize;
 
-      internal->vSlots[vLoopSlots]->Handle = SLOT_HANDLE_OFFSET + vLoopSlots;
-      internal->vSlots[vLoopSlots]->tcIndex = -1;
-      internal->vSlots[vLoopSlots]->pid = 0xffff;
-  }
+    /* set top_p, btm, read_p & write_p ( qwrite_p etc not required ) */
+    writel((u32) base_p, (void*)&TCInterruptDMAConfig_p->DMABase_p );
+    writel(((u32) top_p-1) & ~0X0f , (void*)&TCInterruptDMAConfig_p->DMATop_p);
+    writel((u32) base_p , (void*)&TCInterruptDMAConfig_p->DMARead_p);
+    writel((u32) base_p , (void*)&TCInterruptDMAConfig_p->DMAWrite_p);
 
-  /* set up the processing thread */
-  sema_init(&workSem, 0);
-  kernel_thread ( stream_injector, internal, 0 );
+    //Init Interrupt DMA (stptiHelper_TCInit_InterruptDMA)
+    // ******************************************
 
-  /* schedule the polling process */
-  init_timer(&ptiTimer);
-  ptiTimer.expires = jiffies + DMA_POLLING_INTERVAL;
-  ptiTimer.function = process_pti_dma;
-  ptiTimer.data = 0;
-  add_timer(&ptiTimer);
+    // ******************************************
+    //Alloc PrivateData (stptiHelper_TCInit_AllocPrivateData)
 
-  return;
+    //fixme erstmal wechgelassen (SlotHandle etc werden alloziiert)
 
-}
+    //Alloc PrivateData
+    // ******************************************
 
-int pti_hal_descrambler_set ( int session_handle, int descrambler_handle,
-			      u8 * Data, int parity )
-{
-        return 0;
-}
+    // ******************************************
+    //TcCam Init (TcCam_Initialize)
+    TC_SectionFilterArrays_p = (TCSectionFilterArrays_t *) &TC_Device->TC_SectionFilterArrays;
 
-int pti_hal_descrambler_unlink ( int session_handle, int descrambler_handle )
-{
-        return 0;
-}
-
-int pti_hal_descrambler_link ( int session_handle, int descrambler_handle,
-			       int slot_handle )
-{
-        return 0;
-}
-
-int pti_hal_get_new_descrambler ( int session_handle )
-{
-	return 1;
-}
-
-int pti_hal_slot_clear_pid ( int session_handle, int slot_handle )
-{
-  int i;
-
-  slot_handle -= SLOT_HANDLE_OFFSET;
-
-  printk("%s slot = %d, tc = %d, num = %d\n", __FUNCTION__, slot_handle,
-		internal->vSlots[slot_handle]->tcIndex,
-		*internal->num_pids);
-
-  if ((internal->vSlots[slot_handle]->tcIndex < 0) ||
-	(internal->vSlots[slot_handle]->pid == 0xffff))
-  {
-       printk("error pid not set, can't clear\n");
-       return -1;
-  }
-
-  /* Now reallocate the PIDs in the DMA table.
-     Move the last PID to the TC index to be cleared (shift operation
-     in the original code disturbs other PIDs). The sleep operation seems
-     to be necessary because without it the transport stream is disturbed. */
-  PtiWrite(&internal->pidtable[internal->vSlots[slot_handle]->tcIndex],
-		internal->pidtable[*internal->num_pids - 1]);
-  msleep(10);
-  PtiWrite(internal->num_pids , *internal->num_pids - 1);
-
-  /* ... and update id information */
-  for(i = 0; i < 32; i++)
-  {
-    /* find the slot using the moved TC index */
-    if(*internal->num_pids == internal->vSlots[i]->tcIndex)
+    //ClearAllCams( TC_SectionFilterArrays_p );
+    for( block = 0; block < SF_NUM_BLOCKS_PER_CAM; block++ )
     {
-      internal->vSlots[i]->tcIndex = internal->vSlots[slot_handle]->tcIndex;
-      break;
-    }
-  }
-
-  internal->vSlots[slot_handle]->tcIndex = -1;
-
-  internal->err_count = 0;
-
-  return 0;
-}
+        for( index = 0; index < SF_FILTER_LENGTH; index++ )
+        {
+            TC_SectionFilterArrays_p->CamA_Block[block].Index[index].Data.Word = 0xffffffff;
+            TC_SectionFilterArrays_p->CamA_Block[block].Index[index].Mask.Word = 0xffffffff;
 
-int pti_hal_slot_free ( int session_handle, int slot_handle )
-{
-  printk("%s %d\n", __FUNCTION__, slot_handle);
-
-  if(internal->vSlots[slot_handle - SLOT_HANDLE_OFFSET]->tcIndex != -1)
-    pti_hal_slot_clear_pid (session_handle, slot_handle );
-
-  slot_handle -= SLOT_HANDLE_OFFSET;
-
-  internal->vSlots[slot_handle]->inUse = 0;
-  internal->vSlots[slot_handle]->pid = 0xffff;
-  internal->vSlots[slot_handle]->tcIndex = -1;
-
-  internal->err_count = 0;
-
-  return 0;
-}
-
-int pti_hal_slot_unlink_buffer ( int session_handle, int slot_handle)
-{
-        return 0;
-}
-
-int pti_hal_slot_link_buffer ( int session_handle, int slot_handle,
-			       int bufType)
-{
-        return 0;
-}
-
-
-int pti_hal_slot_set_pid ( int session_handle, int slot_handle, u16 pid )
-{
-  int vLoop;
-
-  printk("%s: %d %d %d\n", __FUNCTION__, session_handle, slot_handle, pid);
-
-  for (vLoop = 0; vLoop < (*internal->num_pids); vLoop++)
-  {
-	  if ((unsigned short) internal->pidtable[vLoop] == (unsigned short) pid)
-	  {
-		 printk("pid %d already collecting. ignoring ... \n", pid);
-		 return -1;
-	  }
-  }
-
-  for (vLoop = 0; vLoop < 32; vLoop++)
-  {
-     if (internal->vSlots[vLoop]->Handle == slot_handle)
-     {
-	if ( internal->vSlots[vLoop]->inUse == 1 )
-	{
-	   internal->vSlots[vLoop]->pid = pid;
-	   internal->vSlots[vLoop]->tcIndex = *internal->num_pids;
-
-	   printk("%s ok (pid %d, tc = %d)\n", __FUNCTION__, pid, *internal->num_pids);
-
-	   PtiWrite(&internal->pidtable[*internal->num_pids], pid);
-	   msleep(10);
-	   PtiWrite(internal->num_pids,*internal->num_pids + 1);
-
-           return 0;
-	} else
-	{
-	   printk("%s failed1\n", __FUNCTION__);
-	   return -1;
+            TC_SectionFilterArrays_p->CamB_Block[block].Index[index].Data.Word = 0xffffffff;
+            TC_SectionFilterArrays_p->CamB_Block[block].Index[index].Mask.Word = 0xffffffff;
         }
-     }
-  }
+    }
 
-  printk("%s failed2\n", __FUNCTION__);
-  return -1;
+    for( index = 0; index < TC_NUMBER_OF_HARDWARE_NOT_FILTERS; index++ )
+    {
+        TC_SectionFilterArrays_p->NotFilter[index] = 0;
+    }
 
-}
+    //fixme: auch hier hab ich die ganze interne verwaltung wegoptimiert ;-)
 
-int pti_hal_get_new_slot_handle ( int session_handle, int dvb_type,
-				  int dvb_pes_type, struct dvb_demux *demux,
-				  struct StreamContext_s *DemuxStream,
-				  struct DeviceContext_s *DeviceContext )
-{
-  int vLoopSlots;
+    //TcCam Init (TcCam_Initialize)
+    // ******************************************
 
-  for ( vLoopSlots = 0; vLoopSlots < 32; vLoopSlots++ )
-  {
-	if ( internal->vSlots[vLoopSlots]->inUse == 0 )
-	{
-          internal->vSlots[vLoopSlots]->inUse = 1;
-          internal->vSlots[vLoopSlots]->tcIndex = -1;
+    // ******************************************
+    //Start (stptiHelper_TCInit_Start)
+#if 0
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->TCMode, 0x08 );       /* Full Reset the TC  */
 
-	  printk("ret slothandle = %d\n", internal->vSlots[vLoopSlots]->Handle);
+    udelay(200*64); /* 12800us */               /* Wait */
 
-          return internal->vSlots[vLoopSlots]->Handle;
-	}
-  }
+    STSYS_WriteRegDev32LE( (void*)&TC_Device->TCMode, 0x00 );       /* Finish Full Reset the TC  */
 
-  return -1;
-}
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
-int pti_hal_set_source(int session_handle, const int source)
-//FIXME int pti_hal_set_source ( int session_handle, const dmx_source_t source )
-#else
-int pti_hal_set_source ( int session_handle, const dmx_source_t source )
+    udelay(10*64); /* 640us */
 #endif
-{
-		printk("source %d, session_handle %d\n", source, session_handle);
-		#if defined(SPARK7162)
-		{
-			int i;
-			int old_session;
-			int old_source = -1;
-			old_session = internal->demux_tag[source];
-			printk("before\n");
-			for (i = 0; i < TAG_COUNT; i++)
-			{
-				printk("internal->demux[%d] = 0x%x\n",
-						i, (int)internal->demux[i]);
-				printk("internal->demux_tag[%d] = %d\n",
-						i, internal->demux_tag[i]);
-			}
-			if (old_session == session_handle)
-			{
-        		return 1;
-			}
-			for (i = 0; i < TAG_COUNT; i++)
-			{
-			    if (internal->demux[i])
-			    {
-			        if (internal->demux_tag[i] == session_handle)
-			        {
-			            old_source = i;
-			        }
-			    }
-			}
-			internal->demux_tag[source] = session_handle;
-			if (old_source > -1)
-			{
-				internal->demux_tag[old_source] = old_session;
-			}
-
-			printk("after\n");
-			for (i = 0; i < TAG_COUNT; i++)
-			{
-				printk("internal->demux[%d] = 0x%x\n",
-						i, (int)internal->demux[i]);
-				printk("internal->demux_tag[%d] = %d\n",
-						i, internal->demux_tag[i]);
-			}
-		}
-		#endif
-        return 1;
-}
 
-int pti_hal_get_session_handle ( int tc_session_number )
-{
-	return 1;
-}
+    writel( 1, (void*)&TC_Device->IIFFIFOEnable );
+    writel( 2, (void*)&TC_Device->TCMode );
+    writel( 1, (void*)&TC_Device->TCMode );
+    
 
-int pti_hal_get_new_session_handle ( int source, struct dvb_demux * demux )
-{
-	if((source >= 0) && (source < TAG_COUNT))
-	{
-		printk("session %d, demux %p\n", source, demux);
-		internal->demux[source] = demux;
-		#if defined(SPARK7162)
-		internal->demux_tag[source] = source;
-		#endif
-	}
-
-	return source;
 }
 
-void paceSwtsByPti(void)
-{
-}
-
-EXPORT_SYMBOL(paceSwtsByPti);
-
-EXPORT_SYMBOL(pti_hal_descrambler_set);
-EXPORT_SYMBOL(pti_hal_descrambler_unlink);
-EXPORT_SYMBOL(pti_hal_descrambler_link);
-EXPORT_SYMBOL(pti_hal_get_new_descrambler);
-EXPORT_SYMBOL(pti_hal_slot_free);
-EXPORT_SYMBOL(pti_hal_slot_unlink_buffer);
-EXPORT_SYMBOL(pti_hal_slot_link_buffer);
-EXPORT_SYMBOL(pti_hal_slot_clear_pid);
-EXPORT_SYMBOL(pti_hal_slot_set_pid);
-EXPORT_SYMBOL(pti_hal_get_new_slot_handle);
-EXPORT_SYMBOL(pti_hal_set_source);
-EXPORT_SYMBOL(pti_hal_get_session_handle);
-EXPORT_SYMBOL(pti_hal_get_new_session_handle);
-EXPORT_SYMBOL(pti_hal_init);
-
 int __init pti_init(void)
 {
-   printk("pti loaded\n");
+   printk("pti loaded (videoMem = %d, waitMS = %d", videoMem, waitMS);
+#ifdef WITH_CAMROUTING
+   printk(", camRouting = %d", camRouting);
+#endif
+#ifdef CONFIG_PRINTK
+   printk(", enableStatistic = %d", enableStatistic); 
+#else
+   printk(", enableSysStatistic = %d", enableSysStatistic); 
+#endif
+   printk(")\n");
    return 0;
+
 }
 
-static void __exit pti_exit(void)
-{
+void __exit pti_exit(void)
+{  
    printk("pti unloaded\n");
 }
 
 module_init             (pti_init);
 module_exit             (pti_exit);
 
-#if defined(PLAYER_179) || defined(PLAYER_191)
-#if (defined(HL101) || defined(VIP1_V2) || defined(VIP2_V1) || defined(SPARK) || defined(SPARK7162))
-module_param(waitMS, int, 0444);
-MODULE_PARM_DESC(waitMS, "waitMS");
+MODULE_DESCRIPTION      ("PTI driver");
+MODULE_AUTHOR           ("Team Ducktales");
+MODULE_LICENSE          ("NO");
 
-module_param(videoMem, int, 0444);
-MODULE_PARM_DESC(videoMem, "videoMem\n");
+#ifdef WITH_CAMROUTING
+module_param(camRouting, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+MODULE_PARM_DESC(camRouting, "ufs910 only! 1=if stream not scrambled do not route it through cimax");
 #endif
-#elif defined(PLAYER_131)
+
+module_param(videoMem, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+MODULE_PARM_DESC(videoMem, "memory for video pid buffer in dvb packets (188 byte). default 2048");
+
+module_param(waitMS, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+MODULE_PARM_DESC(waitMS, "waiting time in ms before processing next data (default=20)");
+
+#ifdef CONFIG_PRINTK
+module_param(enableStatistic, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+MODULE_PARM_DESC(enableStatistic, "enable statistic output on pids arriving pti (default=0=disabled)");
 #else
-#endif
+module_param(enableSysStatistic, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+MODULE_PARM_DESC(enableSysStatistic, "enable sys statistic output on pids arriving pti (default=1=disabled)");
 
-MODULE_AUTHOR("Peter Bennett <peter.bennett@st.com>; adapted by TDT");
-MODULE_DESCRIPTION("STPTI DVB Driver");
-MODULE_LICENSE("GPL");
+module_param(pti_last_time, ulong, S_IRUSR | S_IRGRP);
+MODULE_PARM_DESC(pti_last_time, "last time pti task called");
+
+module_param(pti_count, ulong, S_IRUSR | S_IRGRP);
+MODULE_PARM_DESC(pti_count, "pti package counter");
+#endif
diff --git a/tdt/cvs/driver/pti/pti_main.h b/tdt/cvs/driver/pti/pti_main.h
new file mode 100644
index 0000000..8ae9085
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_main.h
@@ -0,0 +1,20 @@
+#ifndef pti_main_h_123
+#define pti_main_h_123
+
+#include "pti_public.h"
+
+/* *****************************
+ * Global vars
+ */
+
+/* not good but for first shot we make vars globally accessible */
+extern STPTI_TCParameters_t tc_params;
+extern TCDevice_t* myTC;
+
+/* ******************************
+ * Functions
+ */
+
+void pti_main_loadtc(struct stpti* pti);
+
+#endif
diff --git a/tdt/cvs/driver/pti/pti_process.c b/tdt/cvs/driver/pti/pti_process.c
new file mode 100644
index 0000000..3858fea
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_process.c
@@ -0,0 +1,478 @@
+/*
+ * Data processing function.
+ *
+ */
+ 
+#include <linux/init.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
+#endif
+
+#include <asm/io.h>
+#include <asm/cacheflush.h>
+
+#include "dmxdev.h"
+#include "dvb_demux.h"
+#include <linux/dvb/dmx.h>
+
+#include "pti.h"
+#include "pti_main.h"
+#include "pti_hal.h"
+#include "ts_makros.h"
+
+#define U32 u32
+#define U16 u16
+#define U8 u8
+
+#ifdef WITH_CAMROUTING
+extern int camRouting;
+#endif
+extern int waitMS;
+#ifdef CONFIG_PRINTK
+extern int enableStatistic;
+#else
+extern int enableSysStatistic;
+#endif
+extern int max_pti_dma;
+extern struct TCDMAConfigExt_s *TCDMAConfigExt_t;
+
+static struct stpti *pti = NULL;
+extern void (*demultiplexDvbPackets)(struct dvb_demux* demux, const u8 *buf, int count);
+
+void setDmaThreshold(int a, int b)
+{
+}
+
+#ifdef CONFIG_PRINTK
+int pktCount;
+int prevPktCount;
+int maxDelta;
+int minDelta = 999999999;
+int loopCount = 0;
+int lastPktCount;
+#endif
+
+static wait_queue_head_t   bufferHalfFull;
+
+void paceSwtsByPti(void)
+{
+    if (wait_event_interruptible(bufferHalfFull, 1))
+    {
+         printk("wait_event_interruptible failed\n");
+         return;
+    }
+}
+
+EXPORT_SYMBOL(paceSwtsByPti);
+
+#ifdef CONFIG_PRINTK
+struct pidStatistic_s
+{
+    int           number;
+    unsigned long time; 
+
+    unsigned long complete;
+    unsigned int  rate;
+
+    unsigned int  min_rate;
+    unsigned int  max_rate;
+
+    u8            lastCC;
+    u8            ccError;
+};
+
+struct pidStatistic_s pidS[0xffff];
+
+void ptiStatistic(int num, u8* pBuf)
+{
+   int i; 
+   u8 cc;
+
+   /* walk over the packets, count each pid and remeber the current time */
+   for (i = 0; i < num; i++)
+   {
+       u16 pid = ts_pid(pBuf + (i * 188));
+       pidS[pid].number++;
+       pidS[pid].complete++;
+       
+       if ((pidS[pid].time == 0) || (time_after(jiffies, pidS[pid].time + HZ /* 1 sekunde vorbei ? */)))
+       {
+          pidS[pid].time = jiffies;
+       
+          pidS[pid].rate = pidS[pid].number;
+	      pidS[pid].number = 0;
+        
+          if ((pidS[pid].rate > pidS[pid].max_rate) || (pidS[pid].max_rate == 0))
+	         pidS[pid].max_rate = pidS[pid].rate;
+	     
+          if ((pidS[pid].rate < pidS[pid].min_rate) || (pidS[pid].min_rate == 0))
+	         pidS[pid].min_rate = pidS[pid].rate;
+       
+       }
+       cc = ts_cc(pBuf + (i * 188));
+       
+       if (pidS[pid].lastCC != 255)
+       {
+          if ((pidS[pid].lastCC + 1) % 0x10 != cc)
+          {
+             pidS[pid].ccError++;  
+             printk("cc error last %d exp %d got %d\n", pidS[pid].lastCC, (pidS[pid].lastCC + 1) % 0x10, cc);
+          }
+       }
+       pidS[pid].lastCC = cc;  
+   }
+}
+
+void ptiStatisticClean(void)
+{
+   int i;
+
+   for (i = 0; i < 0xffff; i++)
+   {
+       if ((time_after(jiffies, pidS[i].time + (HZ * 5) /* 5 sekunde vorbei ? */)))
+       {
+           pidS[i].rate = 0;
+           pidS[i].min_rate = 0;
+           pidS[i].max_rate = 0;
+           pidS[i].complete = 0;
+           pidS[i].number = 0;
+           pidS[i].time = 0;
+           pidS[i].lastCC = 255;
+           pidS[i].ccError = 0;
+       }
+   }
+}
+
+void ptiStatisticOut(void)
+{
+   int i;
+   for (i = 0; i < 0xffff; i++)
+   {
+       if (pidS[i].rate != 0)
+           printk("pidstatistic: pid 0x%x, rate = %d packets/s (complete %lu) %d Mbps/s, min %d/s - max %d/s, CC error %d\n", i, 
+	           pidS[i].rate, pidS[i].complete, (pidS[i].rate * 188 * 8) / (1024 * 1024), pidS[i].min_rate, pidS[i].max_rate, pidS[i].ccError);
+   }
+}
+#else
+extern unsigned long pti_last_time; 
+extern unsigned long pti_count;
+
+void ptiStatistic(int num)
+{
+    pti_last_time  = jiffies;
+    pti_count     += num;
+}
+#endif
+
+inline static void processDmaChannel (int tc_dma_index,
+			       U32 ReadPtr_physical,
+			       U32 WritePtr_physical,
+			       TCDMAConfig_t *DMAConfig_p)
+{
+  struct dvb_demux *demux = pti_hal_get_demux_from_dma_index ( tc_dma_index );
+
+  /* calculate the write index in the buffer */
+  U32 WriteInd = ( WritePtr_physical - TCDMAConfigExt_t[tc_dma_index].BasePtr_physical );
+  /* calculate the read index in the buffer */
+  U32 ReadInd = ( ReadPtr_physical - TCDMAConfigExt_t[tc_dma_index].BasePtr_physical );
+  /* calculate the read pointer */
+  U8 *pBuf_add_ReadInd = ( TCDMAConfigExt_t[tc_dma_index].pBuf + ReadInd );
+
+  /* decrease the index by one packet because it might be rolled back or
+   * be incomplete
+  
+   * nit: laut meinen debugs sind nie unvollstaendige Pakete gekommen.
+   *      Ausserdem wuerde dem demuxer nicht vollstaendige Pakete uebergeben werden,
+   *      was dieser dann verwirft, daher auf 188 ausrichten.
+   */
+  if(WriteInd >= 188)
+	  WriteInd -= 188;  // normal case
+  else
+	  WriteInd = TCDMAConfigExt_t[tc_dma_index].bufSize_sub_188;  //after a wraparound (e.g. WriteInd = 0)
+
+  // align to 188
+  WriteInd = (WriteInd / 188) * 188;
+
+  /* ist passiert als ich speicher ueberschrieben hatte, kann nicht schaden
+   * denke ich; update: auch danach ist es aufgetreten; interrupt failed?
+
+   * nit: ich denke mit diese Abfrage laesst sich kein Bufferueberlauf, 
+   *      in einen Ringbuffer feststellen.
+   */
+  if (WriteInd > TCDMAConfigExt_t[tc_dma_index].bufSize)
+  {
+    printk("pti_task: (%x, %x, %x)\n", WriteInd, TCDMAConfigExt_t[tc_dma_index].TopPtr_physical, TCDMAConfigExt_t[tc_dma_index].BasePtr_physical);
+    /* clear buffer and bye bye */
+    writel(readl((void*)&DMAConfig_p->DMAWrite_p), (void*)&DMAConfig_p->DMARead_p);
+    return;
+  }
+
+#ifdef CONFIG_PRINTK
+  prevPktCount = pktCount;
+#endif
+
+  /* validate pointers, even if they are invalid we want to process
+     status blocks */
+  if((TCDMAConfigExt_t[tc_dma_index].pBuf != NULL) && (demux != NULL))
+  {
+    struct DeviceContext_s* pContext = (struct DeviceContext_s*)demux->priv;
+
+    int num = 0;
+    if ( WriteInd < ReadInd )
+    {
+      int bytenum = ( TCDMAConfigExt_t[tc_dma_index].bufSize - ReadInd );
+      int num1 = bytenum / 188;
+      int num2 = WriteInd / 188;
+      num = num1 + num2;
+
+#ifdef CONFIG_PRINTK
+      pktCount += num;
+#endif
+
+      /* zur erklaerung dieser sache. ich hatte eine zeitlang einen ueberschriebenen
+       * speicher und somit konnte dies auftreten. ich denke solche abfragen koennen
+       * nicht schaden von daher hab ich es drinne gelassen.
+
+       * nit: ich denke mit diese Abfrage laesst sich kein Bufferueberlauf, 
+       *      in einen Ringbuffer feststellen.
+       */
+      if (num > TCDMAConfigExt_t[tc_dma_index].bufSize_div_188)
+      {
+	  printk("pti_task: (%x, %x, %d, %x, %x, %x)\n", TCDMAConfigExt_t[tc_dma_index].bufSize, ReadInd, num, ReadPtr_physical,
+              TCDMAConfigExt_t[tc_dma_index].BasePtr_physical, TCDMAConfigExt_t[tc_dma_index].TopPtr_physical);
+      } 	
+      else if (demultiplexDvbPackets != NULL)
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+//    __flush_invalidate_region(pBuf_add_ReadInd, bytenum);
+    invalidate_ioremap_region (0, pBuf_add_ReadInd, 0, bytenum);
+#else
+	   dma_cache_inv(pBuf_add_ReadInd, bytenum);
+#endif
+	   demultiplexDvbPackets ( demux, pBuf_add_ReadInd, num1 );  // process packets before wraparound
+           
+#ifdef CONFIG_PRINTK
+	   if (enableStatistic)
+	      ptiStatistic(num1, pBuf_add_ReadInd);
+#else
+	   if (enableSysStatistic)
+	      ptiStatistic(num1);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+//    __flush_invalidate_region(TCDMAConfigExt_t[tc_dma_index].pBuf, WriteInd);
+    invalidate_ioremap_region (0, TCDMAConfigExt_t[tc_dma_index].pBuf, 0, WriteInd);
+#else
+	   dma_cache_inv(TCDMAConfigExt_t[tc_dma_index].pBuf, WriteInd);
+#endif
+	   demultiplexDvbPackets ( demux, TCDMAConfigExt_t[tc_dma_index].pBuf, num2 );  // process packets after wraparound
+
+#ifdef CONFIG_PRINTK
+	   if (enableStatistic)
+	      ptiStatistic(num2, TCDMAConfigExt_t[tc_dma_index].pBuf);
+#else
+	   if (enableSysStatistic)
+	      ptiStatistic(num2);
+#endif
+      }
+      //printk("+");
+    }
+    else
+    {
+      int bytenum = ( WriteInd - ReadInd );
+      num = bytenum / 188;
+
+#ifdef CONFIG_PRINTK
+      pktCount += num;
+#endif
+
+      /* nit: ich denke mit diese Abfrage laesst sich kein Bufferueberlauf, 
+       *      in einen Ringbuffer feststellen.
+       */
+      if (num > TCDMAConfigExt_t[tc_dma_index].bufSize_div_188)
+      {
+	  printk("pti_task: (%x, %x, %x, %d)\n", WriteInd, ReadInd, TCDMAConfigExt_t[tc_dma_index].BasePtr_physical, tc_dma_index);
+      } 	
+      else if (demultiplexDvbPackets != NULL)
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+//    __flush_invalidate_region(pBuf_add_ReadInd, bytenum);
+    invalidate_ioremap_region (0, pBuf_add_ReadInd, 0, bytenum);
+#else
+	  dma_cache_inv(pBuf_add_ReadInd, bytenum);
+#endif
+	  demultiplexDvbPackets ( demux, pBuf_add_ReadInd, num );
+
+#ifdef CONFIG_PRINTK
+	  if (enableStatistic)
+	     ptiStatistic(num, pBuf_add_ReadInd);
+#else
+	   if (enableSysStatistic)
+	     ptiStatistic(num);
+#endif
+      }
+      //printk(".");
+    }
+
+    /* if the input is the DVR device the data is played
+       back via SWTS to enable passing the playback data
+       though the hardware descrambler */
+    if(pContext->pPtiSession->source == DMX_SOURCE_DVR0)
+    {
+      if(num < TCDMAConfigExt_t[tc_dma_index].bufSize_div_188_div_2)
+      {
+        /* Buffer is less than half-empty, enable the semaphore.
+	   Enforce binary semaphore behavior, otherwise the caller
+           wouldn't block when necessary. */
+       wake_up_interruptible(&bufferHalfFull);
+      }
+      //printk("pti_task: %d\n", num);
+    }
+  }
+
+  //printk("pti_task: RI %d, BA %x\n", ReadInd, DMAConfig_p->BasePtr_physical);
+
+#ifdef CONFIG_PRINTK
+  if((pktCount - prevPktCount) > maxDelta)
+  {
+    maxDelta = pktCount - prevPktCount;
+  }
+
+  if((pktCount - prevPktCount) < minDelta)
+  {
+    minDelta = pktCount - prevPktCount;
+  }
+
+  loopCount++;
+
+  if(!(loopCount % 50) && (enableStatistic))
+  {
+    printk("statistic: pktCount %d last packets %d minDelta %d maxDelta %d\n", pktCount, pktCount - lastPktCount, minDelta, maxDelta);
+    ptiStatisticOut();
+    ptiStatisticClean();
+    lastPktCount = pktCount;
+    minDelta = 999999999;
+    maxDelta = 0;
+  }
+#endif
+
+  /*
+   * acknowledge all packets in the block 
+   
+   * nit: wird das abschneiden und ausrichten des WriteInd deaktiviert,
+   *      so kann WritePtr_physical verwendet werden.
+   */
+  //writel ( WritePtr_physical, ( void * ) &DMAConfig_p->DMARead_p );
+  writel ( TCDMAConfigExt_t[tc_dma_index].BasePtr_physical + WriteInd, ( void * ) &DMAConfig_p->DMARead_p );
+}
+
+#define SysConfigBaseAddress    0x19001000
+#define SYS_CFG0      		0x100
+#define SYS_CFG1      		0x104
+
+#define TSMergerBaseAddress   	0x19242000
+#define TSM_1394_CFG      	0x0810
+#define TSM_PTI_SEL      	0x0200
+#define TSM_1394_DEST      	0x0210
+
+unsigned long    reg_sys_config = 0;
+unsigned long    reg_tsm_config = 0;
+
+int pti_task ( void *data )
+{
+  //STPTI_TCParameters_t *TC_Params_p = &tc_params;
+  TCDMAConfig_t *DMAConfig_p;
+  int vLoopDMAs;
+  U32 WritePtr_physical;
+  U32 ReadPtr_physical;
+  int time_to_wait = msecs_to_jiffies(waitMS);
+
+  pti = (struct stpti*) data;
+
+  daemonize ( "pti_task" );
+
+  //set highest prio
+  set_user_nice(current, -20);
+  printk("pti_task: using %d dma channel\n", max_pti_dma);
+
+  init_waitqueue_head (&pti->queue);
+  init_waitqueue_head(&bufferHalfFull);
+
+  while ( 1 )
+  {
+    wait_event_timeout(pti->queue, 0, time_to_wait);
+
+#ifndef CONFIG_PRINTK
+//update pti time
+    if (enableSysStatistic)
+        ptiStatistic(0);
+#endif
+    
+/*    pti_hal_output_slot_state(); */
+/* Dagobert: configure the stream routing in accordance to
+ * the scrambled state. route stream only through cimax
+ * if screem is scrambled, otherwise directly to pti
+ */
+
+#ifdef WITH_CAMROUTING
+    if (camRouting == 1)
+    {
+       int state;
+       if ((state = pti_hal_get_scrambled()) != -1)
+       {
+          u32 reg;
+	  
+	  if (reg_sys_config == 0)
+	  {
+	     reg_sys_config = (unsigned long) ioremap(SysConfigBaseAddress, 0x0900);
+	     reg_tsm_config = (unsigned long) ioremap(TSMergerBaseAddress, 0x0900);
+	  }
+
+          reg = ctrl_inl(reg_tsm_config + TSM_1394_CFG);
+
+          if (state == 1)
+	  {
+	      ctrl_outl(0x6, reg_sys_config + SYS_CFG0);
+	      ctrl_outl(reg | 0x20000 ,reg_tsm_config + TSM_1394_CFG);
+	      
+	      ctrl_outl(0xe ,reg_tsm_config + TSM_PTI_SEL);
+              ctrl_outl(0x1 , reg_tsm_config + TSM_1394_DEST);
+	  } else
+	  {
+	      ctrl_outl(0x2, reg_sys_config + SYS_CFG0);
+	      ctrl_outl(reg & ~ 0x20000 ,reg_tsm_config + TSM_1394_CFG);
+
+	      ctrl_outl(0xf ,reg_tsm_config + TSM_PTI_SEL);
+              ctrl_outl(0x0 , reg_tsm_config + TSM_1394_DEST);
+	  }
+       }
+
+    }
+#endif
+
+    for ( vLoopDMAs = 0; vLoopDMAs < /* TC_Params_p->TC_NumberDMAs*/ max_pti_dma; vLoopDMAs++ )
+    {
+      DMAConfig_p = &((TCDMAConfig_t *)tc_params.TC_DMAConfigStart)[vLoopDMAs];
+      
+      ReadPtr_physical = readl ( ( void * ) &DMAConfig_p->DMARead_p );
+      WritePtr_physical = readl ( ( void * ) &DMAConfig_p->DMAWrite_p );
+      
+      if(ReadPtr_physical != WritePtr_physical)
+      {
+         processDmaChannel(vLoopDMAs, ReadPtr_physical, WritePtr_physical, DMAConfig_p);
+      }
+    }
+    
+  }				/* while true */
+
+  printk ( "######## PTI task terminated\n" );
+  // TODO: stop dma
+}
+
diff --git a/tdt/cvs/driver/pti/pti_session.c b/tdt/cvs/driver/pti/pti_session.c
new file mode 100644
index 0000000..4e30e9a
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_session.c
@@ -0,0 +1,139 @@
+
+#include "pti.h"
+#include "pti_main.h"
+#include "pti_session.h"
+
+static u32 St20ToTcRamAddress( u32 SomeSt20Address, STPTI_TCParameters_t *TC_Params_p )
+{
+    return ( (u32) ( (u8 *)SomeSt20Address - (u8 *)TC_Params_p->TC_DataStart + (u8 *)TC_DSRAM_BASE) );
+}
+
+void pti_session_set_source(int index, int tsmerger_tag)
+{
+  TCSessionInfo_t *TCSessionInfo_p = &((TCSessionInfo_t *)tc_params.TC_SessionDataStart)[index];
+
+  if(tsmerger_tag != STPTI_STREAM_ID_NONE)
+  {
+    // check the usage of the given stream ID
+    // there must be no other session using the same TS input stream
+    // otherwise the setting would disturb data arrival for all sessions
+    int i;
+    for(i = 0; i < tc_params.TC_NumberOfSessions; i++)
+    {
+      TCSessionInfo_p = &((TCSessionInfo_t *)tc_params.TC_SessionDataStart)[i];
+
+      if(((readw(&TCSessionInfo_p->SessionTSmergerTag) &
+		 ~SESSION_USE_MERGER_FOR_STC) == tsmerger_tag) && (i != index))
+      {
+	// source already in use
+	printk("%s(%d,%x): ERROR STREAM ALREADY IN USE (%d)\n", __func__, index, tsmerger_tag, i);
+	return;
+      }
+    }
+  }
+
+  TCSessionInfo_p = &((TCSessionInfo_t *)tc_params.TC_SessionDataStart)[index];
+  STSYS_WriteTCReg16LE(&TCSessionInfo_p->SessionTSmergerTag,
+                       tsmerger_tag | SESSION_USE_MERGER_FOR_STC);
+}
+
+/* **************************************
+ * Init Session and return session number
+ */
+int pti_session_init(int tsmerger_tag, int slotOffset, int numberSlots)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    TCSessionInfo_t      *TCSessionInfo_p;
+    u16 SlotsToAllocate;
+    u16 BytesToAllocate;
+    int session;
+    //u8 numfilters;
+    //int numblocks, filtermode, filtersperblock=SF_NUM_FILTERS_PER_BLOCK;
+    
+    // ******************************************
+    //stptiHAL_PeekNextFreeSession(FullHandle_t DeviceHandle)
+
+    for (session = 0; session < TC_Params_p->TC_NumberOfSessions; session++)
+    {
+        TCSessionInfo_p = &((TCSessionInfo_t *)TC_Params_p->TC_SessionDataStart)[session];
+
+        if ( readw((void*)&TCSessionInfo_p->SessionTSmergerTag) == SESSION_NOT_ALLOCATED )
+        {
+           	printk("Free session: %d\n", session );
+		break;
+       }
+    }
+
+    if (session == TC_Params_p->TC_NumberOfSessions)
+    {
+	printk("No free session !!!!!!!!!!!!!!!!\n");	
+    	return -1;
+    } else
+    {
+    	printk("Using session %d\n", session);
+    }
+
+    // ******************************************************
+    //stptiHAL_GetNextFreeSession(FullHandle_t DeviceHandle)
+
+    TCSessionInfo_p = &((TCSessionInfo_t *)TC_Params_p->TC_SessionDataStart)[session];
+
+    pti_session_set_source(session, tsmerger_tag);
+
+    // ********************************************************************
+    //stptiHelper_TCInit_SessionInfoModeFlags( FullHandle_t DeviceHandle )
+    
+    /* Set DiscardSynchByte bit in the global data structure if STPTI has been initialised with this option */
+    /* See DDTS GNBvd08680 PJW */
+
+//    if ( (Device_p->TCCodes == STPTI_SUPPORTED_TCCODES_SUPPORTS_DVB) 
+        /* DVB has a 1 byte header (the sync byte) */
+
+    STSYS_SetTCMask16LE ((void*)&TCSessionInfo_p->SessionModeFlags,(TC_GLOBAL_DATA_DISCARD_SYNC_BYTE_SET));
+    STSYS_WriteTCReg16LE((void*)&TCSessionInfo_p->SessionDiscardParams, 1 );
+
+    // ********************************************************
+    //stptiHelper_SlotList_Alloc( FullHandle_t DeviceHandle )
+	
+    SlotsToAllocate = numberSlots;
+    BytesToAllocate = SlotsToAllocate * 2;
+
+    STSYS_WriteTCReg16LE((void*)&TCSessionInfo_p->SessionPIDFilterStartAddr,St20ToTcRamAddress( (u32)TC_Params_p->TC_LookupTableStart + slotOffset * 2, TC_Params_p ));
+    STSYS_WriteTCReg16LE((void*)&TCSessionInfo_p->SessionPIDFilterLength,SlotsToAllocate);
+
+    // *****************************************************************
+    //TcCam_FilterAllocateSession( FullHandle_t DeviceHandle )
+
+    // case STPTI_FILTER_OPERATING_MODE_NONE:
+    /* invalid filter mode i.e. all bits set - TC_SESSION_INFO_FILTER_TYPE_FIELD */
+    STSYS_WriteTCReg16LE((void*)&TCSessionInfo_p->SessionSectionParams,
+                                TC_SESSION_INFO_FILTER_TYPE_FIELD );
+
+    STSYS_SetTCMask16LE ((void*)&TCSessionInfo_p->SessionSectionParams, TC_SESSION_DVB_PACKET_FORMAT );
+
+    STSYS_SetTCMask16LE((void*)&TCSessionInfo_p->SessionSectionParams, TC_SESSION_INFO_FORCECRCSTATE | TC_SESSION_INFO_DISCARDONCRCERROR );
+
+    /* nothing allocated yet, so nothing enabled from our FilterList_p[n] */
+    writel(0, (void*)&TCSessionInfo_p->SectionEnables_0_31);
+    writel(0, (void*)&TCSessionInfo_p->SectionEnables_32_63);
+
+#if defined(SECURE_LITE2)
+    writel(0, (void*)&TCSessionInfo_p->SectionEnables_64_95);
+    writel(0, (void*)&TCSessionInfo_p->SectionEnables_96_127);
+#endif
+    /* --- setup TC RAM CAM configuration --- */
+
+    //STSYS_WriteTCReg16LE((void*)&TCSessionInfo_p->SessionCAMConfig, CAM_CFG_64_FILTERS );
+
+    /* --- setup TC RAM CAM base address --- */
+
+    /* Note: SessionCAMFilterStartAddr is at bit position 7:1 (7 bits) */
+
+    /* point to just past start of reserved area (0x304) */
+//fixme: dies wird nur beim ersten mal gesetzt (siehe if abfrage im original,
+//ansonsten wird was anderes gemacht!)
+    //STSYS_WriteTCReg16LE((void*)&TCSessionInfo_p->SessionCAMFilterStartAddr, (0xC1 << 1) ); /* 0x182 */
+
+    return session;
+    
+}
diff --git a/tdt/cvs/driver/pti/pti_session.h b/tdt/cvs/driver/pti/pti_session.h
new file mode 100644
index 0000000..3156ffc
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_session.h
@@ -0,0 +1,7 @@
+#ifndef pti_session_h_123
+#define pti_session_h_123
+
+int pti_session_init(int tsmerger_tag, int slotOffset, int numberSlots);
+void pti_session_set_source(int index, int tsmerger_tag);
+
+#endif
diff --git a/tdt/cvs/driver/pti/pti_slot.c b/tdt/cvs/driver/pti/pti_slot.c
new file mode 100644
index 0000000..910de80
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_slot.c
@@ -0,0 +1,270 @@
+#include <dvb_demux.h>
+
+#include "pti.h"
+#include "pti_main.h"
+
+/* ************************************
+ * Set a pid to a slot
+ */
+void pti_slot_set_pid(int tc_slot_index, u16 Pid)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    TCMainInfo_t         *MainInfo_p;
+    
+    // *****************************************************************
+    //stptiHAL_SlotSetPid(FullHandle_t SlotHandle, U16 Pid, U16 MapPid)
+
+    if (tc_slot_index < 0)
+    {
+    	printk("%s: invalid slot index passed %d\n", __func__, tc_slot_index);
+	return;
+    }
+
+    MainInfo_p    = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+
+//fixme: wildcard, neg pid, PCR etc wegoptimiert
+
+    STSYS_SetTCMask16LE((void*)&MainInfo_p->SlotState, (SLOT_STATE_INITIAL_SCRAMBLE_STATE) );
+
+    /* Clear the PID */
+    PutTCData( &((u16 *)TC_Params_p->TC_LookupTableStart)[tc_slot_index], 0xe000 /*STPTI_InvalidPid()*/ );
+
+    /* Set the Mapping PID */
+
+//fixme: da ich neg pids und wildcards weg optimiert habe ist dies gleich dem pid
+
+    STSYS_WriteTCReg16LE((void*)&MainInfo_p->RemainingPESLength, Pid);
+
+    /* Set the PID */
+    PutTCData( &((u16 *)TC_Params_p->TC_LookupTableStart)[tc_slot_index], Pid );
+
+}
+
+void pti_slot_clear_pid(int tc_slot_index, int tc_dma_index, int rewind)
+{
+#define TC_ONE_PACKET_TIME 75
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    TCMainInfo_t         *MainInfo_p;
+
+    if (tc_slot_index < 0)
+    {
+    	printk("%s: invalid slot index passed %d\n", __func__, tc_slot_index);
+	return;
+    }
+
+    MainInfo_p    = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+
+    /* Clear the PID */
+    PutTCData( &((u16 *)TC_Params_p->TC_LookupTableStart)[tc_slot_index], 0xe000 /*STPTI_InvalidPid()*/ );
+
+    udelay(TC_ONE_PACKET_TIME);
+
+    /* rewind will be set if clearing the pid, if updating (not implemented)
+     * the it will remain false. tc_dma_index kann kleiner null sein!
+     */
+    if ((rewind == 1) && (tc_dma_index >= 0))
+    {
+	int vLoop;
+	TCDMAConfig_t * DMAConfig_p = &((TCDMAConfig_t *)TC_Params_p->TC_DMAConfigStart)[tc_dma_index];
+
+	/* wait for dma completion */
+    	for ( vLoop = 0; vLoop < 16; vLoop++ )
+    	{
+        	/* if 0 then dma not in progress */
+        	if ( !(readw((void*)&MainInfo_p->SlotState) & TC_MAIN_INFO_SLOT_STATE_DMA_IN_PROGRESS) )
+		    break;
+		    
+    		udelay(TC_ONE_PACKET_TIME);
+    	}
+         
+        printk("QWrite = %x\n", DMAConfig_p->DMAQWrite_p);	        
+	/* now rewind dma */
+	DMAConfig_p->DMAWrite_p = DMAConfig_p->DMAQWrite_p;
+
+    }
+
+    /* Reset Slot Status Word in slot's Main Info */
+    STSYS_WriteTCReg16LE((void*)&MainInfo_p->SlotState, 0 );
+    
+/* fixme: im orig machen sie noch eine Disassoziation des Descramblers 
+    STSYS_WriteTCReg16LE((U32)&MainInfo_p->DescramblerKeys_p,TC_INVALID_LINK);
++ des Indexers stpti_SlotDisassociateIndex
+*/
+
+}
+
+/* **********************************
+ * Get a pid from a slot
+ */
+u16 pti_slot_get_pid(u32 tc_slot_index)
+{
+    u16 Pid;
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    
+    if (tc_slot_index < 0)
+    {
+    	printk("%s: invalid slot index passed %d\n", __func__, tc_slot_index);
+	return -1;
+    }
+
+    GetTCData( &((u16 *)TC_Params_p->TC_LookupTableStart)[tc_slot_index], Pid )
+    
+    return Pid;
+}
+
+/* ************************************
+ * Allocate/Initialise a slot in a session
+ */
+void pti_slot_allocate(u32 tc_slot_index, int dvb_type, int dvb_pes_type)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    int type = TC_SLOT_TYPE_NULL;
+    
+    if (tc_slot_index < 0)
+    {
+    	printk("%s: invalid slot index passed %d\n", __func__, tc_slot_index);
+	return;
+    }
+
+    /* Aus den linuxDVB Params type und pes_type den tc type machen */
+    switch (dvb_type) 
+    {
+ 	 case DMX_TYPE_TS:
+    	    if (dvb_pes_type != DMX_TS_PES_PCR)
+	    	type = TC_SLOT_TYPE_RAW;
+	    else
+	    	type = TC_SLOT_TYPE_NULL;
+    	 break;
+  	 case DMX_TYPE_SEC:
+    	  /*  type = TC_SLOT_TYPE_SECTION;*/
+	  /* fixme: erstmal sec filter nicht behandeln, 
+	   * da wir die filter daten hier nicht
+	   * herbekommen. wir liefern der dvb api
+	   * also die packete und sie soll den rest
+	   * machen
+	   */
+	    type = TC_SLOT_TYPE_RAW;
+    	 break;
+  	 case DMX_TYPE_PES:
+    	    type = TC_SLOT_TYPE_PES;
+    	 break;
+  	 default:
+    	    type = TC_SLOT_TYPE_NULL;
+	 break;
+//FIXME: PCR braucht noch setup des indexers?!
+   }
+
+   // ********************************************************
+   //SlotAllocate ->stptiHAL_SlotInitialise
+
+   {
+    	TCMainInfo_t *MainInfo_p = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+
+   	STSYS_WriteTCReg16LE((void*)&MainInfo_p->SlotState,          0);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->SlotMode,           0);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->DescramblerKeys_p,  TC_INVALID_LINK);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->DMACtrl_indices,    0xffff);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->StartCodeIndexing_p,0);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->SectionPesFilter_p, TC_INVALID_LINK);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->RemainingPESLength, 0);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->PacketCount,        0);
+
+    	STSYS_SetTCMask16LE((void*)&MainInfo_p->SlotMode, type);
+        STSYS_SetTCMask16LE((void*)&MainInfo_p->SlotMode, TC_MAIN_INFO_SLOT_MODE_DISABLE_CC_CHECK);
+	
+
+   }
+    
+}
+
+void pti_slot_link_to_buffer(u32 tc_slot_index, u32 tc_dma_index)
+{
+    u16 DMACtrl_indices;
+    TCMainInfo_t *MainInfo_p;
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    TCDMAConfig_t * DMAConfig_p = &((TCDMAConfig_t *)TC_Params_p->TC_DMAConfigStart)[tc_dma_index];
+
+    if (tc_slot_index < 0)
+    {
+    	printk("%s: invalid slot index passed %d\n", __func__, tc_slot_index);
+	return;
+    }
+
+    if (tc_dma_index < 0)
+    {
+    	printk("%s: invalid dma index passed %d\n", __func__, tc_dma_index);
+	return;
+    }
+
+    //printk("%s (slot %d, dma %d)>\n", __func__, tc_slot_index, tc_dma_index);
+
+    // *******************************************************************************
+    //TcHal_MainInfoAssociateDmaWithSlot( TC_Params_p, SlotIdent, DMAConfig_p );
+    MainInfo_p = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+    DMACtrl_indices  = readl((void*)&MainInfo_p->DMACtrl_indices);
+    DMACtrl_indices &= 0xFF00;            /* mask off main buffer index */
+    DMACtrl_indices |= tc_dma_index & 0x00FF;  /* or in main buffer index */
+    STSYS_WriteTCReg16LE((void*)&MainInfo_p->DMACtrl_indices, DMACtrl_indices);
+
+#if defined(SECURE_LITE2)
+    STSYS_WriteTCReg16LE((void*)&DMAConfig_p->BufferLevelThreshold, 0 );
+#endif
+}
+
+void pti_slot_unlink_buffer(u32 tc_slot_index)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    TCMainInfo_t *MainInfo_p;
+    
+    /* **************************
+     * TcHal_MainInfoUnlinkDmaWithSlot(TC_Params_p, SlotIdent);
+     */
+    if (tc_slot_index < 0)
+    {
+    	printk("%s: invalid slot index passed %d\n", __func__, tc_slot_index);
+	return;
+    }
+
+
+    MainInfo_p = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+
+    STSYS_SetTCMask16LE((void*)&MainInfo_p->DMACtrl_indices, 0xffff);
+}
+
+void pti_slot_free(u32 tc_slot_index)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    int type = TC_SLOT_TYPE_NULL;
+    
+   /* dont trust user so invalidate pid ;-) */
+   PutTCData( &((u16 *)TC_Params_p->TC_LookupTableStart)[tc_slot_index], 0xe000);
+
+   /* stptiHelper_WaitPacketTimeDeschedule */
+   udelay(320);
+    
+   {
+    	TCMainInfo_t *MainInfo_p = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+
+   	STSYS_WriteTCReg16LE((void*)&MainInfo_p->SlotState,          0);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->SlotMode,           0);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->DescramblerKeys_p,  TC_INVALID_LINK);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->DMACtrl_indices,    0xffff);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->StartCodeIndexing_p,0);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->SectionPesFilter_p, TC_INVALID_LINK);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->RemainingPESLength, 0);
+	STSYS_WriteTCReg16LE((void*)&MainInfo_p->PacketCount,        0);
+
+    	STSYS_SetTCMask16LE((void*)&MainInfo_p->SlotMode, type );
+
+   }
+
+}
+
+int pti_slot_get_state(u32 tc_slot_index)
+{
+    STPTI_TCParameters_t* TC_Params_p = &tc_params;
+    
+    TCMainInfo_t *MainInfo_p = &((TCMainInfo_t *)TC_Params_p->TC_MainInfoStart)[tc_slot_index];
+
+    return MainInfo_p->SlotState;
+}
diff --git a/tdt/cvs/driver/pti/pti_slot.h b/tdt/cvs/driver/pti/pti_slot.h
new file mode 100644
index 0000000..635a1eb
--- /dev/null
+++ b/tdt/cvs/driver/pti/pti_slot.h
@@ -0,0 +1,15 @@
+#ifndef pti_slot_h_123
+#define pti_slot_h_123
+
+void pti_slot_allocate(u32 tc_slot_index, int dvb_type, int dvb_pes_type);
+
+u16 pti_slot_get_pid(u32 tc_slot_index, u16 Pid);
+void pti_slot_set_pid(u32 tc_slot_index, u16 Pid);
+void pti_slot_clear_pid(int tc_slot_index, int tc_dma_index, int rewind);
+
+void pti_slot_link_to_buffer(u32 tc_slot_index, u32 tc_dma_index);
+void pti_slot_unlink_buffer(u32 tc_slot_index);
+
+void pti_slot_free(u32 tc_slot_index);
+int pti_slot_get_state(u32 tc_slot_index);
+#endif
diff --git a/tdt/cvs/driver/pti/tc_code.h b/tdt/cvs/driver/pti/tc_code.h
index 0ccfc2a..d97c317 100644
--- a/tdt/cvs/driver/pti/tc_code.h
+++ b/tdt/cvs/driver/pti/tc_code.h
@@ -1,114 +1,1232 @@
 /************************************************************************
-COPYRIGHT (C) ST Microelectronics (R&D) 2005
+COPYRIGHT (C) ST Microelectronics (R&D) 2008
+All rights reserved.
 
-Source file name : tccode.h
 Author :           Automatically generated file
 
 Contains the transport controller code packed as a word array
 
 ************************************************************************/
 
+#include "pti.h"
 
-#define TRANSPORT_CONTROLLER_CODE_SIZE      103
-#define TRANSPORT_CONTROLLER_LABLE_MAP_SIZE 35
 
-static char const VERSION[] = "\nTC Version " __FILE__ " 0.0.0\n";
+#if (defined(UFS912) || defined(ATEVIO7500) )&& defined(SECURE_LITE2) && defined(A18)
+
+/* LDRsL3 */
+#warning secure lite 2 for ufs912
+
+#define TC_ID 31
+#define TC_DVB 1
+#define TC_PTI4_SECURELITE 2
+#define TC_WATCH_AND_RECORD_CLEAR_PAYLOAD 1
+#define TC_HARDWARE_START_CODE_DETECTION 1
+#define TC_CAROUSEL_SUPPORT 1
+#define TC_CAROUSEL_DESIGN_VERSION_2 1
+#define TC_WATCH_AND_RECORD_SUPPORT 1
+#define TC_AES_DESCRAMBLE_SUPPORT 1
+#define TC_MULTI2_DESCRAMBLE_SUPPORT 1
+#define TC_SP_OVERLAY_SUPPORT 1
+#define TC_TSDEBUG_SUPPORT 1
+#define TC_PROFILING 1
+
+#define TRANSPORT_CONTROLLER_CODE_SIZE      3042
+
+static char const VERSION[] = "\nTC Version STPTI_DVBTCLoaderSL3 \n\tRel: 2051. File: DVBTC4 Version: 0\n \n\tRel: 2051. File: TCINIT Version: 0\n \n\tRel: 2051. File: TS_HEADER Version: 0\n \n\tRel: 2051. File: SETUPDMA Version: 0\n \n\tRel: 2051. File: AF_ALTOUT Version: 0\n \n\tRel: 2051. File: AF_PROC Version: 0\n \n\tRel: 2051. File: CC_PROC Version: 0\n \n\tRel: 2051. File: SLT_SWIT Version: 0\n \n\tRel: 2051. File: ECMEMM Version: 0\n \n\tRel: 2051. File: RAW_PROC Version: 0\n \n\tRel: 2051. File: PES_PROC Version: 0\n \n\tRel: 2051. File: CAR_PROC Version: 0\n \n\tRel: 2051. File: RAMCAM_PROC Version: 0\n \n\tRel: 2051. File: DMA_UNLD Version: 0\n \n\tRel: 2051. File: SIG_DEC Version: 0\n \n\tRel: 2051. File: STAT_BLK Version: 0\n \n\tRel: 2051. File: STREAMID Version: 0\n \n\tRel: 2051. File: ERR_PROC Version: 0\n \n\tRel: 2051. File: COMMON Version: 0\n \n\tRel: 2051. File: TCDMA Version: 0\n \n\tRel: 2051. File: SET_SCRAM Version: 0\n";
 
 
 #define TRANSPORT_CONTROLLER_VERSION    2
 
-#ifdef TCASM_LM_SUPPORT
-
-#define TCASM_LM_CODE   (0)
-#define TCASM_LM_DATA   (1)
-#define TCASM_LM_CONST  (2)
-#define TCASM_LM_UNKOWN (-1)
-
-typedef struct TCASM_LM_s
-{
-    char           *Name;
-    unsigned short  Value;
-    unsigned short  Segment;
-    unsigned char*  File;
-    unsigned short  Line;
-}TCASM_LM_t;
-
-static TCASM_LM_t TCASM_LableMap[] =
-{
-    {"::__end_of_code__", 408, TCASM_LM_CODE, "<unknown>", 1 },
-    {"::__css__", 0, TCASM_LM_CONST, "<unknown>", 1 },
-    {"::__dss__", 32768, TCASM_LM_CONST, "<unknown>", 1 },
-    {"::__StackPointer", 32768, TCASM_LM_DATA, "/tmp/lcc321201.asm", 3 },
-    {"::_program_entry_point", 0, TCASM_LM_CODE, "/tmp/lcc321201.asm", 7 },
-    {"::_main", 8, TCASM_LM_CODE, "pti_firmware.c", 24 },
-    {"::_packet_size", 32772, TCASM_LM_DATA, "pti_firmware.c", 1 },
-    {"::_thrown_away", 32774, TCASM_LM_DATA, "pti_firmware.c", 3 },
-    {"::_header_size", 32776, TCASM_LM_DATA, "pti_firmware.c", 5 },
-    {"::_10", 32778, TCASM_LM_DATA, "pti_firmware.c", 7 },
-    {"::_11", 32778, TCASM_LM_DATA, "pti_firmware.c", 8 },
-    {"::_22", 32778, TCASM_LM_DATA, "pti_firmware.c", 9 },
-    {"::_25", 32778, TCASM_LM_DATA, "pti_firmware.c", 10 },
-    {"::_26", 32778, TCASM_LM_DATA, "pti_firmware.c", 11 },
-    {"::_pidsearch", 32954, TCASM_LM_DATA, "pti_firmware.c", 237 },
-    {"::_pidtable", 32826, TCASM_LM_DATA, "pti_firmware.c", 172 },
-    {"::_2", 24, TCASM_LM_CODE, "pti_firmware.c", 35 },
-    {"::_pread", 32818, TCASM_LM_DATA, "pti_firmware.c", 166 },
-    {"::_5", 64, TCASM_LM_CODE, "pti_firmware.c", 43 },
-    {"::_pwrite", 32958, TCASM_LM_DATA, "pti_firmware.c", 240 },
-    {"::_7", 72, TCASM_LM_CODE, "pti_firmware.c", 47 },
-    {"::_8", 72, TCASM_LM_CODE, "pti_firmware.c", 47 },
-    {"::_num_pids", 32810, TCASM_LM_DATA, "pti_firmware.c", 160 },
-    {"::_buffer", 32778, TCASM_LM_DATA, "pti_firmware.c", 143 },
-    {"::_12", 228, TCASM_LM_CODE, "pti_firmware.c", 94 },
-    {"::_14", 188, TCASM_LM_CODE, "pti_firmware.c", 91 },
-    {"::_15", 188, TCASM_LM_CODE, "pti_firmware.c", 91 },
-    {"::_17", 228, TCASM_LM_CODE, "pti_firmware.c", 94 },
-    {"::_21", 272, TCASM_LM_CODE, "pti_firmware.c", 107 },
-    {"::_psize", 32814, TCASM_LM_DATA, "pti_firmware.c", 163 },
-    {"::_19", 332, TCASM_LM_CODE, "pti_firmware.c", 112 },
-    {"::_20", 392, TCASM_LM_CODE, "pti_firmware.c", 133 },
-    {"::_discard", 32822, TCASM_LM_DATA, "pti_firmware.c", 169 },
-    {"::_3", 392, TCASM_LM_CODE, "pti_firmware.c", 137 },
-    {"::_1", 408, TCASM_LM_CODE, "pti_firmware.c", 141 },
-};
 
-#endif
+static const unsigned int transport_controller_code[] = {
+	0x2c000040, 0x40003f80, 0x40009f00, 0x2facbc04, 0x2c8001c0, 0x40214888, 
+	0x2c800000, 0x40002108, 0x40003888, 0x40214b88, 0x2d000fc0, 0x40002d10, 
+	0x2d200000, 0x40002010, 0x2d001800, 0x40002090, 0x2c000000, 0x4000cb00, 
+	0x4000c100, 0x2c000200, 0x40008400, 0x40008480, 0x2c008840, 0x4000a000, 
+	0x4000a080, 0x50003880, 0x50003880, 0x50802100, 0x5100c100, 0x20400040, 
+	0x20400080, 0x88001900, 0x2c000040, 0x4000a100, 0x4000a180, 0x2f002504, 
+	0xc00a0e00, 0x2c000000, 0x4000cb00, 0x2c000040, 0x4000c100, 0x40008600, 
+	0x40008680, 0x2c000000, 0x40214a00, 0x40214b00, 0x40214c80, 0x40214600, 
+	0x40046100, 0x4000cf00, 0x2e215800, 0xe0000100, 0x44400500, 0x120001a0, 
+	0xe0000240, 0x44400500, 0x40214500, 0x40214580, 0x4000c900, 0x40206f00, 
+	0x2ca06a00, 0xe0000280, 0x44400440, 0x2c800000, 0x10800048, 0x08800008, 
+	0x5000c100, 0x24400000, 0x88004000, 0x50214b80, 0x00800048, 0x88004c00, 
+	0x10000040, 0x00800400, 0x98005300, 0x2c0003c0, 0x30000040, 0x102cb100, 
+	0x50c00000, 0x10800048, 0x08800008, 0x40400008, 0x2c000000, 0x40214b80, 
+	0x50a14700, 0x50214780, 0x10800048, 0x18000000, 0x40214708, 0x40214780, 
+	0x51a15104, 0x25c000db, 0x80007600, 0x2f005f04, 0xc00ab000, 0x51a15180, 
+	0x2f006204, 0xc0098300, 0xe04000c0, 0x2fc00180, 0x2f006604, 0xc00aeb00, 
+	0x25800098, 0x80006d00, 0x2f006a04, 0xc00ac600, 0x2d800000, 0x40215118, 
+	0xc0002000, 0x51808200, 0x51808200, 0x52808280, 0x52808280, 0x484010da, 
+	0x484014ea, 0x484020da, 0x484024ea, 0xc0002000, 0x2c203800, 0x40206980, 
+	0x2cac3b04, 0x50ac3e80, 0x2483ffc8, 0x00002008, 0x80008b00, 0x51a15000, 
+	0x24004018, 0x80086e00, 0x25003fd8, 0x2e000140, 0x2cac3b04, 0x58c01c42, 
+	0x2403ffc8, 0x28400080, 0x80008b00, 0x1080160d, 0x02000060, 0x88008300, 
+	0xc0086e00, 0x2d800040, 0x2f008e04, 0xc0098300, 0x2d400180, 0x2e000140, 
+	0x2e800140, 0x02c00128, 0x40215328, 0x40214990, 0x2e002e80, 0x5ac01842, 
+	0x26800428, 0x88009900, 0x2e002040, 0x58404c42, 0x24400000, 0x8000a600, 
+	0x50a15000, 0x25804008, 0x8000a200, 0x24803fc8, 0x01c00050, 0x8000a600, 
+	0x26c00168, 0x8000a600, 0x298011d0, 0x88002000, 0x10c00100, 0x40001008, 
+	0x11800040, 0x2f00ab04, 0xc0098300, 0xe0400000, 0x2d400180, 0x31000210, 
+	0x21400190, 0x40214310, 0x40214a90, 0x58400042, 0x10000040, 0x48400042, 
+	0x26800428, 0x8800b700, 0xc0002000, 0x2c380000, 0x2487ffd0, 0x2f00bb04, 
+	0xc0091f00, 0x51214300, 0x24200010, 0x88088f00, 0x51a14600, 0x258003d8, 
+	0x01800058, 0x8800c800, 0x2d801100, 0x40003798, 0x2d800040, 0x40003898, 
+	0x2d800000, 0x40003898, 0x2d800040, 0x2f00cb04, 0xc0098300, 0x24100010, 
+	0x8000d000, 0x50215880, 0x20008000, 0x40215880, 0x2d400180, 0x40214390, 
+	0x52214580, 0x24000220, 0x8800dc00, 0x50214600, 0x24004000, 0x8000e000, 
+	0x22000220, 0x402145a0, 0x26000060, 0x8800e000, 0x51214680, 0x293c0010, 
+	0x8004fa00, 0xc000e000, 0x5a402802, 0x240000e0, 0x80017900, 0x31800620, 
+	0x25801fd8, 0x30000118, 0x318000d8, 0x11c00018, 0x11a16618, 0x240000a0, 
+	0x8000ee00, 0x40215498, 0x40215401, 0xc0010900, 0x40215418, 0x40215481, 
+	0x24000320, 0x8000f500, 0x24000120, 0x8800f800, 0xc000f900, 0x24003c20, 
+	0x80010800, 0xc0010100, 0xc0010800, 0x24003c20, 0x80010800, 0x24000420, 
+	0x88010700, 0x263fc3e0, 0x22000420, 0x48402822, 0xc0010700, 0x263fc3e0, 
+	0x48402822, 0x50215400, 0x5a402800, 0x263fc3e0, 0x48402820, 0xc0002000, 
+	0xc0017900, 0x24000320, 0x80010e00, 0x24000120, 0x88011400, 0xc0011500, 
+	0x24003c20, 0x80012200, 0x51a15800, 0x21808018, 0x40215818, 0xc0078800, 
+	0xc0012a00, 0x50215480, 0x59c02800, 0x26003c18, 0x80011e00, 0x26000418, 
+	0x88011e00, 0x25bfc3d8, 0x48402818, 0xc0012a00, 0x25bfc3d8, 0x21800818, 
+	0x48402818, 0xc0012a00, 0x263fc3e0, 0x22000820, 0x48402822, 0x50215480, 
+	0x5a402800, 0x263fc3e0, 0x22000420, 0x48402820, 0x5a402802, 0x32000620, 
+	0x26001fe0, 0x32000060, 0x5ac01042, 0x12400160, 0x52c00100, 0x2687ffe8, 
+	0x52214300, 0x26380020, 0x22400160, 0x40214320, 0x40214aa0, 0x52214380, 
+	0x24000420, 0x80015100, 0x260003e0, 0x58400802, 0x24020000, 0x88015100, 
+	0x58400002, 0x26820000, 0x80015100, 0x32800700, 0x12800068, 0x268003e8, 
+	0x28400128, 0x80015100, 0x2c040000, 0x51a15800, 0x21c00018, 0x40215818, 
+	0x51a15980, 0x25be01d8, 0x300001e0, 0x21c00018, 0x328000e8, 0x21c00158, 
+	0x40215998, 0x58400002, 0x243dc3c0, 0x20020000, 0x32000120, 0x20400100, 
+	0x48400002, 0x50215480, 0x5ac00000, 0x32800728, 0x12800068, 0x268003e8, 
+	0x50214380, 0x243ffc00, 0x20400140, 0x40214380, 0x50215480, 0x5ac01000, 
+	0x24bfc028, 0x2a3fc008, 0x80016800, 0x32000748, 0x1223a620, 0x40214c20, 
+	0x24803fe8, 0x2a003fc8, 0x80016e00, 0x32000148, 0x1223a620, 0x402146a0, 
+	0x58c03100, 0x40214808, 0x58c00800, 0x40214608, 0x248003c8, 0x288000c8, 
+	0x88017700, 0x2c800040, 0x40214588, 0x58c00000, 0x2c400004, 0x2d800000, 
+	0x40214b18, 0x40046018, 0x50214600, 0x258003c0, 0x25000c00, 0x88018200, 
+	0x25c000d8, 0x8001b900, 0x25801000, 0x8801ab00, 0x50214380, 0x25002000, 
+	0x8001ab00, 0x24afffc8, 0x51a15980, 0x21800118, 0x24001000, 0x88019100, 
+	0x25000048, 0x80019800, 0x25bfff98, 0x24bfff88, 0xc0019500, 0x25000048, 
+	0x88019800, 0x21800058, 0x20800048, 0x51215880, 0x21010010, 0x40215890, 
+	0x40215998, 0x25000108, 0x8801a000, 0x20800108, 0x51a15880, 0x21810018, 
+	0x40215898, 0x20800088, 0x59400c02, 0x29bc0010, 0x880b2100, 0x51a14600, 
+	0x258003d8, 0x018000d8, 0x8001b900, 0x51a14380, 0x25800418, 0x8001b900, 
+	0xc008c000, 0x25900008, 0x8801b100, 0x25800108, 0x8001b900, 0x25800088, 
+	0x8001b900, 0x24afffc8, 0x24bffe08, 0x51a15980, 0x25bffed8, 0x40215998, 
+	0x51a15880, 0x21810018, 0x40215898, 0x51214580, 0x26800210, 0x8801bf00, 
+	0x51214600, 0x268003d0, 0x8001cb00, 0x51a14680, 0x40215b98, 0x293c0018, 
+	0x8001cb00, 0x594010c0, 0x40215f10, 0x594014c0, 0x40215f90, 0x2f01c904, 
+	0xc00ab000, 0x2f01cb04, 0xc00ab700, 0x51214580, 0x25800210, 0x8001d000, 
+	0x25800050, 0x8004fa00, 0x51a14600, 0x25800c18, 0x8801d600, 0x2d000000, 
+	0x4000c910, 0xc001e300, 0x2d0000c0, 0x4000c910, 0x2d000400, 0x4000c810, 
+	0x2d0011c0, 0x4000ca10, 0x2d000000, 0x4000c810, 0x51214300, 0x31000610, 
+	0x4000ca10, 0x51214300, 0x4000ca10, 0x52214380, 0x25002020, 0x80021100, 
+	0x59400c02, 0x2abc0010, 0x80020000, 0x51400080, 0x26801020, 0x8801ef00, 
+	0x26800050, 0x80020000, 0xc001f100, 0x25000090, 0x80020000, 0x51214600, 
+	0x26800810, 0x8001f900, 0x253fcfe0, 0x4000ca10, 0x2c000040, 0x4000c900, 
+	0xc0021800, 0x258003d0, 0x018000d8, 0x88021100, 0x25001010, 0x88021100, 
+	0x253fcfe0, 0xc0021800, 0x25c000d8, 0x80020b00, 0x51214380, 0x4000ca10, 
+	0x2d000040, 0x4000c910, 0x51214600, 0x258003d0, 0x018000d8, 0x80021100, 
+	0xc008c600, 0x51214600, 0x258003d0, 0x80021100, 0x018000d8, 0x80021100, 
+	0xc0021100, 0x51214380, 0x51a14600, 0x25800c18, 0x80021800, 0x4000ca10, 
+	0x2c000040, 0x4000c900, 0x50214580, 0x24000040, 0x88021e00, 0x50214c00, 
+	0x283c0000, 0x80026100, 0x59c02402, 0x31800598, 0x28000558, 0x88023700, 
+	0x50214380, 0x24002000, 0x80026100, 0x50214600, 0x24001000, 0x88026100, 
+	0x58400c02, 0x2a3c0000, 0x80026100, 0x52214380, 0x253fcfe0, 0x50214c00, 
+	0x283c0000, 0x80026100, 0x58402402, 0x24008000, 0x80026100, 0x50203880, 
+	0x240fffc0, 0x40203880, 0xc0026100, 0x51214380, 0x24003010, 0x80024b00, 
+	0x30000690, 0x00000080, 0x80024600, 0x30000690, 0x000000c0, 0x80024100, 
+	0xc0026100, 0x253fcfd0, 0x25800318, 0x31800118, 0x214000d0, 0xc0024f00, 
+	0x253fcfd0, 0x25800c18, 0x31800098, 0x214000d0, 0xc0024f00, 0x253fcfd0, 
+	0x258000d8, 0x31800198, 0x214000d0, 0x50214c00, 0x283c0000, 0x80026100, 
+	0x50214380, 0x24002000, 0x80025b00, 0x50203880, 0x24003fc0, 0x32000210, 
+	0x20400100, 0x40203880, 0xc0026100, 0x50203900, 0x243fc000, 0x2e400080, 
+	0x26003fe0, 0x20400100, 0x40203900, 0x24000c10, 0x8008dc00, 0x50214580, 
+	0x24000040, 0x80027b00, 0x5a401802, 0x26000060, 0x80026b00, 0x2f026b04, 
+	0xc00a1a00, 0x52215000, 0x25804020, 0x80027000, 0x25803fe0, 0xc0027100, 
+	0x2d8011c0, 0x2fc000c0, 0x5a401802, 0x260000a0, 0x80027700, 0x2f027704, 
+	0xc00a3c00, 0x52214300, 0x33800620, 0x2fc00100, 0x2fc00080, 0x25000810, 
+	0x88027e00, 0xc002ba00, 0x2d800040, 0x2f028104, 0xc0098300, 0x2dc00180, 
+	0x24000040, 0x80028500, 0x2fc000c0, 0x52a14380, 0x26800428, 0x88028a00, 
+	0x2d802dc0, 0xc0028f00, 0x02802dd8, 0x9008dc00, 0x26c000d8, 0x88028f00, 
+	0xc002ba00, 0x2f029104, 0xc0098300, 0x2d400180, 0x24000040, 0x80029500, 
+	0x2fc00080, 0x01800058, 0x52a15880, 0x26bfc028, 0x22c000a8, 0x402158a8, 
+	0x26800410, 0x8002b000, 0x02800198, 0x9802b000, 0x32800230, 0x22c001a8, 
+	0x40215c28, 0x31000230, 0x21400190, 0x40215c90, 0x32000230, 0x224001a0, 
+	0x40215d20, 0x24000040, 0x8002af00, 0x33800628, 0x2fc00140, 0x33800610, 
+	0x2fc00080, 0x33800620, 0x2fc00100, 0x01800198, 0x24000040, 0x8002b500, 
+	0xe04000c0, 0x2fc00180, 0xc002ba00, 0xe04000c0, 0x2c400180, 0x52214380, 
+	0x26000420, 0x8002f400, 0x51a14600, 0x25820018, 0x8802f400, 0x51a14380, 
+	0x25800418, 0x8002f400, 0x51215880, 0x26820008, 0x8802c900, 0x25008010, 
+	0x8802ee00, 0x51214580, 0x25000050, 0x8802ee00, 0xc0091000, 0x24002010, 
+	0x8002cd00, 0x25000410, 0x8002ee00, 0x50214380, 0x260003c0, 0x26803c08, 
+	0x32800728, 0x28400160, 0x8802dc00, 0x51214580, 0x25000050, 0x8802ee00, 
+	0x25000208, 0x8802da00, 0x20800208, 0xc0078800, 0x24bffdc8, 0xc008bd00, 
+	0x24bffdc8, 0x12800068, 0x268003e8, 0x28400160, 0x8002ee00, 0x51a15980, 
+	0x25be01d8, 0x320001e0, 0x21c00118, 0x328000e8, 0x21c00158, 0x40215998, 
+	0x51a14580, 0x25800058, 0x8008bd00, 0x51a15800, 0x21800418, 0x40215818, 
+	0x50214380, 0x260003c0, 0x32000120, 0x24bfc3c8, 0x20c00108, 0x20820008, 
+	0x51a14680, 0x29bc0018, 0x88030600, 0x51a14c00, 0x29bc0018, 0x8008c000, 
+	0x2f02fc04, 0xc009b100, 0x50001000, 0x51a14b00, 0x21c000c0, 0x2f030104, 
+	0xc0098300, 0xe0400000, 0x2dc00180, 0x2f030504, 0xc009d300, 0xc0078800, 
+	0x50214600, 0x258003c0, 0x25000c00, 0x88030c00, 0x25c000d8, 0x80078800, 
+	0x51214600, 0x25000c10, 0x80031100, 0x2e000040, 0x4000c920, 0x50001000, 
+	0x51a14600, 0x258003d8, 0x88031b00, 0x21880000, 0x2f031804, 0xc0098300, 
+	0xe0400000, 0x2dc00180, 0xc0078800, 0x010000d8, 0x80037e00, 0x24400000, 
+	0x80070d00, 0x01000098, 0x80038e00, 0x01000058, 0x8005c000, 0xc0078800, 
+	0x29002e00, 0x8808dc00, 0x25810008, 0x80078800, 0x5a401806, 0x2b3c0025, 
+	0x80078800, 0x50215880, 0x24008000, 0x88033100, 0x25c00127, 0x88036600, 
+	0xc0078800, 0x25c00127, 0x80033800, 0x51a14680, 0x50000400, 0x40000200, 
+	0x50000480, 0x40000280, 0x2d900100, 0x2f033b04, 0xc0098300, 0x2c400180, 
+	0x2c400180, 0x31800234, 0x21c0019d, 0x2583ffd9, 0x80078800, 0x2b3c0025, 
+	0x80078800, 0x5a401c06, 0x26400021, 0x5ac00c06, 0x2a400129, 0x26003fe0, 
+	0x88078800, 0x2e800040, 0x26000040, 0x88034f00, 0x25800088, 0x80035200, 
+	0xc0035800, 0x25800048, 0x80035500, 0xc0035800, 0x20800088, 0x24bfff88, 
+	0xc0035700, 0x20800048, 0x24bfff48, 0x2e800080, 0x2d900040, 0x2f035b04, 
+	0xc0098300, 0x32000230, 0x20400100, 0x2a0000a8, 0x88078800, 0xe0000400, 
+	0x2f800000, 0x2fc00000, 0x33800619, 0x2fc000c2, 0x33800600, 0x0180005d, 
+	0x2583ffdd, 0x51801000, 0x21900018, 0x2f036b04, 0xc0098300, 0x01900018, 
+	0x2d4000c2, 0x004000da, 0x90037100, 0x2d4000c0, 0x2c000000, 0xe0400080, 
+	0x2fc00180, 0xe0400000, 0x2f400184, 0x01c000dd, 0x90037800, 0x2d800004, 
+	0x4840181b, 0x21c000df, 0x88070d00, 0x2f800000, 0xc0038800, 0xc0078800, 
+	0x2f038004, 0xc009b100, 0x51a14b00, 0x21c000c0, 0x2f038404, 0xc0098300, 
+	0xe0400000, 0x2fc00180, 0x2f038804, 0xc009d300, 0x2d800040, 0x40214518, 
+	0x51a14580, 0x25800218, 0x8804fa00, 0xc0070d00, 0x2f039004, 0xc009b100, 
+	0x51008204, 0x51008204, 0x250000d5, 0x268000c0, 0x114000ae, 0x250000d5, 
+	0x52a15880, 0x24008028, 0x8003c000, 0x25018008, 0x01818010, 0x8003a500, 
+	0x01810010, 0x9803cb00, 0x51a15800, 0x21802018, 0x40215818, 0x24be7fc8, 
+	0x2f03a404, 0xc00b0300, 0xc003cb00, 0x51a14800, 0x52a14680, 0x25000418, 
+	0x8803b300, 0x59c02140, 0x59402540, 0x2fc000c0, 0x33800618, 0x2fc00080, 
+	0x33800610, 0x2f03b104, 0xc00aeb00, 0x25800098, 0x8808d400, 0x2d800040, 
+	0x40214518, 0x51008200, 0x51008200, 0x50008280, 0x50008280, 0x40214410, 
+	0x40214480, 0x48402150, 0x48402540, 0x40008210, 0x40008280, 0xc003cb00, 
+	0x24018008, 0x80078800, 0x2e000000, 0x2f03c504, 0xc004ef00, 0x2e800000, 
+	0x01018000, 0x80048200, 0x01010000, 0x80048200, 0xc0045300, 0x52801000, 
+	0x01000268, 0x9003d200, 0x2dc00140, 0x2f03d104, 0xc0098300, 0xc008cb00, 
+	0x2e001000, 0x2f03d504, 0xc004ef00, 0x258001c8, 0x25800098, 0x8803db00, 
+	0x2e800240, 0x2c400140, 0xc003dd00, 0x50214b00, 0x20400140, 0x2dc00000, 
+	0x2f03e004, 0xc0098300, 0x028000a8, 0x30000230, 0x20400180, 0x8808cb00, 
+	0x02800068, 0x2c400180, 0x00000040, 0x8808cb00, 0x2f800000, 0x2f800000, 
+	0x2f800040, 0x02800068, 0x2c400180, 0x48402002, 0x2fc00000, 0x59c01802, 
+	0x25004018, 0x8003f500, 0x25803fd8, 0x29c00018, 0x8808cb00, 0x028000a8, 
+	0x31000230, 0x21400190, 0x48401c12, 0x25400090, 0x8003ff00, 0x9803ff00, 
+	0x51801000, 0x01c000d0, 0x9808cb00, 0x33800610, 0x2fc00080, 0x29802f00, 
+	0x80041100, 0x29802fc0, 0x80041100, 0x29803c00, 0x80041100, 0x29803c40, 
+	0x80041100, 0x29803fc0, 0x80041100, 0x29803c80, 0x80041100, 0x29803e00, 
+	0x80041100, 0x29802f80, 0x88041d00, 0xe0400140, 0x2fc00180, 0x2e800000, 
+	0x253e7fc8, 0x20818010, 0x59c01c02, 0x01800298, 0x48401c1a, 0x50001000, 
+	0x24400000, 0x8004d100, 0xc004a300, 0x2c400180, 0x02800068, 0x25800800, 
+	0x80043d00, 0x51a14600, 0x25801018, 0x88043d00, 0x25800108, 0x88042e00, 
+	0x20800108, 0x24bfff48, 0x51a15880, 0x21810018, 0x40215898, 0x51a15980, 
+	0x21800118, 0x40215998, 0x5a400c02, 0x29bc0020, 0x8008c600, 0x25800400, 
+	0x88043800, 0x52400100, 0x26004020, 0x8008c600, 0x24bfff88, 0xc0044500, 
+	0x52400100, 0x26008020, 0x8008c600, 0x20800048, 0xc0044500, 0x25800108, 
+	0x80044500, 0x25800088, 0x88044500, 0x24bffe08, 0x51a15880, 0x21810018, 
+	0x40215898, 0x2fc00000, 0x028000a8, 0x2fc00180, 0x2c400180, 0x2fc00000, 
+	0x48402002, 0x24400000, 0x80047500, 0x59401c02, 0x25400090, 0x80045200, 
+	0x01400010, 0x48401c12, 0x20808008, 0x58402002, 0x51001000, 0x25400090, 
+	0x8004d700, 0x01c00010, 0x90045a00, 0x2c400080, 0x26000088, 0x80046400, 
+	0x26c00168, 0x88046a00, 0x2ec00080, 0x2dc00080, 0x21880018, 0x2f046304, 
+	0xc0098300, 0xc0046a00, 0x26c00168, 0x8808cb00, 0x2ec00000, 0x2dc00000, 
+	0x2f046a04, 0xc0098300, 0x59402002, 0x01400010, 0x48402012, 0xe0400000, 
+	0x2fc00180, 0x02c00028, 0x25400090, 0x80047500, 0x26c00168, 0x8808cb00, 
+	0xc004d700, 0x58401c02, 0x24400000, 0x80047d00, 0x000000c0, 0x48401c02, 
+	0x253e7fc8, 0x20810010, 0xc0047f00, 0x253e7fc8, 0x20818010, 0x51001000, 
+	0x25400090, 0x8004d700, 0x240001c8, 0x25000100, 0x80049f00, 0x25000080, 
+	0x88049f00, 0x59c00c02, 0x293c0018, 0x8008c000, 0x25000040, 0x80049100, 
+	0x514000c0, 0x25008010, 0x8008c600, 0x12000318, 0xc0049500, 0x514000c0, 
+	0x25008010, 0x8008c600, 0x12000118, 0x55400500, 0x54400500, 0x40044410, 
+	0x40044480, 0x55400500, 0x54400500, 0x40044510, 0x40044580, 0x2c080000, 
+	0x40214b00, 0x50001000, 0x59c01c02, 0x00400018, 0x48401c02, 0x26c00168, 
+	0x8804aa00, 0x51a14b00, 0x52801000, 0x21c00158, 0x2f04aa04, 0xc0098300, 
+	0x25400097, 0x8804b100, 0xe0400140, 0x2fc00180, 0x2e800000, 0xc004d100, 
+	0x2d400144, 0x01c000aa, 0x9804b000, 0xe04000c0, 0x2fc00180, 0x2f04b704, 
+	0xc00aeb00, 0x25800098, 0x8808d400, 0x52808200, 0x52808200, 0x51808280, 
+	0x51808280, 0x40008228, 0x40008298, 0x298000d1, 0x8804ce00, 0x01000095, 
+	0x2fc00180, 0x2fc00180, 0x2f04c604, 0xc00aeb00, 0x25800098, 0x8808d400, 
+	0x52808200, 0x52808200, 0x51808280, 0x51808280, 0x40008228, 0x40008298, 
+	0x2e800000, 0xe0400082, 0x2fc00180, 0x24018008, 0x00018000, 0x8004d700, 
+	0x58401c02, 0x24400000, 0x8004dd00, 0x50214800, 0x24000100, 0x8804de00, 
+	0x2f04dc04, 0xc009d300, 0xc0070d00, 0x24be7fc8, 0x2f04e004, 0xc009d300, 
+	0x51a14500, 0x11800058, 0x40214518, 0x51a14800, 0x25000418, 0x8804ed00, 
+	0x51a14680, 0x594020c0, 0x59c024c0, 0x2fc00080, 0x33800610, 0x2fc000c0, 
+	0x33800618, 0x2c000040, 0xc0070e00, 0x51214800, 0x25000110, 0x8004f900, 
+	0x52a15880, 0x26802028, 0x22c00128, 0x26003c08, 0x32000720, 0x23c00160, 
+	0x53801000, 0xc0400182, 0x52a07204, 0x26800069, 0x88050100, 0x52a14580, 
+	0x26800068, 0x88070d00, 0xc0002000, 0x268000a9, 0x88002000, 0x52215900, 
+	0x263fc020, 0x2e800004, 0x2d207404, 0x2abfc020, 0x88051600, 0x52a07284, 
+	0x2e000004, 0x2ac00163, 0x80051000, 0x12000065, 0x11000515, 0xc0050b00, 
+	0x2a8000a9, 0x88051400, 0x2e000004, 0xc0051500, 0x1200006d, 0x402072a1, 
+	0x2c000000, 0x51400082, 0x26800210, 0x88052800, 0x22800210, 0x404000aa, 
+	0x26800410, 0x80052700, 0x5ac00482, 0x2ac00128, 0x88052700, 0x2a3fc02c, 
+	0x88053200, 0x260001d4, 0x51a15304, 0x29c0011f, 0x80053200, 0x40400092, 
+	0x11000515, 0x1280006d, 0x2a8000e9, 0x88051700, 0x10000040, 0x2a800080, 
+	0x8005b900, 0x2e800004, 0x2d207404, 0xc0051700, 0x22400162, 0x40207320, 
+	0x26801010, 0x80055b00, 0x5a401c46, 0x26200025, 0x80054300, 0x5a404846, 
+	0x320005a5, 0x5ac04446, 0x318001ad, 0x224000e7, 0x328005ad, 0x59c04046, 
+	0x3180019d, 0x21c0015f, 0xc0054500, 0x59c04046, 0x5a404446, 0x5a401882, 
+	0x01c00119, 0x84055900, 0x29c00119, 0x88054d00, 0x5ac01482, 0x01c00161, 
+	0x84055900, 0x5a402082, 0x01c00119, 0x84055b00, 0x29c00119, 0x88055700, 
+	0x5ac01c82, 0x01c00161, 0x84055b00, 0x29c00161, 0x80055b00, 0x2e8000c0, 
+	0xc005a800, 0x40400092, 0xc0002000, 0x52a07200, 0x26800128, 0x80056200, 
+	0x4020b291, 0x2f056104, 0xc00a1a00, 0x5120b284, 0x26802010, 0x80056b00, 
+	0x5a401082, 0x59c00504, 0x12804019, 0x2683c028, 0x25bc3fdd, 0x21c0015d, 
+	0x48400519, 0x26808010, 0x80057f00, 0x5a400c82, 0x50215000, 0x26804000, 
+	0x88057200, 0x2c0011c0, 0x2fc00000, 0x51a14304, 0x33800619, 0x2fc000c2, 
+	0x51a14384, 0x2fc000c2, 0x01800120, 0x80057f00, 0x2c4000c0, 0x2f057d04, 
+	0xc0098300, 0xe0400000, 0x2fc00180, 0x58401082, 0x5a400882, 0x2e800004, 
+	0x2ec00100, 0x01802f2c, 0x98058600, 0x2e802f00, 0x2600006c, 0x26bfffa8, 
+	0x55c00404, 0x2fc000c2, 0x33800619, 0x128000ad, 0x028000a8, 0x88058800, 
+	0x26000065, 0x80059200, 0x53c00000, 0x1280006d, 0x29c00166, 0x8005a400, 
+	0x02c00162, 0x50400000, 0x52207204, 0x26000125, 0x80058300, 0x4020b2a0, 
+	0x4020e2a8, 0x40211291, 0x402142a9, 0x2f059f04, 0xc00a1a00, 0x5220b280, 
+	0x52a0e280, 0x51211284, 0x52a14284, 0xc0058300, 0x2e800000, 0x50214500, 
+	0x10000040, 0x40214500, 0x52207300, 0x24000810, 0x8005b100, 0x24004010, 
+	0x8805b700, 0x58400802, 0x243fbfc0, 0x48400802, 0xc005b600, 0x24004010, 
+	0x8805b700, 0x58403042, 0x243fbfc0, 0x48403042, 0x253ffbd0, 0x40400092, 
+	0xc005ba00, 0x2e800140, 0x40216128, 0x402161a0, 0x50215800, 0x20010000, 
+	0x40215800, 0xc0070d00, 0x59401802, 0x29bc0010, 0x8008c000, 0x51a14b00, 
+	0x21c000c0, 0x2f05c704, 0xc0098300, 0x59c04880, 0x30000618, 0x200f0200, 
+	0x52214a80, 0x2603ffe0, 0x2a000520, 0x8805cf00, 0x20004000, 0x40003800, 
+	0x58400c42, 0x2a140018, 0x8805d500, 0x20010000, 0xc005d700, 0x58400c42, 
+	0x2000c000, 0x5a400842, 0x2dc00004, 0x40004100, 0x400041a0, 0x2c000040, 
+	0x40004000, 0x40004080, 0x52a14684, 0x58402142, 0x5a402542, 0x40214400, 
+	0x402144a0, 0x2c000000, 0x40001080, 0x2c3fffc0, 0x40003600, 0x2c000000, 
+	0x40003c80, 0x40003d80, 0x40004600, 0x40004880, 0x40004800, 0x40004900, 
+	0x5ac04880, 0x28140028, 0x80060e00, 0x59c07842, 0x58400080, 0x244000c0, 
+	0x40003c00, 0x40003d00, 0x59c07c42, 0x58400480, 0x244000c0, 0x40003c80, 
+	0x40003d80, 0x59c08042, 0x58400880, 0x25c000c0, 0x28100028, 0x88060600, 
+	0x40003d18, 0x59c08442, 0x58400c80, 0x244000c0, 0x40003d80, 0xc0061c00, 
+	0x40004618, 0x40004898, 0x59c08442, 0x58400c80, 0x25c000c0, 0x40004818, 
+	0x40004918, 0xc0061c00, 0x11800f0d, 0x12000014, 0x2f061204, 0xc0063100, 
+	0x40003c00, 0x2f061504, 0xc0063100, 0x40003d00, 0x2f061804, 0xc0063100, 
+	0x40003c80, 0x2f061b04, 0xc0063100, 0x40003d80, 0x24008008, 0x80065800, 
+	0x50215880, 0x24008000, 0x80064200, 0x2c400180, 0x59c03480, 0x018000d8, 
+	0x90062800, 0x11c000c0, 0x98062b00, 0xc0064200, 0x59c04080, 0x2a4000c0, 
+	0x80064200, 0x24bf7fc8, 0x51a14400, 0x52214480, 0x40008218, 0x400082a0, 
+	0xc0065c00, 0x55c004c2, 0x56400502, 0x264000e0, 0x55c004c2, 0x56c00502, 
+	0x26c000e8, 0x240003e0, 0x2583c020, 0x31800718, 0x204000c0, 0x258003e8, 
+	0x31800218, 0x204000c0, 0x2583c028, 0x31800118, 0x204000c0, 0xc0400182, 
+	0x12800210, 0x2d800240, 0x2e003000, 0x50400140, 0x54400540, 0x44400500, 
+	0x01800058, 0x88064500, 0x2d8000c0, 0x2e003480, 0x50400140, 0x54400540, 
+	0x44400500, 0x01800058, 0x88064c00, 0x50400140, 0x54400540, 0x40003700, 
+	0x50400140, 0x54400540, 0x40003780, 0xc0066b00, 0x50215880, 0x24008000, 
+	0x8008dc00, 0x2c400180, 0x51801000, 0x01c00018, 0x9808dc00, 0xe0400000, 
+	0x2ec00180, 0x25c000d8, 0x80078800, 0x2c000000, 0x40003880, 0x40003700, 
+	0x40003480, 0x40003780, 0x2c3fffc0, 0x40003500, 0x40003580, 0x2f066d04, 
+	0xc00a4a00, 0x2c000040, 0x40003880, 0x2f067104, 0xc00a5100, 0x24200020, 
+	0x88078800, 0x24001020, 0x8006e400, 0x24000060, 0x8006d200, 0x240000a0, 
+	0x8006d200, 0x50003800, 0x50003800, 0x24004000, 0x8006a600, 0x50003000, 
+	0x50003000, 0x25a00000, 0x8806a600, 0x25803fc0, 0x29801cd8, 0x8806a900, 
+	0x2f068604, 0xc00aeb00, 0x50008200, 0x50008200, 0x51808000, 0x51808000, 
+	0x004000c0, 0x88069900, 0x50008280, 0x50008280, 0x51808080, 0x51808080, 
+	0x004000c0, 0x88069900, 0x50008100, 0x50008100, 0x51808180, 0x51808180, 
+	0x40008200, 0x40008298, 0xc006a300, 0x50008200, 0x50008200, 0x51808280, 
+	0x51808280, 0x24400000, 0x8806a000, 0x01800058, 0x00000040, 0x40008200, 
+	0x40008298, 0x2f803fc0, 0x2f06a604, 0xc00aeb00, 0x58401842, 0x24000080, 
+	0x8806ac00, 0x50001080, 0x40003600, 0xc006d600, 0x50215800, 0x20000080, 
+	0x40215800, 0x50214880, 0x243ffec0, 0x40214880, 0x50214d00, 0x24000080, 
+	0x8806b200, 0x2c000040, 0x40008600, 0x40008680, 0x50008600, 0x50008600, 
+	0x29800040, 0x8006b800, 0x51214880, 0x21000110, 0x40214890, 0x24000080, 
+	0x8808d400, 0x50003600, 0x50003600, 0x11000040, 0x8806c800, 0x50214400, 
+	0x51a14480, 0xc006cf00, 0x2d800000, 0x5ac01142, 0x59401542, 0x10400140, 
+	0x19c00098, 0x2f06cf04, 0xc00b1300, 0x40008200, 0x40008298, 0xc006e400, 
+	0x50003600, 0x50003600, 0x11000040, 0x8006e400, 0x50003600, 0x50003600, 
+	0x2d800000, 0x5ac01142, 0x59401542, 0x10400140, 0x19c00098, 0x2f06df04, 
+	0xc00b1300, 0x40214400, 0x40214498, 0x50214500, 0x10000040, 0x40214500, 
+	0x24000220, 0x8006ec00, 0x50001000, 0xe0400000, 0x2d400180, 0x2c000040, 
+	0x24bf7fc8, 0xc0070e00, 0x24000120, 0x80066300, 0x51003480, 0x51003480, 
+	0x010000d0, 0x9806f600, 0x50003700, 0x50003700, 0x24400000, 0x8006e900, 
+	0x20808008, 0x5ac01802, 0x12800228, 0x2e003000, 0x2c000240, 0x51400100, 
+	0x55400500, 0x44400550, 0x00000040, 0x8806fb00, 0x2e003480, 0x2c0000c0, 
+	0x51400100, 0x55400500, 0x44400550, 0x00000040, 0x88070200, 0x51003700, 
+	0x51003700, 0x44400550, 0x51003780, 0x51003780, 0x44400550, 0x2c000000, 
+	0x2f071004, 0xc00aeb00, 0x52a14680, 0x51214600, 0x25018010, 0x80071a00, 
+	0x52008304, 0x52008304, 0x52808384, 0x52808384, 0x48401961, 0x48401d69, 
+	0x25800098, 0x8808d400, 0x51808204, 0x51808204, 0x52008280, 0x52008280, 
+	0x48401159, 0x48401560, 0x24400000, 0x80072600, 0x40214419, 0x402144a0, 
+	0x50214600, 0x24018000, 0x80073100, 0x2e008200, 0x30000700, 0x12c00020, 
+	0x54400500, 0x55400500, 0x243ffc00, 0x44400540, 0x44400550, 0x52a14500, 
+	0x51a14680, 0x5a4028c0, 0x59402cc0, 0x10400160, 0x19000010, 0x40215e00, 
+	0x40215e90, 0x26c00168, 0x80078800, 0x484028c0, 0x48402cd0, 0x52214600, 
+	0x260003e0, 0x29000060, 0x80074500, 0x290000a0, 0x80074500, 0x2e808200, 
+	0xc0074600, 0x2ea14400, 0x52400140, 0x56400540, 0x51400140, 0x55400540, 
+	0x484020e0, 0x484024d0, 0x5a4038c0, 0x26400120, 0x80077600, 0x5a4008c0, 
+	0x32000620, 0x5ac00cc0, 0x32800228, 0x12c00128, 0x402cad28, 0x5a4000c0, 
+	0x32000620, 0x5ac004c0, 0x32800228, 0x12c00128, 0x402cada8, 0x5a4020c0, 
+	0x32000620, 0x5ac024c0, 0x32800228, 0x12c00128, 0x402cae28, 0x5a4018c0, 
+	0x32000620, 0x5ac01cc0, 0x32800228, 0x12c00128, 0x402caea8, 0x522cad00, 
+	0x52acad80, 0x02c00160, 0x402caf28, 0x522cae00, 0x52acae80, 0x02c00160, 
+	0x26200028, 0x80077200, 0x522caf00, 0x12c00160, 0x5a4038c0, 0x02400128, 
+	0x98078800, 0xc0078000, 0x5a4034c0, 0x02c00100, 0x98078800, 0x52a14600, 
+	0x268003e8, 0x2a8000e8, 0x88078000, 0x12000120, 0x02c00100, 0x90078800, 
+	0x584030c0, 0x26800040, 0x88078800, 0x26800200, 0x88078800, 0x50215800, 
+	0x20001000, 0x40215800, 0x51801000, 0x51207100, 0x01c00098, 0xe04000c0, 
+	0x2c400180, 0x51801000, 0x2f079004, 0xc0098300, 0xe04000c0, 0x2c400180, 
+	0x2f079404, 0xc00aeb00, 0x25800098, 0x8808da00, 0x51a14c00, 0x293c0018, 
+	0x8007fc00, 0x40206f80, 0x58402402, 0x24004000, 0x8007fc00, 0x50214580, 
+	0x25000100, 0x8807fc00, 0x2e4000c4, 0x2f07a304, 0xc00ab000, 0x59401102, 
+	0x40215f10, 0x59401502, 0x40215f90, 0x2d800040, 0x4000cb18, 0x2da03800, 
+	0x4000cc18, 0x2d206a00, 0x50400080, 0x2d803180, 0x4000c018, 0x40001018, 
+	0x2e3fffc0, 0x51a14600, 0x258003d8, 0x2a800198, 0x8007b800, 0x52a15800, 
+	0x26880028, 0x8007bd00, 0x5ac02002, 0x26c00168, 0x8007bd00, 0x3180062c, 
+	0x26003fe8, 0x2403ffc0, 0x25800040, 0x11c000c0, 0x2e800000, 0x02400020, 
+	0x8c07c700, 0x12400020, 0x02c00100, 0x2c400100, 0x2e000000, 0xe0400000, 
+	0x2fc00180, 0xe0400140, 0x2f400184, 0xe0400140, 0x2fc000c2, 0x25800040, 
+	0x8007d000, 0x2dc00180, 0x5c400480, 0x2403ffc0, 0x8807be00, 0x51801000, 
+	0xe04000c0, 0x2c400180, 0x2f07d804, 0xc00aeb00, 0x25800098, 0x8807f400, 
+	0x50008200, 0x50008200, 0x51008280, 0x51008280, 0x48401102, 0x48401512, 
+	0x48402102, 0x48402512, 0x58402902, 0x59402d02, 0x10000040, 0x19000010, 
+	0x48402902, 0x48402d12, 0x40216000, 0x40216090, 0x59403502, 0x00400080, 
+	0x9807fc00, 0x58403102, 0x24000040, 0x8807fc00, 0x50215880, 0x20100000, 
+	0x40215880, 0xc007fb00, 0x58402102, 0x59402502, 0x48401102, 0x48401512, 
+	0x51a15800, 0x21a20018, 0x40215818, 0x50206f80, 0x51215800, 0x59c03842, 
+	0x21880018, 0x25c00098, 0x40215818, 0x2536efd0, 0x293fffd0, 0x59c03842, 
+	0x25c00098, 0x4840385a, 0x51215880, 0x59c01402, 0x21900018, 0x26c000d0, 
+	0x5a403c42, 0x258000a0, 0x88081000, 0x52a15880, 0x26900028, 0xc0082400, 
+	0x51a14600, 0x258003d8, 0x298000d8, 0x88082100, 0x51a14580, 0x25800118, 
+	0x88082400, 0x25800060, 0x80082400, 0x22820028, 0x51215980, 0x25000110, 
+	0x80081e00, 0x22810028, 0x263fffa0, 0x48403c62, 0xc0082400, 0x51a14c00, 
+	0x293c0018, 0x88081400, 0x59404042, 0x40215a10, 0x59c04442, 0x40215a98, 
+	0x5a404842, 0x40215b20, 0x51215800, 0x402158a8, 0x22c000a8, 0x80086600, 
+	0x2dac3700, 0x2f083104, 0xc00ab000, 0x52a14580, 0x26800128, 0x80083700, 
+	0x52a15880, 0x26a3bfe8, 0x402158a8, 0x2c000040, 0x4000a100, 0x4000a180, 
+	0x2ea15800, 0x2d800e00, 0x56400540, 0x27803fe0, 0x33800620, 0x01800098, 
+	0x88083c00, 0x26080010, 0x80085100, 0x51a14984, 0x24000040, 0x01c0001d, 
+	0x2d800040, 0x4000cb18, 0x4000cc19, 0x2d801e00, 0x11c00018, 0x4000c018, 
+	0x40001018, 0xe0400000, 0x2f400184, 0xe0001e00, 0x2fc00180, 0x2f085304, 
+	0xc00aeb00, 0x25800098, 0x80085a00, 0x2f085704, 0xc00ac600, 0x2d800080, 
+	0x40005018, 0xc0086c00, 0x51808200, 0x51808200, 0x51008280, 0x51008280, 
+	0x402c3918, 0x402c3990, 0x51ac3900, 0x512c3a00, 0x29c00098, 0x80086600, 
+	0x2d800040, 0x40005018, 0x51a14580, 0x25800218, 0x88002000, 0x51a14600, 
+	0x25804018, 0x88002000, 0x4840000a, 0xc0002000, 0x2d800040, 0x2f087104, 
+	0xc0098300, 0x2d400180, 0x2c000000, 0x4000cb00, 0x2c000180, 0x4000c000, 
+	0x2c400180, 0x31800780, 0x258000c4, 0x3180021d, 0x22c0019d, 0x32000234, 
+	0x224001a5, 0x31800234, 0x21c0019d, 0x2e000140, 0x2cac3b04, 0x58c01c42, 
+	0x2403ffc8, 0x284000c0, 0x80088900, 0x1080160d, 0x02000060, 0x88088100, 
+	0xc0002000, 0x24200008, 0x80088e00, 0x4840406b, 0x48404463, 0x4840485b, 
+	0xc0009000, 0x2c000100, 0x40005000, 0x58403042, 0x25800c00, 0x80002000, 
+	0x2c000400, 0x4000c800, 0x2c0000c0, 0x4000c900, 0x2c0011c0, 0x4000ca00, 
+	0x2c000000, 0x4000c800, 0x50214300, 0x31000600, 0x4000ca10, 0x4000ca00, 
+	0x2c000040, 0x4000c900, 0x2c002e40, 0x59401842, 0x25000410, 0x8808a700, 
+	0x2c002000, 0x4000c000, 0xe0400000, 0x2c400180, 0xc0002000, 0x51a14600, 
+	0x25802018, 0x8008bd00, 0x51a14680, 0x2a3c0018, 0x8008bd00, 0x5ac030c0, 
+	0x268003a8, 0x2a800028, 0x8808bd00, 0x2f08b704, 0xc00ab000, 0x2f802d00, 
+	0x2f800000, 0x2f800000, 0x2f800040, 0x2f802d00, 0xc008e000, 0x24bdffc8, 
+	0x2e800400, 0xc008dd00, 0x2e900000, 0xc008dd00, 0x2e800080, 0xc008dd00, 
+	0x2e800100, 0xc008dd00, 0x59400c02, 0x2abc0010, 0x8008c000, 0x2e800100, 
+	0xc008dd00, 0x2e802000, 0xc008dd00, 0x2a000128, 0x8008dc00, 0x2a000328, 
+	0x8008dc00, 0x2a000228, 0x8008dc00, 0xc0078800, 0x51a15800, 0x21a00018, 
+	0x40215818, 0x51a15880, 0x25bfbfd8, 0x40215898, 0x2f08e004, 0xc00ac600, 
+	0x2e800200, 0x51a15800, 0x21c00158, 0x40215818, 0x2f08e204, 0xc00aeb00, 
+	0x25800098, 0x8008f700, 0x51a15800, 0x21a00018, 0x40215818, 0x51a14600, 
+	0x25818018, 0x8008f500, 0x2e008200, 0x31800718, 0x12c000e0, 0x55c00540, 
+	0x55400540, 0x52214680, 0x12000220, 0x44400518, 0x44400510, 0x44400518, 
+	0x44400510, 0x2f08f704, 0xc00ac600, 0x50214600, 0x240003c0, 0x01800040, 
+	0x80090400, 0x01800080, 0x80090f00, 0x59c01802, 0x293c0018, 0x80091000, 
+	0x594044c0, 0x253fdfd0, 0x484044d0, 0xc0091000, 0x50008700, 0x2d800040, 
+	0x40009718, 0x40009798, 0x51809700, 0x25800058, 0x88090800, 0x40008700, 
+	0x40008780, 0x24bf7fc8, 0xc0091000, 0x24be7fc8, 0x2f091204, 0xc00b0300, 
+	0x51215880, 0x25008010, 0x80078800, 0x51215800, 0x29000410, 0x88078800, 
+	0x51001000, 0x25400090, 0x80078800, 0x58401842, 0x24000400, 0x8802ee00, 
+	0xc0078800, 0x2e3c0000, 0x402146a0, 0x40214c20, 0x512c3e80, 0x2503ffd0, 
+	0x29002010, 0x80092900, 0x59401c42, 0x25200010, 0x88093000, 0x52005200, 
+	0x51005280, 0x52805300, 0x26a07fe8, 0x48404062, 0x48404452, 0x4840486a, 
+	0x59402442, 0x25000090, 0x80093500, 0x2c3fffc0, 0x2cbfffc0, 0x59401042, 
+	0x40002010, 0x59401442, 0x40002090, 0x40002188, 0x2d000040, 0x40002110, 
+	0x51002100, 0x25400090, 0x88093c00, 0x51002200, 0x24a00010, 0x88096d00, 
+	0x58401046, 0x00200005, 0x300007c5, 0x10400085, 0x30800201, 0x40215908, 
+	0x30800101, 0x300000c5, 0x10400045, 0x10216605, 0x58c00402, 0x10800048, 
+	0x4840040a, 0x5ac01002, 0x24bfc028, 0x2a3fc008, 0x80095600, 0x32000748, 
+	0x1223a620, 0x40214c20, 0x24803fe8, 0x2a003fc8, 0x80095c00, 0x32000148, 
+	0x1223a620, 0x402146a0, 0x58c03100, 0x40214808, 0x58c00802, 0x40214608, 
+	0x2e000000, 0x248003c8, 0x288000c8, 0x88096b00, 0x52214300, 0x5ac01c02, 
+	0x26400020, 0x22400160, 0x40214320, 0x2e000040, 0x402145a0, 0x58c00002, 
+	0xc0400182, 0x2cbfffc0, 0x40215908, 0x51214f00, 0x50a14f80, 0x2c3fffc0, 
+	0x00afbbc8, 0x80094200, 0x58c03042, 0x24000c0c, 0x88089400, 0x2400400c, 
+	0x80002000, 0x52214580, 0x22000220, 0x402145a0, 0x58c03442, 0x40214688, 
+	0x58c03040, 0x40214808, 0x2c800000, 0x40214608, 0xc0400182, 0x40207008, 
+	0x2483ffd8, 0x8009af00, 0x50a14580, 0x24804008, 0x8809af00, 0x40206f98, 
+	0x40207090, 0x2c800080, 0x25080018, 0x80099200, 0x59402402, 0x25008010, 
+	0x80099200, 0x2c8000c0, 0x4000cb08, 0x25080018, 0x88099d00, 0x59401842, 
+	0x25000410, 0x80099d00, 0x51214600, 0x250003d0, 0x29000050, 0x80099d00, 
+	0x21900018, 0x51206f00, 0x10800090, 0x40206f08, 0x10a06a10, 0x51206980, 
+	0x4000cc10, 0x4000c018, 0x40400058, 0x2583ffd8, 0x50801000, 0x00c000c8, 
+	0x40207108, 0x24800058, 0x11c00058, 0x114000d0, 0x40206990, 0x51207080, 
+	0x51a06f80, 0x50a07000, 0xc0400182, 0x59401402, 0x25004010, 0x80400182, 
+	0x59c02406, 0x25803fdd, 0x11a7071d, 0x2d216284, 0x40002c11, 0x59400cc2, 
+	0x40002c90, 0x594008c2, 0x40002e10, 0x2d000000, 0x40002d90, 0x52215880, 
+	0x26008020, 0x8809ca00, 0x5a4000c6, 0x263fff21, 0x8009cb00, 0x2a003fa5, 
+	0x52001000, 0x12400125, 0x404000a3, 0x2d000040, 0x2e000004, 0x52001000, 
+	0x2d215804, 0x40002d10, 0x32000220, 0x224000a0, 0x48402ca2, 0x40002ea1, 
+	0xc0400182, 0x5a401402, 0x26004020, 0x800a0c00, 0x59c02402, 0x25803fdc, 
+	0x11a7071d, 0x51002e80, 0x484000d2, 0x51002d00, 0x25400090, 0x8009ff00, 
+	0x020001d0, 0x9009ef00, 0x2d216284, 0x01800050, 0x31800058, 0x114000d5, 
+	0x52c00082, 0x263fc028, 0x8809ef00, 0x028000a8, 0x404000aa, 0x8c09ef00, 
+	0x26803fe8, 0x22c00128, 0x484000ea, 0x01000050, 0x8009ff00, 0x59c02402, 
+	0x25bfc018, 0x5a4008c2, 0x32000620, 0x224000e0, 0x48402422, 0x2d215804, 
+	0x5a402c82, 0x263fc020, 0x224000a0, 0x48402ca2, 0x5a4004c2, 0x484050a2, 
+	0x59400482, 0x21004010, 0x48400492, 0x2d000000, 0x51a14c00, 0x2a3c0018, 
+	0x800a0500, 0x5a4028c0, 0x31000220, 0x51a14680, 0x2a3c0018, 0x800a0b00, 
+	0x5a4028c0, 0x26003fe0, 0x21400110, 0x484004d2, 0xc00a0e00, 0xc0400182, 
+	0x2d000fc0, 0x40002d10, 0xc0400182, 0x56c00504, 0x4440052b, 0x56c00504, 
+	0x4440052b, 0x56c00504, 0x4440052b, 0x56c00504, 0x4440052b, 0xc0400182, 
+	0x5a404846, 0x320005e5, 0x5ac04446, 0x328001e9, 0x22400165, 0x328005ed, 
+	0x5ac04042, 0x328001e8, 0x22c0016d, 0x2e804b00, 0x2d000004, 0x2d800004, 
+	0x26000068, 0x800a2a00, 0x11400117, 0x19c0015f, 0x3280006d, 0x26200021, 
+	0x800a2e00, 0x2280006d, 0x32000065, 0x328007e8, 0x880a2600, 0x5a404842, 
+	0x26007fe0, 0x11400115, 0x1980001d, 0x32000619, 0x2fc00100, 0x2fc000c2, 
+	0x32000611, 0x2fc00100, 0x2fc00082, 0xc0400182, 0x5a401c42, 0x2603ffe0, 
+	0x320000a0, 0x59404046, 0x32800611, 0x23c00160, 0x2fc00082, 0x5a404442, 
+	0x33800620, 0x2fc00100, 0x5a404842, 0x33800620, 0x2fc00100, 0xc0400182, 
+	0x52214d00, 0x26000060, 0x880a4a00, 0x52214880, 0x263fffa0, 0x402148a0, 
+	0xc0400182, 0x52215080, 0x52003884, 0x52003884, 0x25400090, 0x26000065, 
+	0x800aaa00, 0x02000060, 0x880a5200, 0x52214904, 0x12000065, 0x0a000025, 
+	0x40214921, 0x2e000004, 0x40004119, 0x400041a1, 0x400038a1, 0x2e000044, 
+	0x40004021, 0x400040a1, 0x52003804, 0x52003804, 0x22000065, 0x40003821, 
+	0x2e000044, 0x400038a1, 0x52003004, 0x52003004, 0x40003021, 0x52003084, 
+	0x52003084, 0x400030a1, 0x52003104, 0x52003104, 0x40003121, 0x52003184, 
+	0x52003184, 0x400031a1, 0x52003204, 0x52003204, 0x40003221, 0x52003780, 
+	0x52003780, 0x52003804, 0x52003804, 0x263fffa5, 0x40003821, 0x26000060, 
+	0x800aaa00, 0x52003a04, 0x52003a04, 0x2fc00102, 0x33800621, 0x52003a84, 
+	0x52003a84, 0x2fc00102, 0x33800621, 0x52004404, 0x52004404, 0x2fc00102, 
+	0x33800621, 0x52003b04, 0x52003b04, 0x2fc00102, 0x33800621, 0x52003b84, 
+	0x52003b84, 0x2fc00102, 0x33800621, 0x52004504, 0x52004504, 0x2fc00102, 
+	0x33800621, 0x51003480, 0x51003480, 0x2e003000, 0x52400104, 0x56400504, 
+	0x2fc00102, 0x01000050, 0x800aa400, 0x33800621, 0x01000050, 0x880a9c00, 
+	0x2e000044, 0x400037a1, 0x2e000044, 0x400038a1, 0x52215080, 0xc00a5200, 
+	0x52003780, 0x52003780, 0x52214884, 0x22000065, 0x402148a1, 0xc0400182, 
+	0x2e008000, 0x2e800200, 0x554004c4, 0x44400511, 0x02800068, 0x880ab200, 
+	0xc0400182, 0x50214600, 0x24018000, 0x800ac500, 0x2e008300, 0x30000700, 
+	0x12c00020, 0x55c00540, 0x54400540, 0x44400518, 0x44400500, 0x52a14680, 
+	0x12800328, 0x44400558, 0x44400540, 0xc0400182, 0x2d800380, 0x40008718, 
+	0x40008798, 0x51214e00, 0x51a14e80, 0x40008210, 0x40008298, 0x40008098, 
+	0x40008398, 0x2d800000, 0x40008118, 0x40008198, 0x51a14880, 0x25bffed8, 
+	0x40214898, 0x51a14d00, 0x25800098, 0x880ad500, 0x2d8001c0, 0x40008618, 
+	0x40008698, 0x2d8003c0, 0x40008718, 0x40008798, 0x51808600, 0x51808600, 
+	0x25000058, 0x880ade00, 0x51214880, 0x21000110, 0x40214890, 0x2d000100, 
+	0x40008610, 0x40008690, 0x25800098, 0x880ac600, 0xc0400182, 0x51a14880, 
+	0x25bffed8, 0x40214898, 0x51a14d00, 0x25800098, 0x880aee00, 0x2d8001c0, 
+	0x40008618, 0x40008698, 0x2e3fffc0, 0x02000060, 0x800afc00, 0x51808600, 
+	0x51808600, 0x29000058, 0x253ffed0, 0x800af500, 0x52214880, 0x22000120, 
+	0x402148a0, 0x2e000100, 0x40008620, 0x400086a0, 0xc0400182, 0x51a14800, 
+	0x25800818, 0x800b1200, 0x51a14680, 0x293c0018, 0x800b1200, 0x51214600, 
+	0x25018010, 0x880b1200, 0x594020c0, 0x584024c0, 0x484010d0, 0x40008210, 
+	0x484014c0, 0x40008280, 0xc0400182, 0x5ac00942, 0x59400d42, 0x26bffc28, 
+	0x12800428, 0x19000010, 0x02c00140, 0x09400098, 0x980b2000, 0x58400142, 
+	0x59c00542, 0x10400140, 0x19c00098, 0xc00b1300, 0xc0400182, 0x51a14380, 
+	0x25800c18, 0x29800818, 0x800be100, 0x51c00080, 0x25c000d8, 0x8008c400, 
+	0x263c0018, 0x32000520, 0x25801c18, 0x28001818, 0x880b2e00, 0x2d800400, 
+	0x318007d8, 0x21c000e0, 0x40044018, 0x59c00480, 0x24000058, 0x40046080, 
+	0x24000198, 0x300007c0, 0x40046400, 0x2c400100, 0x2a000120, 0x880b4400, 
+	0x2e203000, 0x2e044c04, 0x2f0b3e04, 0xc00a1100, 0x2f0b4004, 0xc00a1100, 
+	0x2f0b4204, 0xc00a1100, 0x2f0b4404, 0xc00a1100, 0x26800048, 0x800b4b00, 
+	0x51c00080, 0x25800098, 0x8008c600, 0x12000310, 0xc00b4f00, 0x51c00080, 
+	0x25800058, 0x8008c600, 0x12000110, 0x2a0000c4, 0x800b6000, 0x2a000144, 
+	0x800b6000, 0x2e044404, 0x2f0b5604, 0xc00a1100, 0x52040204, 0x26000065, 
+	0x800b5b00, 0x40040221, 0xc008c600, 0x12000220, 0x2e044a04, 0x2f0b5f04, 
+	0xc00a1100, 0xc00b7600, 0x2e044e04, 0x2f0b6304, 0xc00a1100, 0x26c00168, 
+	0x880b6700, 0x12000220, 0xc00b6800, 0x12000620, 0x2e045004, 0x2f0b6b04, 
+	0xc00a1100, 0x52040204, 0x26000065, 0x800b7000, 0x40040221, 0xc008c600, 
+	0x2e044a04, 0x2f0b7304, 0xc00a1100, 0x2e044c04, 0x2f0b7604, 0xc00a1100, 
+	0x2c080000, 0x40214b00, 0x50046100, 0x243f83c0, 0x59c00480, 0x25807c18, 
+	0x204000c0, 0x40046100, 0x58401842, 0x24000400, 0x880b8500, 0x2e002080, 
+	0x2e800080, 0x40046028, 0xc00ba100, 0x2e002f00, 0x50214380, 0x24000800, 
+	0x800b9800, 0x2d800040, 0x2f0b8c04, 0xc0098300, 0x2ec00080, 0x2d400180, 
+	0x11800150, 0x50400140, 0x24000100, 0x800b9500, 0x118004d8, 0x25bffc18, 
+	0x01800118, 0x40046018, 0x2e800140, 0xc00ba100, 0x50400080, 0x24000100, 
+	0x800b9f00, 0x2e800300, 0x40046028, 0x2e800100, 0xc00ba100, 0x2e800100, 
+	0x40046028, 0x2c000000, 0x40206f00, 0x2e206a04, 0xe0000100, 0x44400502, 
+	0x2c203800, 0x40206980, 0x50046100, 0x243ffdc0, 0x40046100, 0x400461a0, 
+	0x2c000c00, 0x4000cf00, 0x2c000040, 0x4000cd00, 0x21880028, 0x2f0bb304, 
+	0xc0098300, 0x2e050004, 0x000020a0, 0x800bba00, 0x50214980, 0x20400102, 
+	0x4000ce00, 0x2e000004, 0x51a14a80, 0x30000618, 0x20400102, 0x4000ce00, 
+	0x24003fd8, 0x4000ce00, 0x01c00160, 0x000020a0, 0x800bc900, 0x50214380, 
+	0x4000ce00, 0x24000800, 0x800bc900, 0x4000ce10, 0x02800068, 0xe0000780, 
+	0x24400000, 0x2c001a00, 0x4000cf00, 0x2c000000, 0x4000cd00, 0x40001018, 
+	0x21880018, 0x2f0bd304, 0xc0098300, 0x40001020, 0xe0400140, 0x2c400180, 
+	0x50214580, 0x20004000, 0x40214580, 0x58402402, 0x24008000, 0x800be100, 
+	0x25400090, 0x800be100, 0x40206a20, 0x2c000000, 0x40206a80, 0xc001b900 };
+
+#elif defined(A18)
+
+#warning using A18 tc code
+
+#define TC_ID 0
+#define TC_DVB 1
+#define TC_CAROUSEL_SUPPORT 1
+#define TC_CAROUSEL_DESIGN_VERSION_1 1
+#define TC_TSDEBUG_SUPPORT 1
+
+#define TRANSPORT_CONTROLLER_CODE_SIZE      1915
+
+static char const VERSION[] = "\nTC Version STPTI_DVBTCLoader \n\tRel: 2051. File: DVBTC4 Version: 0\n \n\tRel: 2051. File: TCINIT Version: 0\n \n\tRel: 2051. File: TS_HEADER Version: 0\n \n\tRel: 2051. File: SETUPDMA Version: 0\n \n\tRel: 2051. File: AF_ALTOUT Version: 0\n \n\tRel: 2051. File: AF_PROC Version: 0\n \n\tRel: 2051. File: CC_PROC Version: 0\n \n\tRel: 2051. File: SLT_SWIT Version: 0\n \n\tRel: 2051. File: RAW_PROC Version: 0\n \n\tRel: 2051. File: PES_PROC Version: 0\n \n\tRel: 2051. File: CAR_PROC Version: 0\n \n\tRel: 2051. File: STDCAM_PROC Version: 0\n \n\tRel: 2051. File: DMA_UNLD Version: 0\n \n\tRel: 2051. File: SIG_DEC Version: 0\n \n\tRel: 2051. File: STAT_BLK Version: 0\n \n\tRel: 2051. File: STREAMID Version: 0\n \n\tRel: 2051. File: ERR_PROC Version: 0\n \n\tRel: 2051. File: COMMON Version: 0\n \n\tRel: 2051. File: TCDMA Version: 0\n \n\tRel: 2051. File: SET_SCRAM Version: 0\n";
+
+
+#define TRANSPORT_CONTROLLER_VERSION    2
+
+
+static const unsigned int transport_controller_code[] = {
+	0x2c000040, 0x40003f80, 0x40009f00, 0x2fa65f04, 0x2c8001c0, 0x4020a188, 
+	0x2c800000, 0x40002108, 0x40003888, 0x4020a488, 0x2d200000, 0x40002010, 
+	0x2d001800, 0x40002090, 0x2c000000, 0x4000cb00, 0x4000c100, 0x2c000200, 
+	0x40008400, 0x40008480, 0x2c008840, 0x4000a000, 0x4000a080, 0x50003880, 
+	0x50802100, 0x5100c100, 0x20400040, 0x20400080, 0x88001700, 0x2c000000, 
+	0x4000cb00, 0x2c000040, 0x4000c100, 0x40008600, 0x40008680, 0x2c000000, 
+	0x4020a300, 0x4020a400, 0x4020a580, 0x2e20ae00, 0xe0000100, 0x44400500, 
+	0x120001a0, 0xe0000240, 0x44400500, 0x40209e00, 0x40209e80, 0x4000c900, 
+	0x40206700, 0x2ca06200, 0xe0000280, 0x44400440, 0x2c800000, 0x10800048, 
+	0x08800008, 0x5000c100, 0x24400000, 0x88003500, 0x50a0a000, 0x5020a080, 
+	0x10800048, 0x18000000, 0x4020a008, 0x4020a080, 0x51a0aa04, 0x25c000db, 
+	0x80005a00, 0x2f004504, 0xc006e800, 0x51a0aa80, 0x2f004804, 0xc006b600, 
+	0xe04000c0, 0x2fc00180, 0x2f004c04, 0xc0072200, 0x25800098, 0x80005300, 
+	0x2f005004, 0xc006fe00, 0x2d800000, 0x4020aa18, 0xc0001d00, 0x51808200, 
+	0x52808280, 0x484010da, 0x484014ea, 0x484020da, 0x484024ea, 0xc0001d00, 
+	0x2c203000, 0x40206180, 0x2ca62904, 0x50a62c80, 0x2483ffc8, 0x00002008, 
+	0x80006f00, 0x51a0a900, 0x24004018, 0x8005b500, 0x25003fd8, 0x2e0000c0, 
+	0x2ca62904, 0x58c01c42, 0x2403ffc8, 0x28400080, 0x80006f00, 0x1080110d, 
+	0x02000060, 0x88006700, 0xc005b500, 0x2d800040, 0x2f007204, 0xc006b600, 
+	0x2d400180, 0x2e0000c0, 0x2e8000c0, 0x02c00128, 0x4020ac28, 0x4020a290, 
+	0x2e002e80, 0x5ac01842, 0x26800428, 0x88007d00, 0x2e002040, 0x58404c42, 
+	0x24400000, 0x80008a00, 0x50a0a900, 0x25804008, 0x80008600, 0x24803fc8, 
+	0x01c00050, 0x80008a00, 0x26c00168, 0x80008a00, 0x298011d0, 0x88001d00, 
+	0x10c00100, 0x40001008, 0x11800040, 0x2f008f04, 0xc006b600, 0xe0400000, 
+	0x2d400180, 0x31000210, 0x21400190, 0x40209c10, 0x4020a390, 0x58400042, 
+	0x10000040, 0x48400042, 0x26800428, 0x88009b00, 0xc0001d00, 0x2c380000, 
+	0x2487ffd0, 0x2f009f04, 0xc0065400, 0x51209c00, 0x24200010, 0x8805d600, 
+	0x51a09f00, 0x258003d8, 0x01800058, 0x8800ac00, 0x2d801100, 0x40003798, 
+	0x2d800040, 0x40003898, 0x2d800000, 0x40003898, 0x2d800040, 0x2f00af04, 
+	0xc006b600, 0x24100010, 0x8000b400, 0x5020ae80, 0x20008000, 0x4020ae80, 
+	0x2d400180, 0x40209c90, 0x52209e80, 0x24000220, 0x8800c000, 0x50209f00, 
+	0x24004000, 0x8000c400, 0x22000220, 0x40209ea0, 0x26000060, 0x8800c400, 
+	0x51209f80, 0x293c0010, 0x80038000, 0xc000c400, 0x2d800000, 0x4020a418, 
+	0x50209f00, 0x258003c0, 0x25000c00, 0x8800cc00, 0x25c000d8, 0x80010300, 
+	0x25801000, 0x8800f500, 0x50209c80, 0x25002000, 0x8000f500, 0x24afffc8, 
+	0x51a0af80, 0x21800118, 0x24001000, 0x8800db00, 0x25000048, 0x8000e200, 
+	0x25bfff98, 0x24bfff88, 0xc000df00, 0x25000048, 0x8800e200, 0x21800058, 
+	0x20800048, 0x5120ae80, 0x21010010, 0x4020ae90, 0x4020af98, 0x25000108, 
+	0x8800ea00, 0x20800108, 0x51a0ae80, 0x21810018, 0x4020ae98, 0x20800088, 
+	0x59400c02, 0x29bc0010, 0x88074900, 0x51a09f00, 0x258003d8, 0x018000d8, 
+	0x80010300, 0x51a09c80, 0x25800418, 0x80010300, 0xc005f500, 0x25900008, 
+	0x8800fb00, 0x25800108, 0x80010300, 0x25800088, 0x80010300, 0x24afffc8, 
+	0x24bffe08, 0x51a0af80, 0x25bffed8, 0x4020af98, 0x51a0ae80, 0x21810018, 
+	0x4020ae98, 0x51209e80, 0x26800210, 0x88010900, 0x51209f00, 0x268003d0, 
+	0x80011500, 0x51a09f80, 0x4020b198, 0x293c0018, 0x80011500, 0x594010c0, 
+	0x4020b510, 0x594014c0, 0x4020b590, 0x2f011304, 0xc006e800, 0x2f011504, 
+	0xc006ef00, 0x51209e80, 0x25800210, 0x80011a00, 0x25800050, 0x80038000, 
+	0x51a09f00, 0x25800c18, 0x88012000, 0x2d000000, 0x4000c910, 0xc0012d00, 
+	0x2d0000c0, 0x4000c910, 0x2d000400, 0x4000c810, 0x2d0011c0, 0x4000ca10, 
+	0x2d000000, 0x4000c810, 0x51209c00, 0x31000610, 0x4000ca10, 0x51209c00, 
+	0x4000ca10, 0x52209c80, 0x25002020, 0x80015b00, 0x59400c02, 0x2abc0010, 
+	0x80014a00, 0x51400080, 0x26801020, 0x88013900, 0x26800050, 0x80014a00, 
+	0xc0013b00, 0x25000090, 0x80014a00, 0x51209f00, 0x26800810, 0x80014300, 
+	0x253fcfe0, 0x4000ca10, 0x2c000040, 0x4000c900, 0xc0016200, 0x258003d0, 
+	0x018000d8, 0x88015b00, 0x25001010, 0x88015b00, 0x253fcfe0, 0xc0016200, 
+	0x25c000d8, 0x80015500, 0x51209c80, 0x4000ca10, 0x2d000040, 0x4000c910, 
+	0x51209f00, 0x258003d0, 0x018000d8, 0x80015b00, 0xc005fb00, 0x51209f00, 
+	0x258003d0, 0x80015b00, 0x018000d8, 0x80015b00, 0xc0015b00, 0x51209c80, 
+	0x51a09f00, 0x25800c18, 0x80016200, 0x4000ca10, 0x2c000040, 0x4000c900, 
+	0x24000c10, 0x80061100, 0x50209e80, 0x24000040, 0x80017700, 0x5220a900, 
+	0x25804020, 0x80016c00, 0x25803fe0, 0xc0016d00, 0x2d8011c0, 0x2fc000c0, 
+	0x5a401802, 0x260000a0, 0x80017300, 0x2f017304, 0xc006da00, 0x52209c00, 
+	0x33800620, 0x2fc00100, 0x2fc00080, 0x25000810, 0x88017a00, 0xc001b600, 
+	0x2d800040, 0x2f017d04, 0xc006b600, 0x2dc00180, 0x24000040, 0x80018100, 
+	0x2fc000c0, 0x52a09c80, 0x26800428, 0x88018600, 0x2d802dc0, 0xc0018b00, 
+	0x02802dd8, 0x90061100, 0x26c000d8, 0x88018b00, 0xc001b600, 0x2f018d04, 
+	0xc006b600, 0x2d400180, 0x24000040, 0x80019100, 0x2fc00080, 0x01800058, 
+	0x52a0ae80, 0x26bfc028, 0x22c000a8, 0x4020aea8, 0x26800410, 0x8001ac00, 
+	0x02800198, 0x9801ac00, 0x32800230, 0x22c001a8, 0x4020b228, 0x31000230, 
+	0x21400190, 0x4020b290, 0x32000230, 0x224001a0, 0x4020b320, 0x24000040, 
+	0x8001ab00, 0x33800628, 0x2fc00140, 0x33800610, 0x2fc00080, 0x33800620, 
+	0x2fc00100, 0x01800198, 0x24000040, 0x8001b100, 0xe04000c0, 0x2fc00180, 
+	0xc001b600, 0xe04000c0, 0x2c400180, 0x52209c80, 0x26000420, 0x8001f000, 
+	0x51a09f00, 0x25820018, 0x8801f000, 0x51a09c80, 0x25800418, 0x8001f000, 
+	0x5120ae80, 0x26820008, 0x8801c500, 0x25008010, 0x8801ea00, 0x51209e80, 
+	0x25000050, 0x8801ea00, 0xc0064500, 0x24002010, 0x8001c900, 0x25000410, 
+	0x8001ea00, 0x50209c80, 0x260003c0, 0x26803c08, 0x32800728, 0x28400160, 
+	0x8801d800, 0x51209e80, 0x25000050, 0x8801ea00, 0x25000208, 0x8801d600, 
+	0x20800208, 0xc0053d00, 0x24bffdc8, 0xc005f200, 0x24bffdc8, 0x12800068, 
+	0x268003e8, 0x28400160, 0x8001ea00, 0x51a0af80, 0x25be01d8, 0x320001e0, 
+	0x21c00118, 0x328000e8, 0x21c00158, 0x4020af98, 0x51a09e80, 0x25800058, 
+	0x8005f200, 0x51a0ae00, 0x21800418, 0x4020ae18, 0x50209c80, 0x260003c0, 
+	0x32000120, 0x24bfc3c8, 0x20c00108, 0x20820008, 0x51a09f80, 0x29bc0018, 
+	0x8801f700, 0x51a0a500, 0x29bc0018, 0x8005f500, 0xc0053d00, 0x50209f00, 
+	0x258003c0, 0x25000c00, 0x8801fd00, 0x25c000d8, 0x80053d00, 0x51209f00, 
+	0x25000c10, 0x80020200, 0x2e000040, 0x4000c920, 0x50001000, 0x51a09f00, 
+	0x258003d8, 0x88020c00, 0x21880000, 0x2f020904, 0xc006b600, 0xe0400000, 
+	0x2dc00180, 0xc0053d00, 0x010000d8, 0x80021500, 0x24400000, 0x8004f200, 
+	0x01000098, 0x80022100, 0x01000058, 0x8003e700, 0xc0053d00, 0x51a0a400, 
+	0x21c000c0, 0x2f021904, 0xc006b600, 0xe0400000, 0x2fc00180, 0x2d800040, 
+	0x40209e18, 0x51a09e80, 0x25800218, 0x88038000, 0xc004f200, 0x51008204, 
+	0x250000d5, 0x268000c0, 0x114000ae, 0x250000d5, 0x52a0ae80, 0x24008028, 
+	0x80024e00, 0x25018008, 0x01818010, 0x80023500, 0x01810010, 0x98025900, 
+	0x51a0ae00, 0x21802018, 0x4020ae18, 0x24be7fc8, 0x2f023404, 0xc0073900, 
+	0xc0025900, 0x51a0a100, 0x52a09f80, 0x25000418, 0x88024300, 0x59c02140, 
+	0x59402540, 0x2fc000c0, 0x33800618, 0x2fc00080, 0x33800610, 0x2f024104, 
+	0xc0072200, 0x25800098, 0x88060900, 0x2d800040, 0x40209e18, 0x51008200, 
+	0x50008280, 0x40209d10, 0x40209d80, 0x48402150, 0x48402540, 0x40008210, 
+	0x40008280, 0xc0025900, 0x24018008, 0x80053d00, 0x2e000000, 0x2f025304, 
+	0xc0037500, 0x2e800000, 0x01018000, 0x80031000, 0x01010000, 0x80031000, 
+	0xc002e100, 0x52801000, 0x01000268, 0x90026000, 0x2dc00140, 0x2f025f04, 
+	0xc006b600, 0xc0060000, 0x2e001000, 0x2f026304, 0xc0037500, 0x258001c8, 
+	0x25800098, 0x88026900, 0x2e800240, 0x2c400140, 0xc0026b00, 0x5020a400, 
+	0x20400140, 0x2dc00000, 0x2f026e04, 0xc006b600, 0x028000a8, 0x30000230, 
+	0x20400180, 0x88060000, 0x02800068, 0x2c400180, 0x00000040, 0x88060000, 
+	0x2f800000, 0x2f800000, 0x2f800040, 0x02800068, 0x2c400180, 0x48402002, 
+	0x2fc00000, 0x59c01802, 0x25004018, 0x80028300, 0x25803fd8, 0x29c00018, 
+	0x88060000, 0x028000a8, 0x31000230, 0x21400190, 0x48401c12, 0x25400090, 
+	0x80028d00, 0x98028d00, 0x51801000, 0x01c000d0, 0x98060000, 0x33800610, 
+	0x2fc00080, 0x29802f00, 0x80029f00, 0x29802fc0, 0x80029f00, 0x29803c00, 
+	0x80029f00, 0x29803c40, 0x80029f00, 0x29803fc0, 0x80029f00, 0x29803c80, 
+	0x80029f00, 0x29803e00, 0x80029f00, 0x29802f80, 0x8802ab00, 0xe0400140, 
+	0x2fc00180, 0x2e800000, 0x253e7fc8, 0x20818010, 0x59c01c02, 0x01800298, 
+	0x48401c1a, 0x50001000, 0x24400000, 0x80035b00, 0xc0033100, 0x2c400180, 
+	0x02800068, 0x25800800, 0x8002cb00, 0x51a09f00, 0x25801018, 0x8802cb00, 
+	0x25800108, 0x8802bc00, 0x20800108, 0x24bfff48, 0x51a0ae80, 0x21810018, 
+	0x4020ae98, 0x51a0af80, 0x21800118, 0x4020af98, 0x5a400c02, 0x29bc0020, 
+	0x8005fb00, 0x25800400, 0x8802c600, 0x52400100, 0x26004020, 0x8005fb00, 
+	0x24bfff88, 0xc002d300, 0x52400100, 0x26008020, 0x8005fb00, 0x20800048, 
+	0xc002d300, 0x25800108, 0x8002d300, 0x25800088, 0x8802d300, 0x24bffe08, 
+	0x51a0ae80, 0x21810018, 0x4020ae98, 0x2fc00000, 0x028000a8, 0x2fc00180, 
+	0x2c400180, 0x2fc00000, 0x48402002, 0x24400000, 0x80030300, 0x59401c02, 
+	0x25400090, 0x8002e000, 0x01400010, 0x48401c12, 0x20808008, 0x58402002, 
+	0x51001000, 0x25400090, 0x80036100, 0x01c00010, 0x9002e800, 0x2c400080, 
+	0x26000088, 0x8002f200, 0x26c00168, 0x8802f800, 0x2ec00080, 0x2dc00080, 
+	0x21880018, 0x2f02f104, 0xc006b600, 0xc002f800, 0x26c00168, 0x88060000, 
+	0x2ec00000, 0x2dc00000, 0x2f02f804, 0xc006b600, 0x59402002, 0x01400010, 
+	0x48402012, 0xe0400000, 0x2fc00180, 0x02c00028, 0x25400090, 0x80030300, 
+	0x26c00168, 0x88060000, 0xc0036100, 0x58401c02, 0x24400000, 0x80030b00, 
+	0x000000c0, 0x48401c02, 0x253e7fc8, 0x20810010, 0xc0030d00, 0x253e7fc8, 
+	0x20818010, 0x51001000, 0x25400090, 0x80036100, 0x240001c8, 0x25000100, 
+	0x80032d00, 0x25000080, 0x88032d00, 0x59c00c02, 0x293c0018, 0x8005f500, 
+	0x25000040, 0x80031f00, 0x514000c0, 0x25008010, 0x8005fb00, 0x12000318, 
+	0xc0032300, 0x514000c0, 0x25008010, 0x8005fb00, 0x12000118, 0x55400500, 
+	0x54400500, 0x4000e410, 0x4000e480, 0x55400500, 0x54400500, 0x4000e510, 
+	0x4000e580, 0x2c080000, 0x4020a400, 0x50001000, 0x59c01c02, 0x00400018, 
+	0x48401c02, 0x26c00168, 0x88033800, 0x51a0a400, 0x52801000, 0x21c00158, 
+	0x2f033804, 0xc006b600, 0x25400097, 0x88033f00, 0xe0400140, 0x2fc00180, 
+	0x2e800000, 0xc0035b00, 0x2d400144, 0x01c000aa, 0x98033e00, 0xe04000c0, 
+	0x2fc00180, 0x2f034504, 0xc0072200, 0x25800098, 0x88060900, 0x52808200, 
+	0x51808280, 0x40008228, 0x40008298, 0x298000d1, 0x88035800, 0x01000095, 
+	0x2fc00180, 0x2fc00180, 0x2f035204, 0xc0072200, 0x25800098, 0x88060900, 
+	0x52808200, 0x51808280, 0x40008228, 0x40008298, 0x2e800000, 0xe0400082, 
+	0x2fc00180, 0x24018008, 0x00018000, 0x80036100, 0x58401c02, 0x24400000, 
+	0x80036500, 0x5020a100, 0x24000100, 0x88036600, 0xc004f200, 0x24be7fc8, 
+	0x51a09e00, 0x11800058, 0x40209e18, 0x51a0a100, 0x25000418, 0x88037300, 
+	0x51a09f80, 0x594020c0, 0x59c024c0, 0x2fc00080, 0x33800610, 0x2fc000c0, 
+	0x33800618, 0x2c000040, 0xc004f300, 0x5120a100, 0x25000110, 0x80037f00, 
+	0x52a0ae80, 0x26802028, 0x22c00128, 0x26003c08, 0x32000720, 0x23c00160, 
+	0x53801000, 0xc0400182, 0x50206a00, 0x25001000, 0x8803e600, 0x25000100, 
+	0x88038900, 0x51209e80, 0x25000050, 0x8804f200, 0xc003e400, 0x50206a00, 
+	0x25000400, 0x88038900, 0x2d200000, 0x40206a90, 0x5220ac00, 0x268000c0, 
+	0x2a400160, 0x8803e400, 0x25000200, 0x8003b700, 0x5a401c46, 0x26200025, 
+	0x8003a100, 0x5a404846, 0x320005a5, 0x5ac04446, 0x318001ad, 0x224000e7, 
+	0x328005ad, 0x59c04046, 0x3180019d, 0x21c0015f, 0xc003a300, 0x59c04046, 
+	0x5a404446, 0x52206b80, 0x01c00119, 0x8403e400, 0x29c00119, 0x8803ab00, 
+	0x52a06b00, 0x01c00161, 0x8403e400, 0x52206c80, 0x01c00119, 0x8403b700, 
+	0x29c00119, 0x8803b500, 0x52a06c00, 0x01c00161, 0x8403b700, 0x29c00161, 
+	0x8003b700, 0x2e800040, 0xc003dc00, 0x2d802f04, 0x253fc000, 0x8003cd00, 
+	0x32000610, 0x01c0011d, 0x5120a900, 0x26804010, 0x8803c000, 0x2d0011c0, 
+	0x2fc00080, 0x51209c00, 0x33800610, 0x2fc00080, 0x51209c80, 0x2fc00080, 
+	0x01800120, 0x8003cd00, 0x2d4000c0, 0x2f03cb04, 0xc006b600, 0xe0400080, 
+	0x2fc00180, 0x2ea06d00, 0x25000059, 0x25bfff9d, 0x54400540, 0x2fc00000, 
+	0x33800600, 0x0180009d, 0x8803d000, 0x25000050, 0x8003d800, 0x53c00140, 
+	0x2e800000, 0x50209e00, 0x10000040, 0x40209e00, 0x2c000000, 0x40206a00, 
+	0x40206a80, 0x5020ae00, 0x20010000, 0x4020ae00, 0x4020b728, 0xc004f200, 
+	0x2c000000, 0x40206a80, 0xc0001d00, 0x59401802, 0x29bc0010, 0x8005f500, 
+	0x51a0a400, 0x21c000c0, 0x2f03ee04, 0xc006b600, 0x58401842, 0x243c0000, 
+	0x30000600, 0x20084280, 0x40003800, 0x51a09f80, 0x584020c0, 0x5a4024c0, 
+	0x40008f00, 0x40008fa0, 0x40209d00, 0x40209da0, 0x24008008, 0x80042000, 
+	0x5020ae80, 0x24008000, 0x80040c00, 0x2c400180, 0x59c02480, 0x018000d8, 
+	0x98040c00, 0x59c03080, 0x2a4000c0, 0x80040c00, 0x24bf7fc8, 0x51a09d00, 
+	0x52209d80, 0x40008218, 0x400082a0, 0xc0042400, 0x12800210, 0x2d800140, 
+	0x2e003000, 0x54400540, 0x44400500, 0x01800058, 0x88040f00, 0x2d8000c0, 
+	0x2e003480, 0x54400540, 0x44400500, 0x01800058, 0x88041500, 0x2d800080, 
+	0x2e003700, 0x54400540, 0x44400500, 0x01800058, 0x88041b00, 0xc0043300, 
+	0x5020ae80, 0x24008000, 0x80061100, 0x2c400180, 0x51801000, 0x01c00018, 
+	0x98061100, 0xe0400000, 0x2ec00180, 0x25c000d8, 0x80053d00, 0x2c000000, 
+	0x40003880, 0x40003700, 0x40003480, 0x40003780, 0x2c3fffc0, 0x40003500, 
+	0x40003580, 0x59c07842, 0x58400080, 0x244000c0, 0x40003c00, 0x40003d00, 
+	0x59c07c42, 0x58400480, 0x244000c0, 0x40003c80, 0x40003d80, 0x58401842, 
+	0x243c0000, 0x28100000, 0x88044900, 0x59c08042, 0x58400880, 0x244000c0, 
+	0x40003d00, 0x59c08442, 0x58400c80, 0x244000c0, 0x40003d80, 0x5020a600, 
+	0x24000040, 0x80044d00, 0xc0044900, 0x5020a180, 0x243fff80, 0x4020a180, 
+	0x2c000040, 0x40003880, 0x51003780, 0x5020a180, 0x20000040, 0x4020a180, 
+	0x2c000100, 0x40008600, 0x40008680, 0x24000410, 0x80048d00, 0x50003000, 
+	0x24003fc0, 0x28003fc0, 0x80048d00, 0x50003a00, 0x51803a80, 0x52003800, 
+	0x26001c20, 0x02001c20, 0x98047200, 0x52003b00, 0x2a400020, 0x24400020, 
+	0x52003b80, 0x2a4000e0, 0x25c000e0, 0x2fc00000, 0x33800600, 0x2fc000c0, 
+	0x33800618, 0xe0000100, 0x2f800000, 0xc0047c00, 0x2fc00000, 0x33800600, 
+	0x2fc000c0, 0x33800618, 0x50003b00, 0x51803b80, 0x2fc00000, 0x33800600, 
+	0x2fc000c0, 0x33800618, 0x24b7ffc8, 0x5a401842, 0x260000a0, 0x88048100, 
+	0x20880008, 0x50003700, 0x24400000, 0x8804c600, 0x51803480, 0x2e003000, 
+	0x54400500, 0x2fc00000, 0x01800058, 0x80048d00, 0x33800600, 0x01800058, 
+	0x88048600, 0x253ffbd0, 0x24001010, 0x8004c600, 0x24000050, 0x8004c600, 
+	0x50003000, 0x24200000, 0x8004b900, 0x24000090, 0x8004b900, 0x25880008, 
+	0x8804bb00, 0x5020ae00, 0x20000080, 0x4020ae00, 0x50008600, 0x24000100, 
+	0x8804b800, 0x5020a180, 0x243ffec0, 0x4020a180, 0x5020a600, 0x24000080, 
+	0x8804a200, 0x2c000040, 0x40008600, 0x40008680, 0x50008600, 0x29800040, 
+	0x25bffed8, 0x8004a800, 0x51a0a180, 0x21800118, 0x4020a198, 0x2d800100, 
+	0x40008618, 0x24000080, 0x88060900, 0x50209d00, 0x51a09d80, 0x40008200, 
+	0x40008298, 0xc004d000, 0xc0060900, 0x2f800000, 0xc004bc00, 0x2f803fc0, 
+	0x2c000080, 0x40003880, 0x50209e00, 0x10000040, 0x40209e00, 0x50008f00, 
+	0x51808f80, 0x40209d00, 0x40209d98, 0xc004d000, 0x24000210, 0x8004d000, 
+	0x50001000, 0xe0400000, 0x2d400180, 0x50008600, 0x24000100, 0x8804b800, 
+	0x24bf7fc8, 0xc004f200, 0x24000110, 0x80044900, 0x24000410, 0x88044900, 
+	0x51003480, 0x010000d0, 0x9804da00, 0x51003700, 0x25400090, 0x8004cb00, 
+	0x20808008, 0x5ac01802, 0x12800228, 0x2e003000, 0x2c000140, 0x55400500, 
+	0x44400550, 0x00000040, 0x8804df00, 0x2e003480, 0x2c0000c0, 0x55400500, 
+	0x44400550, 0x00000040, 0x8804e500, 0x2e003700, 0x2c000080, 0x55400500, 
+	0x44400550, 0x00000040, 0x8804eb00, 0x50008600, 0x24000100, 0x8804b800, 
+	0x2c000000, 0x2f04f504, 0xc0072200, 0x52a09f80, 0x51209f00, 0x25018010, 
+	0x8004fd00, 0x52008304, 0x52808384, 0x48401961, 0x48401d69, 0x25800098, 
+	0x88060900, 0x51808204, 0x52008280, 0x48401159, 0x48401560, 0x24400000, 
+	0x80050700, 0x40209d19, 0x40209da0, 0x50209f00, 0x24018000, 0x80051200, 
+	0x2e008200, 0x30000700, 0x12c00020, 0x54400500, 0x55400500, 0x243ffc00, 
+	0x44400540, 0x44400550, 0x52a09e00, 0x51a09f80, 0x5a4028c0, 0x59402cc0, 
+	0x10400160, 0x19000010, 0x4020b400, 0x4020b490, 0x26c00168, 0x80053d00, 
+	0x484028c0, 0x48402cd0, 0x52209f00, 0x260003e0, 0x29000060, 0x80052600, 
+	0x290000a0, 0x80052600, 0x2e808200, 0xc0052700, 0x2ea09d00, 0x56400540, 
+	0x55400540, 0x484020e0, 0x484024d0, 0x5a4034c0, 0x02c00100, 0x98053d00, 
+	0x52a09f00, 0x268003e8, 0x2a8000e8, 0x88053500, 0x12000120, 0x02c00100, 
+	0x90053d00, 0x584030c0, 0x26800040, 0x88053d00, 0x26800200, 0x88053d00, 
+	0x5020ae00, 0x20001000, 0x4020ae00, 0x51801000, 0x51206900, 0x01c00098, 
+	0xe04000c0, 0x2c400180, 0x51801000, 0x2f054504, 0xc006b600, 0xe04000c0, 
+	0x2c400180, 0x2f054904, 0xc0072200, 0x25800098, 0x88060f00, 0x5120ae00, 
+	0x59c03842, 0x21880018, 0x25c00098, 0x4020ae18, 0x2536efd0, 0x293fffd0, 
+	0x59c03842, 0x25c00098, 0x4840385a, 0x5120ae80, 0x59c01402, 0x21900018, 
+	0x26c000d0, 0x5a403c42, 0x258000a0, 0x88055f00, 0x52a0ae80, 0x26900028, 
+	0xc0057000, 0x51a09f00, 0x258003d8, 0x298000d8, 0x88057000, 0x51a09e80, 
+	0x25800118, 0x88057000, 0x25800060, 0x80057000, 0x22820028, 0x5120af80, 
+	0x25000110, 0x80056d00, 0x22810028, 0x263fffa0, 0x48403c62, 0xc0057000, 
+	0x59404042, 0x4020b010, 0x59c04442, 0x4020b098, 0x5a404842, 0x4020b120, 
+	0x5120ae00, 0x4020aea8, 0x22c000a8, 0x8005ad00, 0x2da62500, 0x2f057d04, 
+	0xc006e800, 0x52a09e80, 0x26800128, 0x80058300, 0x52a0ae80, 0x26a3bfe8, 
+	0x4020aea8, 0x2ea0ae00, 0x2d800a00, 0x56400540, 0x27803fe0, 0x33800620, 
+	0x01800098, 0x88058500, 0x26080010, 0x80059a00, 0x51a0a284, 0x24000040, 
+	0x01c0001d, 0x2d800040, 0x4000cb18, 0x4000cc19, 0x2d801e00, 0x11c00018, 
+	0x4000c018, 0x40001018, 0xe0400000, 0x2f400184, 0xe0001e00, 0x2fc00180, 
+	0x2f059c04, 0xc0072200, 0x25800098, 0x8005a300, 0x2f05a004, 0xc006fe00, 
+	0x2d800080, 0x40005018, 0xc005b300, 0x51808200, 0x51008280, 0x40262718, 
+	0x40262790, 0x51a62700, 0x51262800, 0x29c00098, 0x8005ad00, 0x2d800040, 
+	0x40005018, 0x51a09e80, 0x25800218, 0x88001d00, 0x51a09f00, 0x25804018, 
+	0x88001d00, 0x4840000a, 0xc0001d00, 0x2d800040, 0x2f05b804, 0xc006b600, 
+	0x2d400180, 0x2c000000, 0x4000cb00, 0x2c000180, 0x4000c000, 0x2c400180, 
+	0x31800780, 0x258000c4, 0x3180021d, 0x22c0019d, 0x32000234, 0x224001a5, 
+	0x31800234, 0x21c0019d, 0x2e0000c0, 0x2ca62904, 0x58c01c42, 0x2403ffc8, 
+	0x284000c0, 0x8005d000, 0x1080110d, 0x02000060, 0x8805c800, 0xc0001d00, 
+	0x24200008, 0x8005d500, 0x4840406b, 0x48404463, 0x4840485b, 0xc0007400, 
+	0x2c000100, 0x40005000, 0x58403042, 0x25800c00, 0x80001d00, 0x2c000400, 
+	0x4000c800, 0x2c0000c0, 0x4000c900, 0x2c0011c0, 0x4000ca00, 0x2c000000, 
+	0x4000c800, 0x50209c00, 0x31000600, 0x4000ca10, 0x4000ca00, 0x2c000040, 
+	0x4000c900, 0x2c002e40, 0x59401842, 0x25000410, 0x8805ee00, 0x2c002000, 
+	0x4000c000, 0xe0400000, 0x2c400180, 0xc0001d00, 0x24bdffc8, 0x2e800400, 
+	0xc0061200, 0x2e900000, 0xc0061200, 0x2e800080, 0xc0061200, 0x2e800100, 
+	0xc0061200, 0x59400c02, 0x2abc0010, 0x8005f500, 0x2e800100, 0xc0061200, 
+	0x2e802000, 0xc0061200, 0x2a000128, 0x80061100, 0x2a000328, 0x80061100, 
+	0x2a000228, 0x80061100, 0xc0053d00, 0x51a0ae00, 0x21a00018, 0x4020ae18, 
+	0x51a0ae80, 0x25bfbfd8, 0x4020ae98, 0x2f061504, 0xc006fe00, 0x2e800200, 
+	0x51a0ae00, 0x21c00158, 0x4020ae18, 0x2f061704, 0xc0072200, 0x25800098, 
+	0x80062c00, 0x51a0ae00, 0x21a00018, 0x4020ae18, 0x51a09f00, 0x25818018, 
+	0x80062a00, 0x2e008200, 0x31800718, 0x12c000e0, 0x55c00540, 0x55400540, 
+	0x52209f80, 0x12000220, 0x44400518, 0x44400510, 0x44400518, 0x44400510, 
+	0x2f062c04, 0xc006fe00, 0x50209f00, 0x240003c0, 0x01800040, 0x80063900, 
+	0x01800080, 0x80064400, 0x59c01802, 0x293c0018, 0x80064500, 0x594034c0, 
+	0x253fdfd0, 0x484034d0, 0xc0064500, 0x50008700, 0x2d800040, 0x40009718, 
+	0x40009798, 0x51809700, 0x25800058, 0x88063d00, 0x40008700, 0x40008780, 
+	0x24bf7fc8, 0xc0064500, 0x24be7fc8, 0x2f064704, 0xc0073900, 0x5120ae80, 
+	0x25008010, 0x80053d00, 0x5120ae00, 0x29000410, 0x88053d00, 0x51001000, 
+	0x25400090, 0x80053d00, 0x58401842, 0x24000400, 0x8801ea00, 0xc0053d00, 
+	0x2e3c0000, 0x40209fa0, 0x4020a520, 0x51262c80, 0x2503ffd0, 0x29002010, 
+	0x80065e00, 0x59401c42, 0x25200010, 0x88066500, 0x52005200, 0x51005280, 
+	0x52805300, 0x26a07fe8, 0x48404062, 0x48404452, 0x4840486a, 0x59402442, 
+	0x25000090, 0x80066a00, 0x2c3fffc0, 0x2cbfffc0, 0x59401042, 0x40002010, 
+	0x59401442, 0x40002090, 0x40002188, 0x2d000040, 0x40002110, 0x51002100, 
+	0x25400090, 0x88067100, 0x51002200, 0x24a00010, 0x8806a000, 0x58401046, 
+	0x00200005, 0x300007c5, 0x10400085, 0x30800201, 0x4020af08, 0x30800101, 
+	0x30000085, 0x10400045, 0x1020b805, 0x58c00402, 0x10800048, 0x4840040a, 
+	0x5ac01002, 0x24803fe8, 0x2a003fc8, 0x80068f00, 0x32000088, 0x308000c8, 
+	0x12400060, 0x30800048, 0x12400060, 0x12229820, 0x40209fa0, 0x58c03100, 
+	0x4020a108, 0x58c00802, 0x40209f08, 0x2e000000, 0x248003c8, 0x288000c8, 
+	0x88069e00, 0x52209c00, 0x5ac01c02, 0x26400020, 0x22400160, 0x40209c20, 
+	0x2e000040, 0x40209ea0, 0x58c00002, 0xc0400182, 0x2cbfffc0, 0x4020af08, 
+	0x5120a800, 0x50a0a880, 0x2c3fffc0, 0x00afbbc8, 0x80067700, 0x58c03042, 
+	0x24000c0c, 0x8805db00, 0x2400400c, 0x80001d00, 0x52209e80, 0x22000220, 
+	0x40209ea0, 0x58c03442, 0x40209f88, 0x58c03040, 0x4020a108, 0x2c800000, 
+	0x40209f08, 0xc0400182, 0x40206808, 0x2483ffd8, 0x8006cf00, 0x40206798, 
+	0x40206890, 0x2c800080, 0x4000cb08, 0x51206700, 0x10800090, 0x40206708, 
+	0x10a06210, 0x51206180, 0x4000cc10, 0x4000c018, 0x40400058, 0x2583ffd8, 
+	0x50801000, 0x00c000c8, 0x40206908, 0x24800058, 0x11c00058, 0x114000d0, 
+	0x40206190, 0x51206880, 0x51a06780, 0x50a06800, 0xc0400182, 0x56c00504, 
+	0x4440052b, 0x56c00504, 0x4440052b, 0x56c00504, 0x4440052b, 0x56c00504, 
+	0x4440052b, 0xc0400182, 0x5a401c42, 0x2603ffe0, 0x320000a0, 0x59404046, 
+	0x32800611, 0x23c00160, 0x2fc00082, 0x5a404442, 0x33800620, 0x2fc00100, 
+	0x5a404842, 0x33800620, 0x2fc00100, 0xc0400182, 0x2e008000, 0x2e800200, 
+	0x554004c4, 0x44400511, 0x02800068, 0x8806ea00, 0xc0400182, 0x50209f00, 
+	0x24018000, 0x8006fd00, 0x2e008300, 0x30000700, 0x12c00020, 0x55c00540, 
+	0x54400540, 0x44400518, 0x44400500, 0x52a09f80, 0x12800328, 0x44400558, 
+	0x44400540, 0xc0400182, 0x2d800380, 0x40008718, 0x40008798, 0x5120a700, 
+	0x51a0a780, 0x40008210, 0x40008298, 0x40008098, 0x40008398, 0x2d800000, 
+	0x40008118, 0x40008198, 0x51a0a180, 0x25bffed8, 0x4020a198, 0x51a0a600, 
+	0x25800098, 0x88070d00, 0x2d8001c0, 0x40008618, 0x40008698, 0x2d8003c0, 
+	0x40008718, 0x40008798, 0x51808600, 0x25000058, 0x88071600, 0x5120a180, 
+	0x21000110, 0x4020a190, 0x2d000100, 0x40008610, 0x40008690, 0x25800098, 
+	0x8806fe00, 0xc0400182, 0x51a0a180, 0x25bffed8, 0x4020a198, 0x51a0a600, 
+	0x25800098, 0x88072500, 0x2d8001c0, 0x40008618, 0x40008698, 0x2e3fffc0, 
+	0x02000060, 0x80073200, 0x51808600, 0x29000058, 0x253ffed0, 0x80072c00, 
+	0x5220a180, 0x22000120, 0x4020a1a0, 0x2e000100, 0x40008620, 0x400086a0, 
+	0xc0400182, 0x51a0a100, 0x25800818, 0x80074800, 0x51a09f80, 0x293c0018, 
+	0x80074800, 0x51209f00, 0x25018010, 0x88074800, 0x594020c0, 0x584024c0, 
+	0x484010d0, 0x40008210, 0x484014c0, 0x40008280, 0xc0400182, 0x51a09c80, 
+	0x25800c18, 0x29800818, 0x80077a00, 0x51c00080, 0x25c000d8, 0x8005f900, 
+	0x263c0018, 0x32000520, 0x25801c18, 0x28001818, 0x88075600, 0x2d800400, 
+	0x318007d8, 0x21c000e0, 0x4000e018, 0x2c400100, 0x2a000120, 0x88076600, 
+	0x2e203000, 0x2e00ec04, 0x2f076004, 0xc006d100, 0x2f076204, 0xc006d100, 
+	0x2f076404, 0xc006d100, 0x2f076604, 0xc006d100, 0x26800048, 0x80076d00, 
+	0x51c00080, 0x25800098, 0x8005fb00, 0x12000310, 0xc0077100, 0x51c00080, 
+	0x25800058, 0x8005fb00, 0x12000110, 0x2e00e404, 0x2f077404, 0xc006d100, 
+	0x12000220, 0x2e00ea04, 0x2f077804, 0xc006d100, 0x2c080000, 0x4020a400, 
+	0xc0010300 };
+
+#else
+
+/* for all other we uses a none secure lite tc, but indeed
+ * this is wrong for 7109er arch. we should try here sec lite 1
+ */
+
+#define TC_ID 0
+#define TC_DVB 1
+#define TC_CAROUSEL_SUPPORT 1
+#define TC_TSDEBUG_SUPPORT 1
+#define TC_PROFILING 1
+
+#define TRANSPORT_CONTROLLER_CODE_SIZE      1920
+
+static char const VERSION[] = "\nTC Version STPTI_DVBTCLoader \n\tRel: 427216. File: DVBTC4 Version: 0\n \n\tRel: 427216. File: TCINIT Version: 0\n \n\tRel: 427216. File: TS_HEADER Version: 0\n \n\tRel: 427216. File: SETUPDMA Version: 0\n \n\tRel: 427216. File: AF_ALTOUT Version: 0\n \n\tRel: 427216. File: AF_PROC Version: 0\n \n\tRel: 427216. File: CC_PROC Version: 0\n \n\tRel: 427216. File: SLT_SWIT Version: 0\n \n\tRel: 427216. File: RAW_PROC Version: 0\n \n\tRel: 427216. File: PES_PROC Version: 0\n \n\tRel: 427216. File: CAR_PROC Version: 0\n \n\tRel: 427216. File: STDCAM_PROC Version: 0\n \n\tRel: 427216. File: DMA_UNLD Version: 0\n \n\tRel: 427216. File: SIG_DEC Version: 0\n \n\tRel: 427216. File: STAT_BLK Version: 0\n \n\tRel: 427216. File: STREAMID Version: 0\n \n\tRel: 427216. File: ERR_PROC Version: 0\n \n\tRel: 427216. File: COMMON Version: 0\n \n\tRel: 427216. File: TCDMA Version: 0\n \n\tRel: 427216. File: SET_SCRAM Version: 0\n";
+
+
+#define TRANSPORT_CONTROLLER_VERSION    2
+
 
 static const unsigned int transport_controller_code[] = {
-	0x51a00000, 0xc0000200, 0x2e800000, 0x40202ea8, 0x2ea00e80, 0x40002028, 
-	0x52a00c80, 0x269fffe8, 0x03000028, 0x80001000, 0x52a02f80, 0x52200c80, 
-	0x02c00128, 0x40202fa8, 0x2e800000, 0x40200ca8, 0x2e800040, 0x4000c128, 
-	0x5280c100, 0x26800068, 0x03000028, 0x88001200, 0x52a00100, 0x4000c028, 
-	0x52a00a80, 0x400020a8, 0x2f400180, 0x52a00204, 0x2ea00280, 0x2e400144, 
-	0xe0400142, 0x44400532, 0x32800230, 0x2f400144, 0x2ec00182, 0x22c001a8, 
-	0x2f400144, 0x2f800044, 0x52a00a80, 0x26bff828, 0x03000028, 0x80003900, 
-	0x2ec00182, 0x2687ffe8, 0x400021a8, 0x2e800040, 0x40002128, 0x52802100, 
-	0x26800068, 0x03000028, 0x88002f00, 0x52802200, 0x2e200000, 0x26c00128, 
-	0x03000028, 0x80003900, 0x2f800004, 0x52a00100, 0x028000e8, 0x52200200, 
-	0x02c0012c, 0x26800079, 0x03000028, 0x80004400, 0x52a02f80, 0x52200b80, 
-	0x03400128, 0x98005300, 0x2ec00182, 0x40202ea8, 0x52a00180, 0x12800068, 
-	0x402001a8, 0xe0400142, 0x2f400180, 0x52a02f80, 0x52200b80, 0x03400128, 
-	0x98006200, 0x52a00d80, 0x12800068, 0x40200da8, 0xc0006200, 0x52a02f80, 
-	0x12800068, 0x40202fa8, 0x52200204, 0x2ea00280, 0x2dc00144, 0xe0400102, 
-	0x57c004c2, 0x2f8011c0, 0x32800631, 0x2fc00140, 0x2ec00182, 0x27803fe8, 
-	0xe0400142, 0x2fc00180, 0xc0000600, 0x52a02f80, 0x12800068, 0x40202fa8, 
-	0xc0006600 };
-
-static const unsigned short int transport_controller_data[] = {
-	0x199c, 0x0000, 0x00bc, 0x0000, 0x0006, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-	0x0000 };
+	0x2c000040, 0x40003f80, 0x40009f00, 0x2fa67004, 0x2c8001c0, 0x4020a088, 
+	0x2c800000, 0x40002108, 0x40003888, 0x4020a388, 0x2d200000, 0x40002010, 
+	0x2d001800, 0x40002090, 0x2c000000, 0x4000cb00, 0x4000c100, 0x50003880, 
+	0x50802100, 0x5100c100, 0x20400040, 0x20400080, 0x88001100, 0x2c000000, 
+	0x4000cb00, 0x2c000040, 0x4000c100, 0x40008600, 0x40008680, 0x2c000000, 
+	0x4020a200, 0x4020a300, 0x2e20ad00, 0xe0000100, 0x44400500, 0x120001a0, 
+	0xe0000240, 0x44400500, 0x40209d00, 0x40209d80, 0x4000c900, 0x40206700, 
+	0x2ca06200, 0xe0000280, 0x44400440, 0x2c800000, 0x10800048, 0x08800008, 
+	0x5000c100, 0x24400000, 0x88002e00, 0x5020a380, 0x00800048, 0x88003a00, 
+	0x10000040, 0x00800400, 0x98004100, 0x2c0003c0, 0x30000040, 0x10266500, 
+	0x50c00000, 0x10800048, 0x08800008, 0x40400008, 0x2c000000, 0x4020a380, 
+	0x50a09f00, 0x50209f80, 0x10800048, 0x18000000, 0x40209f08, 0x40209f80, 
+	0x51a0a904, 0x25c000db, 0x80006200, 0x2f004d04, 0xc006e500, 0x51a0a980, 
+	0x2f005004, 0xc006b300, 0xe04000c0, 0x2fc00180, 0x2f005404, 0xc0072700, 
+	0x25800098, 0x80005b00, 0x2f005804, 0xc0070300, 0x2d800000, 0x4020a918, 
+	0xc0001700, 0x51808200, 0x52808280, 0x484010da, 0x484014ea, 0x484020da, 
+	0x484024ea, 0xc0001700, 0x2c203000, 0x40206180, 0x2ca63504, 0x50a63880, 
+	0x2483ffc8, 0x00002008, 0x80007700, 0x51a0a800, 0x24004018, 0x80059900, 
+	0x25003fd8, 0x2d8000c0, 0x2ca63504, 0x58c01c42, 0x2403ffc8, 0x28400080, 
+	0x80007700, 0x1080100d, 0x01800058, 0x88006f00, 0xc0059900, 0x2d800040, 
+	0x2f007a04, 0xc006b300, 0x2d400180, 0x4020a190, 0x2e002e80, 0x5ac01842, 
+	0x26800428, 0x88008100, 0x2e002040, 0x58405c42, 0x24400000, 0x80008e00, 
+	0x50a0a800, 0x25804008, 0x80008a00, 0x24803fc8, 0x01c00050, 0x80008e00, 
+	0x26c00168, 0x80008e00, 0x298011d0, 0x88001700, 0x10c00100, 0x40001008, 
+	0x11800040, 0x2f009304, 0xc006b300, 0xe0400000, 0x2d400180, 0x31000210, 
+	0x21400190, 0x40209b10, 0x4020a290, 0x58400042, 0x10000040, 0x48400042, 
+	0x26800428, 0x88009f00, 0xc0001700, 0x2c380000, 0x2487ffd0, 0x2f00a304, 
+	0xc0064a00, 0x51209b00, 0x24200010, 0x8805ba00, 0x51a09e00, 0x258003d8, 
+	0x01800058, 0x8800b000, 0x2d801100, 0x40003798, 0x2d800040, 0x40003898, 
+	0x2d800000, 0x40003898, 0x2d800040, 0x2f00b304, 0xc006b300, 0x24100010, 
+	0x8000b800, 0x5020ad80, 0x20008000, 0x4020ad80, 0x52209d80, 0x24000220, 
+	0x8800c200, 0x50209e00, 0x24004000, 0x8000c700, 0x22000220, 0x40209da0, 
+	0x26000060, 0x8800c700, 0x2d400180, 0x51209e80, 0x293c0010, 0x80037600, 
+	0xc000c900, 0x2c400180, 0x40209b80, 0x2d800000, 0x4020a318, 0x50209e00, 
+	0x258003c0, 0x25000c00, 0x8800d100, 0x25c000d8, 0x80010800, 0x25801000, 
+	0x8800fa00, 0x50209b80, 0x25002000, 0x8000fa00, 0x24afffc8, 0x51a0ae80, 
+	0x21800118, 0x24001000, 0x8800e000, 0x25000048, 0x8000e700, 0x25bfff98, 
+	0x24bfff88, 0xc000e400, 0x25000048, 0x8800e700, 0x21800058, 0x20800048, 
+	0x5120ad80, 0x21010010, 0x4020ad90, 0x4020ae98, 0x25000108, 0x8800ef00, 
+	0x20800108, 0x51a0ad80, 0x21810018, 0x4020ad98, 0x20800088, 0x59400c02, 
+	0x29bc0010, 0x88074e00, 0x51a09e00, 0x258003d8, 0x018000d8, 0x80010800, 
+	0x51a09b80, 0x25800418, 0x80010800, 0xc005eb00, 0x25900008, 0x88010000, 
+	0x25800108, 0x80010800, 0x25800088, 0x80010800, 0x24afffc8, 0x24bffe08, 
+	0x51a0ae80, 0x25bffed8, 0x4020ae98, 0x51a0ad80, 0x21810018, 0x4020ad98, 
+	0x51209d80, 0x26800210, 0x88010e00, 0x51209e00, 0x268003d0, 0x80011a00, 
+	0x51a09e80, 0x4020b098, 0x293c0018, 0x80011a00, 0x594010c0, 0x4020b410, 
+	0x594014c0, 0x4020b490, 0x2f011804, 0xc006e500, 0x2f011a04, 0xc006f400, 
+	0x51209d80, 0x25800210, 0x80011f00, 0x25800050, 0x80037600, 0x51a09e00, 
+	0x25800c18, 0x88012500, 0x2d000000, 0x4000c910, 0xc0013200, 0x2d0000c0, 
+	0x4000c910, 0x2d000400, 0x4000c810, 0x2d0011c0, 0x4000ca10, 0x2d000000, 
+	0x4000c810, 0x51209b00, 0x31000610, 0x4000ca10, 0x51209b00, 0x4000ca10, 
+	0x52209b80, 0x25002020, 0x80016000, 0x59400c02, 0x2abc0010, 0x80014f00, 
+	0x51400080, 0x26801020, 0x88013e00, 0x26800050, 0x80014f00, 0xc0014000, 
+	0x25000090, 0x80014f00, 0x51209e00, 0x26800810, 0x80014800, 0x253fcfe0, 
+	0x4000ca10, 0x2c000040, 0x4000c900, 0xc0016700, 0x258003d0, 0x018000d8, 
+	0x88016000, 0x25001010, 0x88016000, 0x253fcfe0, 0xc0016700, 0x25c000d8, 
+	0x80015a00, 0x51209b80, 0x4000ca10, 0x2d000040, 0x4000c910, 0x51209e00, 
+	0x258003d0, 0x018000d8, 0x80016000, 0xc005f100, 0x51209e00, 0x258003d0, 
+	0x80016000, 0x018000d8, 0x80016000, 0xc0016000, 0x51209b80, 0x51a09e00, 
+	0x25800c18, 0x80016700, 0x4000ca10, 0x2c000040, 0x4000c900, 0x24000c10, 
+	0x80060700, 0x50209d80, 0x24000040, 0x80017c00, 0x5220a800, 0x25804020, 
+	0x80017100, 0x25803fe0, 0xc0017200, 0x2d8011c0, 0x2fc000c0, 0x5a401802, 
+	0x260000a0, 0x80017800, 0x2f017804, 0xc006d700, 0x52209b00, 0x33800620, 
+	0x2fc00100, 0x2fc00080, 0x25000810, 0x88018100, 0x24400000, 0x8801e600, 
+	0xc001bf00, 0x2d800040, 0x2f018404, 0xc006b300, 0x2dc00180, 0x24000040, 
+	0x80018800, 0x2fc000c0, 0x52a09b80, 0x26800428, 0x88018d00, 0x2d802dc0, 
+	0xc0019400, 0x02802dd8, 0x90060700, 0x26c000d8, 0x88019400, 0x24000040, 
+	0x8001bf00, 0xc001e600, 0x2f019604, 0xc006b300, 0x2d400180, 0x24000040, 
+	0x80019a00, 0x2fc00080, 0x01800058, 0x52a0ad80, 0x26bfc028, 0x22c000a8, 
+	0x4020ada8, 0x26800410, 0x8001b500, 0x02800198, 0x9801b500, 0x32800230, 
+	0x22c001a8, 0x4020b128, 0x31000230, 0x21400190, 0x4020b190, 0x32000230, 
+	0x224001a0, 0x4020b220, 0x24000040, 0x8001b400, 0x33800628, 0x2fc00140, 
+	0x33800610, 0x2fc00080, 0x33800620, 0x2fc00100, 0x01800198, 0x24000040, 
+	0x8001ba00, 0xe04000c0, 0x2fc00180, 0xc001e600, 0xe04000c0, 0x2c400180, 
+	0x52209b80, 0x26000420, 0x8001e600, 0x51a09e00, 0x25820018, 0x8801e600, 
+	0x51a09b80, 0x25800418, 0x8001e600, 0x5120ad80, 0x26820008, 0x8801cb00, 
+	0x25008010, 0x8801e000, 0xc0063b00, 0x24002010, 0x8001cf00, 0x25000410, 
+	0x8001e000, 0x50209b80, 0x260003c0, 0x26803c08, 0x32800728, 0x28400160, 
+	0x8801db00, 0x25000208, 0x8801d900, 0x20800208, 0xc0052100, 0x24bffdc8, 
+	0xc005e800, 0x24bffdc8, 0x12800068, 0x268003e8, 0x28400160, 0x8805e800, 
+	0x50209b80, 0x260003c0, 0x32000120, 0x24bfc3c8, 0x20c00108, 0x20820008, 
+	0x51a09e80, 0x29bc0018, 0x8801ed00, 0x51a0a400, 0x29bc0018, 0x8005eb00, 
+	0xc0052100, 0x50209e00, 0x258003c0, 0x25000c00, 0x8801f300, 0x25c000d8, 
+	0x80052100, 0x51209e00, 0x25000c10, 0x8001f800, 0x2e000040, 0x4000c920, 
+	0x50001000, 0x51a09e00, 0x258003d8, 0x88020200, 0x21880000, 0x2f01ff04, 
+	0xc006b300, 0xe0400000, 0x2dc00180, 0xc0052100, 0x010000d8, 0x80020b00, 
+	0x24400000, 0x8004d600, 0x01000098, 0x80021700, 0x01000058, 0x8003cb00, 
+	0xc0052100, 0x51a0a300, 0x21c000c0, 0x2f020f04, 0xc006b300, 0xe0400000, 
+	0x2fc00180, 0x2d800040, 0x40209d18, 0x51a09d80, 0x25800218, 0x88037600, 
+	0xc004d600, 0x51008204, 0x250000d5, 0x268000c0, 0x114000ae, 0x250000d5, 
+	0x52a0ad80, 0x24008028, 0x80024400, 0x25018008, 0x01818010, 0x80022b00, 
+	0x01810010, 0x98024f00, 0x51a0ad00, 0x21802018, 0x4020ad18, 0x24be7fc8, 
+	0x2f022a04, 0xc0073e00, 0xc0024f00, 0x51a0a000, 0x52a09e80, 0x25000418, 
+	0x88023900, 0x59c02140, 0x59402540, 0x2fc000c0, 0x33800618, 0x2fc00080, 
+	0x33800610, 0x2f023704, 0xc0072700, 0x25800098, 0x8805ff00, 0x2d800040, 
+	0x40209d18, 0x51008200, 0x50008280, 0x40209c10, 0x40209c80, 0x48402150, 
+	0x48402540, 0x40008210, 0x40008280, 0xc0024f00, 0x24018008, 0x80052100, 
+	0x2e000000, 0x2f024904, 0xc0036b00, 0x2e800000, 0x01018000, 0x80030600, 
+	0x01010000, 0x80030600, 0xc002d700, 0x52801000, 0x01000268, 0x90025600, 
+	0x2dc00140, 0x2f025504, 0xc006b300, 0xc005f600, 0x2e001000, 0x2f025904, 
+	0xc0036b00, 0x258001c8, 0x25800098, 0x88025f00, 0x2e800240, 0x2c400140, 
+	0xc0026100, 0x5020a300, 0x20400140, 0x2dc00000, 0x2f026404, 0xc006b300, 
+	0x028000a8, 0x30000230, 0x20400180, 0x8805f600, 0x02800068, 0x2c400180, 
+	0x00000040, 0x8805f600, 0x2f800000, 0x2f800000, 0x2f800040, 0x02800068, 
+	0x2c400180, 0x48402002, 0x2fc00000, 0x59c01802, 0x25004018, 0x80027900, 
+	0x25803fd8, 0x29c00018, 0x8805f600, 0x028000a8, 0x31000230, 0x21400190, 
+	0x48401c12, 0x25400090, 0x80028300, 0x98028300, 0x51801000, 0x01c000d0, 
+	0x9805f600, 0x33800610, 0x2fc00080, 0x29802f00, 0x80029500, 0x29802fc0, 
+	0x80029500, 0x29803c00, 0x80029500, 0x29803c40, 0x80029500, 0x29803fc0, 
+	0x80029500, 0x29803c80, 0x80029500, 0x29803e00, 0x80029500, 0x29802f80, 
+	0x8802a100, 0xe0400140, 0x2fc00180, 0x2e800000, 0x253e7fc8, 0x20818010, 
+	0x59c01c02, 0x01800298, 0x48401c1a, 0x50001000, 0x24400000, 0x80035100, 
+	0xc0032700, 0x2c400180, 0x02800068, 0x25800800, 0x8002c100, 0x51a09e00, 
+	0x25801018, 0x8802c100, 0x25800108, 0x8802b200, 0x20800108, 0x24bfff48, 
+	0x51a0ad80, 0x21810018, 0x4020ad98, 0x51a0ae80, 0x21800118, 0x4020ae98, 
+	0x5a400c02, 0x29bc0020, 0x8005f100, 0x25800400, 0x8802bc00, 0x52400100, 
+	0x26004020, 0x8005f100, 0x24bfff88, 0xc002c900, 0x52400100, 0x26008020, 
+	0x8005f100, 0x20800048, 0xc002c900, 0x25800108, 0x8002c900, 0x25800088, 
+	0x8802c900, 0x24bffe08, 0x51a0ad80, 0x21810018, 0x4020ad98, 0x2fc00000, 
+	0x028000a8, 0x2fc00180, 0x2c400180, 0x2fc00000, 0x48402002, 0x24400000, 
+	0x8002f900, 0x59401c02, 0x25400090, 0x8002d600, 0x01400010, 0x48401c12, 
+	0x20808008, 0x58402002, 0x51001000, 0x25400090, 0x80035700, 0x01c00010, 
+	0x9002de00, 0x2c400080, 0x26000088, 0x8002e800, 0x26c00168, 0x8802ee00, 
+	0x2ec00080, 0x2dc00080, 0x21880018, 0x2f02e704, 0xc006b300, 0xc002ee00, 
+	0x26c00168, 0x8805f600, 0x2ec00000, 0x2dc00000, 0x2f02ee04, 0xc006b300, 
+	0x59402002, 0x01400010, 0x48402012, 0xe0400000, 0x2fc00180, 0x02c00028, 
+	0x25400090, 0x8002f900, 0x26c00168, 0x8805f600, 0xc0035700, 0x58401c02, 
+	0x24400000, 0x80030100, 0x000000c0, 0x48401c02, 0x253e7fc8, 0x20810010, 
+	0xc0030300, 0x253e7fc8, 0x20818010, 0x51001000, 0x25400090, 0x80035700, 
+	0x240001c8, 0x25000100, 0x80032300, 0x25000080, 0x88032300, 0x59c00c02, 
+	0x293c0018, 0x8005eb00, 0x25000040, 0x80031500, 0x514000c0, 0x25008010, 
+	0x8005f100, 0x12000318, 0xc0031900, 0x514000c0, 0x25008010, 0x8005f100, 
+	0x12000118, 0x55400500, 0x54400500, 0x4000e410, 0x4000e480, 0x55400500, 
+	0x54400500, 0x4000e510, 0x4000e580, 0x2c080000, 0x4020a300, 0x50001000, 
+	0x59c01c02, 0x00400018, 0x48401c02, 0x26c00168, 0x88032e00, 0x51a0a300, 
+	0x52801000, 0x21c00158, 0x2f032e04, 0xc006b300, 0x25400097, 0x88033500, 
+	0xe0400140, 0x2fc00180, 0x2e800000, 0xc0035100, 0x2d400144, 0x01c000aa, 
+	0x98033400, 0xe04000c0, 0x2fc00180, 0x2f033b04, 0xc0072700, 0x25800098, 
+	0x8805ff00, 0x52808200, 0x51808280, 0x40008228, 0x40008298, 0x298000d1, 
+	0x88034e00, 0x01000095, 0x2fc00180, 0x2fc00180, 0x2f034804, 0xc0072700, 
+	0x25800098, 0x8805ff00, 0x52808200, 0x51808280, 0x40008228, 0x40008298, 
+	0x2e800000, 0xe0400082, 0x2fc00180, 0x24018008, 0x00018000, 0x80035700, 
+	0x58401c02, 0x24400000, 0x80035b00, 0x5020a000, 0x24000100, 0x88035c00, 
+	0xc004d600, 0x24be7fc8, 0x51a09d00, 0x11800058, 0x40209d18, 0x51a0a000, 
+	0x25000418, 0x88036900, 0x51a09e80, 0x594020c0, 0x59c024c0, 0x2fc00080, 
+	0x33800610, 0x2fc000c0, 0x33800618, 0x2c000040, 0xc004d700, 0x5120a000, 
+	0x25000110, 0x80037500, 0x52a0ad80, 0x26802028, 0x22c00128, 0x26003c08, 
+	0x32000720, 0x23c00160, 0x53801000, 0xc0400182, 0x50206a00, 0x25000400, 
+	0x88037700, 0x2d000040, 0x40206b90, 0x25000040, 0x88038100, 0x51209d80, 
+	0x25000050, 0x8804d600, 0xc003c800, 0x25000080, 0x80039300, 0x2ea06a80, 
+	0x55c00540, 0x51000a00, 0x300007d8, 0x251fffd0, 0x02400010, 0x9803c400, 
+	0x2a400010, 0x88039300, 0x54400540, 0x51000a80, 0x300007c0, 0x318003d8, 
+	0x204000c0, 0x01400010, 0x9803c400, 0x52a06a00, 0x30000628, 0x2d802f00, 
+	0x01c00018, 0x52209e80, 0x2a3c0020, 0x8003a300, 0x2e3fffc0, 0x2ea06c00, 
+	0x12c00028, 0x54400540, 0x2fc00000, 0x33800600, 0x01800098, 0x88039d00, 
+	0xc003b600, 0x2e000000, 0x2ea06c00, 0x2d0000c0, 0x4000c910, 0x2d000400, 
+	0x4000c810, 0x54400540, 0x4000ca00, 0x2d000000, 0x4000c810, 0x30000600, 
+	0x4000ca00, 0x01800098, 0x54400540, 0x4000ca00, 0x30000600, 0x4000ca00, 
+	0x01800098, 0x8803b000, 0x50206a00, 0x24003c00, 0x40206a00, 0x2c000000, 
+	0x40206b80, 0x5020ad00, 0x20010000, 0x4020ad00, 0x263fffe0, 0x80052100, 
+	0x51a09d00, 0x11800058, 0x40209d18, 0xc004d600, 0x51209d80, 0x25000050, 
+	0x8804d600, 0xc003c800, 0x2d000000, 0x40206b90, 0xc0001700, 0x59401802, 
+	0x29bc0010, 0x8005eb00, 0x51a0a300, 0x21c000c0, 0x2f03d204, 0xc006b300, 
+	0x58401842, 0x243c0000, 0x30000600, 0x20084280, 0x40003800, 0x51a09e80, 
+	0x584020c0, 0x5a4024c0, 0x40008f00, 0x40008fa0, 0x40209c00, 0x40209ca0, 
+	0x24008008, 0x80040400, 0x5020ad80, 0x24008000, 0x8003f000, 0x2c400180, 
+	0x59c02480, 0x018000d8, 0x9803f000, 0x59c03080, 0x2a4000c0, 0x8003f000, 
+	0x24bf7fc8, 0x51a09c00, 0x52209c80, 0x40008218, 0x400082a0, 0xc0040800, 
+	0x12800210, 0x2d800140, 0x2e003000, 0x54400540, 0x44400500, 0x01800058, 
+	0x8803f300, 0x2d8000c0, 0x2e003480, 0x54400540, 0x44400500, 0x01800058, 
+	0x8803f900, 0x2d800080, 0x2e003700, 0x54400540, 0x44400500, 0x01800058, 
+	0x8803ff00, 0xc0041700, 0x5020ad80, 0x24008000, 0x80060700, 0x2c400180, 
+	0x51801000, 0x01c00018, 0x98060700, 0xe0400000, 0x2ec00180, 0x25c000d8, 
+	0x80052100, 0x2c000000, 0x40003880, 0x40003700, 0x40003480, 0x40003780, 
+	0x2c3fffc0, 0x40003500, 0x40003580, 0x59c04042, 0x58400080, 0x244000c0, 
+	0x40003c00, 0x40003d00, 0x59c04442, 0x58400480, 0x244000c0, 0x40003c80, 
+	0x40003d80, 0x58401842, 0x243c0000, 0x28100000, 0x88042d00, 0x59c04842, 
+	0x58400880, 0x244000c0, 0x40003d00, 0x59c04c42, 0x58400c80, 0x244000c0, 
+	0x40003d80, 0x5020a500, 0x24000040, 0x80043100, 0xc0042d00, 0x5020a080, 
+	0x243fff80, 0x4020a080, 0x2c000040, 0x40003880, 0x51003780, 0x5020a080, 
+	0x20000040, 0x4020a080, 0x2c000100, 0x40008600, 0x40008680, 0x24000410, 
+	0x80047100, 0x50003000, 0x24003fc0, 0x28003fc0, 0x80047100, 0x50003a00, 
+	0x51803a80, 0x52003800, 0x26001c20, 0x02001c20, 0x98045600, 0x52003b00, 
+	0x2a400020, 0x24400020, 0x52003b80, 0x2a4000e0, 0x25c000e0, 0x2fc00000, 
+	0x33800600, 0x2fc000c0, 0x33800618, 0xe0000100, 0x2f800000, 0xc0046000, 
+	0x2fc00000, 0x33800600, 0x2fc000c0, 0x33800618, 0x50003b00, 0x51803b80, 
+	0x2fc00000, 0x33800600, 0x2fc000c0, 0x33800618, 0x24b7ffc8, 0x5a401842, 
+	0x260000a0, 0x88046500, 0x20880008, 0x50003700, 0x24400000, 0x8804aa00, 
+	0x51803480, 0x2e003000, 0x54400500, 0x2fc00000, 0x01800058, 0x80047100, 
+	0x33800600, 0x01800058, 0x88046a00, 0x253ffbd0, 0x24001010, 0x8004aa00, 
+	0x24000050, 0x8004aa00, 0x50003000, 0x24200000, 0x80049d00, 0x24000090, 
+	0x80049d00, 0x25880008, 0x88049f00, 0x5020ad00, 0x20000080, 0x4020ad00, 
+	0x50008600, 0x24000100, 0x88049c00, 0x5020a080, 0x243ffec0, 0x4020a080, 
+	0x5020a500, 0x24000080, 0x88048600, 0x2c000040, 0x40008600, 0x40008680, 
+	0x50008600, 0x29800040, 0x25bffed8, 0x80048c00, 0x51a0a080, 0x21800118, 
+	0x4020a098, 0x2d800100, 0x40008618, 0x24000080, 0x8805ff00, 0x50209c00, 
+	0x51a09c80, 0x40008200, 0x40008298, 0xc004b400, 0xc005ff00, 0x2f800000, 
+	0xc004a000, 0x2f803fc0, 0x2c000080, 0x40003880, 0x50209d00, 0x10000040, 
+	0x40209d00, 0x50008f00, 0x51808f80, 0x40209c00, 0x40209c98, 0xc004b400, 
+	0x24000210, 0x8004b400, 0x50001000, 0xe0400000, 0x2d400180, 0x50008600, 
+	0x24000100, 0x88049c00, 0x24bf7fc8, 0xc004d600, 0x24000110, 0x80042d00, 
+	0x24000410, 0x88042d00, 0x51003480, 0x010000d0, 0x9804be00, 0x51003700, 
+	0x25400090, 0x8004af00, 0x20808008, 0x5ac01802, 0x12800228, 0x2e003000, 
+	0x2c000140, 0x55400500, 0x44400550, 0x00000040, 0x8804c300, 0x2e003480, 
+	0x2c0000c0, 0x55400500, 0x44400550, 0x00000040, 0x8804c900, 0x2e003700, 
+	0x2c000080, 0x55400500, 0x44400550, 0x00000040, 0x8804cf00, 0x50008600, 
+	0x24000100, 0x88049c00, 0x2c000000, 0x2f04d904, 0xc0072700, 0x52a09e80, 
+	0x51209e00, 0x25018010, 0x8004e100, 0x52008304, 0x52808384, 0x48401961, 
+	0x48401d69, 0x25800098, 0x8805ff00, 0x51808204, 0x52008280, 0x48401159, 
+	0x48401560, 0x24400000, 0x8004eb00, 0x40209c19, 0x40209ca0, 0x50209e00, 
+	0x24018000, 0x8004f600, 0x2e008200, 0x30000700, 0x12c00020, 0x54400500, 
+	0x55400500, 0x243ffc00, 0x44400540, 0x44400550, 0x52a09d00, 0x51a09e80, 
+	0x5a4028c0, 0x59402cc0, 0x10400160, 0x19000010, 0x4020b300, 0x4020b390, 
+	0x26c00168, 0x80052100, 0x484028c0, 0x48402cd0, 0x52209e00, 0x260003e0, 
+	0x29000060, 0x80050a00, 0x290000a0, 0x80050a00, 0x2e808200, 0xc0050b00, 
+	0x2ea09c00, 0x56400540, 0x55400540, 0x484020e0, 0x484024d0, 0x5a4034c0, 
+	0x02c00100, 0x98052100, 0x52a09e00, 0x268003e8, 0x2a8000e8, 0x88051900, 
+	0x12000120, 0x02c00100, 0x90052100, 0x584030c0, 0x26800040, 0x88052100, 
+	0x26800200, 0x88052100, 0x5020ad00, 0x20001000, 0x4020ad00, 0x51801000, 
+	0x51206900, 0x01c00098, 0xe04000c0, 0x2c400180, 0x51801000, 0x2f052904, 
+	0xc006b300, 0xe04000c0, 0x2c400180, 0x2f052d04, 0xc0072700, 0x25800098, 
+	0x88060500, 0x5120ad00, 0x59c03842, 0x21880018, 0x25c00098, 0x4020ad18, 
+	0x25336fd0, 0x293fffd0, 0x59c03842, 0x25c00098, 0x4840385a, 0x5120ad80, 
+	0x59c01402, 0x21900018, 0x26c000d0, 0x5a403c42, 0x258000a0, 0x88054300, 
+	0x52a0ad80, 0x26900028, 0xc0055400, 0x51a09e00, 0x258003d8, 0x298000d8, 
+	0x88055400, 0x51a09d80, 0x25800118, 0x88055400, 0x25800060, 0x80055400, 
+	0x22820028, 0x5120ae80, 0x25000110, 0x80055100, 0x22810028, 0x263fffa0, 
+	0x48403c62, 0xc0055400, 0x59405042, 0x4020af10, 0x59c05442, 0x4020af98, 
+	0x5a405842, 0x4020b020, 0x5120ad00, 0x4020ada8, 0x22c000a8, 0x80059100, 
+	0x2da63100, 0x2f056104, 0xc006e500, 0x52a09d80, 0x26800128, 0x80056700, 
+	0x52a0ad80, 0x26a3bfe8, 0x4020ada8, 0x2ea0ad00, 0x2d800900, 0x56400540, 
+	0x27803fe0, 0x33800620, 0x01800098, 0x88056900, 0x26080010, 0x80057e00, 
+	0x51a0a184, 0x24000040, 0x01c0001d, 0x2d800040, 0x4000cb18, 0x4000cc19, 
+	0x2d801e00, 0x11c00018, 0x4000c018, 0x40001018, 0xe0400000, 0x2f400184, 
+	0xe0001e00, 0x2fc00180, 0x2f058004, 0xc0072700, 0x25800098, 0x80058700, 
+	0x2f058404, 0xc0070300, 0x2d800080, 0x40005018, 0xc0059700, 0x51808200, 
+	0x51008280, 0x40263318, 0x40263390, 0x51a63300, 0x51263400, 0x29c00098, 
+	0x80059100, 0x2d800040, 0x40005018, 0x51a09d80, 0x25800218, 0x88001700, 
+	0x51a09e00, 0x25804018, 0x88001700, 0x4840000a, 0xc0001700, 0x2d800040, 
+	0x2f059c04, 0xc006b300, 0x2d400180, 0x2c000000, 0x4000cb00, 0x2c000180, 
+	0x4000c000, 0x2c400180, 0x31800780, 0x258000c4, 0x3180021d, 0x22c0019d, 
+	0x32000234, 0x224001a5, 0x31800234, 0x21c0019d, 0x2e0000c0, 0x2ca63504, 
+	0x58c01c42, 0x2403ffc8, 0x284000c0, 0x8005b400, 0x1080100d, 0x02000060, 
+	0x8805ac00, 0xc0001700, 0x24200008, 0x8005b900, 0x4840506b, 0x48405463, 
+	0x4840585b, 0xc0007b00, 0x2c000100, 0x40005000, 0x58403042, 0x25800c00, 
+	0x80001700, 0x2c000400, 0x4000c800, 0x2c0000c0, 0x4000c900, 0x2c0011c0, 
+	0x4000ca00, 0x2c000000, 0x4000c800, 0x50209b00, 0x31000600, 0x4000ca10, 
+	0x4000ca00, 0x2c000040, 0x4000c900, 0x2c002e40, 0x59401842, 0x25000410, 
+	0x8805d200, 0x2c002000, 0x4000c000, 0xe0400000, 0x2c400180, 0xc0001700, 
+	0x51a09e00, 0x25802018, 0x8005e800, 0x51a09e80, 0x2a3c0018, 0x8005e800, 
+	0x5ac030c0, 0x268003a8, 0x2a800028, 0x8805e800, 0x2f05e204, 0xc006e500, 
+	0x2f802d00, 0x2f800000, 0x2f800000, 0x2f800040, 0x2f802d00, 0xc0060b00, 
+	0x24bdffc8, 0x2e800400, 0xc0060800, 0x2e900000, 0xc0060800, 0x2e800080, 
+	0xc0060800, 0x2e800100, 0xc0060800, 0x59400c02, 0x2abc0010, 0x8005eb00, 
+	0x2e800100, 0xc0060800, 0x2e802000, 0xc0060800, 0x2a000128, 0x80060700, 
+	0x2a000328, 0x80060700, 0x2a000228, 0x80060700, 0xc0052100, 0x51a0ad00, 
+	0x21a00018, 0x4020ad18, 0x51a0ad80, 0x25bfbfd8, 0x4020ad98, 0x2f060b04, 
+	0xc0070300, 0x2e800200, 0x51a0ad00, 0x21c00158, 0x4020ad18, 0x2f060d04, 
+	0xc0072700, 0x25800098, 0x80062200, 0x51a0ad00, 0x21a00018, 0x4020ad18, 
+	0x51a09e00, 0x25818018, 0x80062000, 0x2e008200, 0x31800718, 0x12c000e0, 
+	0x55c00540, 0x55400540, 0x52209e80, 0x12000220, 0x44400518, 0x44400510, 
+	0x44400518, 0x44400510, 0x2f062204, 0xc0070300, 0x50209e00, 0x240003c0, 
+	0x01800040, 0x80062f00, 0x01800080, 0x80063a00, 0x59c01802, 0x293c0018, 
+	0x80063b00, 0x594034c0, 0x253fdfd0, 0x484034d0, 0xc0063b00, 0x50008700, 
+	0x2d800040, 0x40009718, 0x40009798, 0x51809700, 0x25800058, 0x88063300, 
+	0x40008700, 0x40008780, 0x24bf7fc8, 0xc0063b00, 0x24be7fc8, 0x2f063d04, 
+	0xc0073e00, 0x5120ad80, 0x25008010, 0x80052100, 0x5120ad00, 0x29000410, 
+	0x88052100, 0x51001000, 0x25400090, 0x80052100, 0x58401842, 0x24000400, 
+	0x8801e000, 0xc0052100, 0x2e3c0000, 0x40209ea0, 0x4020a420, 0x51263880, 
+	0x2503ffd0, 0x29002010, 0x80065400, 0x59401c42, 0x25200010, 0x88065b00, 
+	0x52005200, 0x51005280, 0x52805300, 0x26a07fe8, 0x48405062, 0x48405452, 
+	0x4840586a, 0x59402442, 0x25000090, 0x80066000, 0x2c3fffc0, 0x2cbfffc0, 
+	0x59401042, 0x40002010, 0x59401442, 0x40002090, 0x40002188, 0x2d000040, 
+	0x40002110, 0x51002100, 0x25400090, 0x88066700, 0x51002200, 0x24a00010, 
+	0x88069600, 0x58401046, 0x00200005, 0x300007c5, 0x10400085, 0x30800201, 
+	0x4020ae08, 0x30800101, 0x30000085, 0x10400045, 0x1020b605, 0x58c00402, 
+	0x10800048, 0x4840040a, 0x5ac01002, 0x24803fe8, 0x2a003fc8, 0x80068500, 
+	0x32000088, 0x308000c8, 0x12400060, 0x30800048, 0x12400060, 0x12229620, 
+	0x40209ea0, 0x58c03100, 0x4020a008, 0x58c00802, 0x40209e08, 0x2e000000, 
+	0x248003c8, 0x288000c8, 0x88069400, 0x52209b00, 0x5ac01c02, 0x26400020, 
+	0x22400160, 0x40209b20, 0x2e000040, 0x40209da0, 0x58c00002, 0xc0400182, 
+	0x2cbfffc0, 0x4020ae08, 0x5120a700, 0x50a0a780, 0x2c3fffc0, 0x00afbbc8, 
+	0x80066d00, 0x58c03042, 0x24000c0c, 0x8805bf00, 0x2400400c, 0x80001700, 
+	0x52a06a00, 0x24800068, 0x80001700, 0x2e000200, 0x40209da0, 0x24800328, 
+	0x30800788, 0x2ca63504, 0xe0400040, 0x1080100d, 0x58c03442, 0x40209e88, 
+	0x58c03040, 0x4020a008, 0x2c800000, 0x40209e08, 0xc0400182, 0x40206808, 
+	0x2483ffd8, 0x8006cc00, 0x40206798, 0x40206890, 0x2c800080, 0x4000cb08, 
+	0x51206700, 0x10800090, 0x40206708, 0x10a06210, 0x51206180, 0x4000cc10, 
+	0x4000c018, 0x40400058, 0x2583ffd8, 0x50801000, 0x00c000c8, 0x40206908, 
+	0x24800058, 0x11c00058, 0x114000d0, 0x40206190, 0x51206880, 0x51a06780, 
+	0x50a06800, 0xc0400182, 0x56c00504, 0x4440052b, 0x56c00504, 0x4440052b, 
+	0x56c00504, 0x4440052b, 0x56c00504, 0x4440052b, 0xc0400182, 0x5a401c42, 
+	0x2603ffe0, 0x320000a0, 0x59405046, 0x32800611, 0x23c00160, 0x2fc00082, 
+	0x5a405442, 0x33800620, 0x2fc00100, 0x5a405842, 0x33800620, 0x2fc00100, 
+	0xc0400182, 0x2e008000, 0x2e800200, 0x554004c4, 0x44400511, 0x02800068, 
+	0x8806e700, 0x2d800000, 0x52008000, 0x52808300, 0x2a400160, 0x8806f100, 
+	0x2d800040, 0x40008418, 0x40008498, 0xc0400182, 0x50209e00, 0x24018000, 
+	0x80070200, 0x2e008300, 0x30000700, 0x12c00020, 0x55c00540, 0x54400540, 
+	0x44400518, 0x44400500, 0x52a09e80, 0x12800328, 0x44400558, 0x44400540, 
+	0xc0400182, 0x2d800380, 0x40008718, 0x40008798, 0x5120a600, 0x51a0a680, 
+	0x40008210, 0x40008298, 0x40008098, 0x40008398, 0x2d800000, 0x40008118, 
+	0x40008198, 0x51a0a080, 0x25bffed8, 0x4020a098, 0x51a0a500, 0x25800098, 
+	0x88071200, 0x2d8001c0, 0x40008618, 0x40008698, 0x2d8003c0, 0x40008718, 
+	0x40008798, 0x51808600, 0x25000058, 0x88071b00, 0x5120a080, 0x21000110, 
+	0x4020a090, 0x2d000100, 0x40008610, 0x40008690, 0x25800098, 0x88070300, 
+	0xc0400182, 0x51a0a080, 0x25bffed8, 0x4020a098, 0x51a0a500, 0x25800098, 
+	0x88072a00, 0x2d8001c0, 0x40008618, 0x40008698, 0x2e3fffc0, 0x02000060, 
+	0x80073700, 0x51808600, 0x29000058, 0x253ffed0, 0x80073100, 0x5220a080, 
+	0x22000120, 0x4020a0a0, 0x2e000100, 0x40008620, 0x400086a0, 0xc0400182, 
+	0x51a0a000, 0x25800818, 0x80074d00, 0x51a09e80, 0x293c0018, 0x80074d00, 
+	0x51209e00, 0x25018010, 0x88074d00, 0x594020c0, 0x584024c0, 0x484010d0, 
+	0x40008210, 0x484014c0, 0x40008280, 0xc0400182, 0x51a09b80, 0x25800c18, 
+	0x29800818, 0x80077f00, 0x51c00080, 0x25c000d8, 0x8005ef00, 0x263c0018, 
+	0x32000520, 0x25801c18, 0x28001818, 0x88075b00, 0x2d800400, 0x318007d8, 
+	0x21c000e0, 0x4000e018, 0x2c400100, 0x2a000120, 0x88076b00, 0x2e203000, 
+	0x2e00ec04, 0x2f076504, 0xc006ce00, 0x2f076704, 0xc006ce00, 0x2f076904, 
+	0xc006ce00, 0x2f076b04, 0xc006ce00, 0x26800048, 0x80077200, 0x51c00080, 
+	0x25800098, 0x8005f100, 0x12000310, 0xc0077600, 0x51c00080, 0x25800058, 
+	0x8005f100, 0x12000110, 0x2e00e404, 0x2f077904, 0xc006ce00, 0x12000220, 
+	0x2e00ea04, 0x2f077d04, 0xc006ce00, 0x2c080000, 0x4020a300, 0xc0010800 };
+
+#endif
diff --git a/tdt/cvs/driver/pti/ts_makros.h b/tdt/cvs/driver/pti/ts_makros.h
new file mode 100644
index 0000000..601db1c
--- /dev/null
+++ b/tdt/cvs/driver/pti/ts_makros.h
@@ -0,0 +1,72 @@
+#ifndef ts_makros_123
+#define ts_makros_123
+
+/* ********************************************* */
+/* Helper Functions to access ts header fields   */
+/* ********************************************* */
+
+static inline u16 ts_pid ( const u8 * buf )
+{
+  return ( ( buf[1] & 0x1f ) << 8 ) + buf[2];
+}
+
+static inline u8 ts_cc ( const u8 * buf )
+{
+  return ( buf[3] & 0x0f );
+}
+
+static inline u8 ts_scrambled ( const u8 * buf )
+{
+  return ( buf[3] & 0xc0 );
+}
+
+static inline u8 ts_error ( const u8 * buf )
+{
+  return ( buf[1] & 0x80 );
+}
+
+static inline u8 ts_payload_unit ( const u8 * buf )
+{
+  return ( buf[1] & 0x40 );
+}
+
+static inline u8 ts_priority ( const u8 * buf )
+{
+  return ( buf[1] & 0x20 );
+}
+
+static inline u8 ts_adaptation ( const u8 * buf )
+{
+  return ( buf[3] & 0x30 );
+}
+
+static inline u8 ts_sync ( const u8 * buf )
+{
+  return ( buf[0]);
+}
+
+/* ********************************************* */
+/* TS Packet Checker functions                   */
+/* ********************************************* */
+
+static inline int getOutOfSync(u8* data, int num)
+{
+	int count = 0;
+	int vLoop;
+	
+  	for (vLoop = 0; vLoop < num; vLoop++)
+  	{
+		if (data[0] != 0x47)
+			count++;	
+		data += 188;
+	}
+	
+	return count;
+}
+
+static inline int isPacketValid(u8* data)
+{
+	return ((ts_sync(data) == 0x47) && (ts_error(data) == 0) );
+}
+
+#endif
-- 
2.1.4

